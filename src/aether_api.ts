// ===============================================================================
// GENERATED FILE: aether_api.ts
// Generated by AetherProtocolGenerator
// ===============================================================================
import  {
    AFuture, ARFuture 
}
from './aether_future';
import  {
    DataIn, DataOut, DataInOut, DataInOutStatic 
}
from './aether_datainout';
import  {
    FastMetaType, FastFutureContext, RemoteApi, FastMeta, SerializerPackNumber, DeserializerPackNumber, FastApiContextLocal, FastMetaApi, BytesConverter, RemoteApiFuture 
}
from './aether_fastmeta';
import  {
    UUID, URI, Uint8Array, AConsumer 
}
from './aether_types';
import  {
    ToString, AString 
}
from './aether_astring';
// NOTE: TextEncoder/TextDecoder should be available globally.
// --- Forward Declarations & Imports ---
// (Not strictly necessary in a single file)
// --- Generated Structures and APIs ---
// --- Generated Enum: AetherCodec ---
export enum AetherCodec  {
    TCP = 'TCP', WEBSOCKET = 'WEBSOCKET', UDP = 'UDP' 
}
export namespace AetherCodec  {
    export const META: FastMetaType<AetherCodec> = new class implements FastMetaType<AetherCodec>  {
        serialize(_sCtx: FastFutureContext, obj: AetherCodec, out: DataOut): void  {
            const values = Object.keys(AetherCodec).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): AetherCodec  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(AetherCodec).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum AetherCodec`);
            return AetherCodec[keys[ordinal] as keyof typeof AetherCodec] as AetherCodec;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: CryptoLib ---
export enum CryptoLib  {
    SODIUM = 'SODIUM', HYDROGEN = 'HYDROGEN' 
}
export namespace CryptoLib  {
    export const META: FastMetaType<CryptoLib> = new class implements FastMetaType<CryptoLib>  {
        serialize(_sCtx: FastFutureContext, obj: CryptoLib, out: DataOut): void  {
            const values = Object.keys(CryptoLib).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): CryptoLib  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(CryptoLib).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum CryptoLib`);
            return CryptoLib[keys[ordinal] as keyof typeof CryptoLib] as CryptoLib;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: PowMethod ---
export enum PowMethod  {
    AE_BCRYPT_CRC32 = 'AE_BCRYPT_CRC32' 
}
export namespace PowMethod  {
    export const META: FastMetaType<PowMethod> = new class implements FastMetaType<PowMethod>  {
        serialize(_sCtx: FastFutureContext, obj: PowMethod, out: DataOut): void  {
            const values = Object.keys(PowMethod).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): PowMethod  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(PowMethod).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum PowMethod`);
            return PowMethod[keys[ordinal] as keyof typeof PowMethod] as PowMethod;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: Status ---
export enum Status  {
    PENDING = 'PENDING', COMPLETED = 'COMPLETED', FAILED = 'FAILED' 
}
export namespace Status  {
    export const META: FastMetaType<Status> = new class implements FastMetaType<Status>  {
        serialize(_sCtx: FastFutureContext, obj: Status, out: DataOut): void  {
            const values = Object.keys(Status).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): Status  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(Status).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum Status`);
            return Status[keys[ordinal] as keyof typeof Status] as Status;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Structure: IPAddress ---
export abstract class IPAddress implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<IPAddress> = new class implements FastMetaType<IPAddress>  {
        serialize(sCtx_0: FastFutureContext, obj_1: IPAddress, _out_2: DataOut): void  {
            const typeId = typeof (obj_1 as any).getAetherTypeId === 'function' ? obj_1.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddress' with invalid type id $ {
                typeId
            }
            `);
            _out_2.writeByte(typeId);
            switch(typeId)  {
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_0, obj_1 as any as IPAddressV4, _out_2);
                break;
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_0, obj_1 as any as IPAddressV6, _out_2);
                break;
                default: throw new Error(`Cannot serialize 'IPAddress' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_0: FastFutureContext, in__3: DataIn): IPAddress  {
            const typeId = in__3.readUByte();
            switch(typeId)  {
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_0, in__3) as any as IPAddress;
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_0, in__3) as any as IPAddress;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddress'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddress(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Key ---
export abstract class Key implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Key> = new class implements FastMetaType<Key>  {
        serialize(sCtx_4: FastFutureContext, obj_5: Key, _out_6: DataOut): void  {
            const typeId = typeof (obj_5 as any).getAetherTypeId === 'function' ? obj_5.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Key' with invalid type id $ {
                typeId
            }
            `);
            _out_6.writeByte(typeId);
            switch(typeId)  {
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumChacha20Poly1305, _out_6);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSecretBox, _out_6);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenCurvePublic, _out_6);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumCurvePublic, _out_6);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenCurvePrivate, _out_6);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumCurvePrivate, _out_6);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumSignPublic, _out_6);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSignPublic, _out_6);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumSignPrivate, _out_6);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSignPrivate, _out_6);
                break;
                default: throw new Error(`Cannot serialize 'Key' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_4: FastFutureContext, in__7: DataIn): Key  {
            const typeId = in__7.readUByte();
            switch(typeId)  {
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Key'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Key(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetric ---
export abstract class KeyAsymmetric extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetric> = new class implements FastMetaType<KeyAsymmetric>  {
        serialize(sCtx_8: FastFutureContext, obj_10: KeyAsymmetric, _out_11: DataOut): void  {
            const typeId = typeof (obj_10 as any).getAetherTypeId === 'function' ? obj_10.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetric' with invalid type id $ {
                typeId
            }
            `);
            _out_11.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetric' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_9: FastFutureContext, in__12: DataIn): KeyAsymmetric  {
            const typeId = in__12.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetric'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetric(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetricPrivate ---
export abstract class KeyAsymmetricPrivate extends KeyAsymmetric implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetricPrivate> = new class implements FastMetaType<KeyAsymmetricPrivate>  {
        serialize(sCtx_13: FastFutureContext, obj_15: KeyAsymmetricPrivate, _out_16: DataOut): void  {
            const typeId = typeof (obj_15 as any).getAetherTypeId === 'function' ? obj_15.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_16.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_14: FastFutureContext, in__17: DataIn): KeyAsymmetricPrivate  {
            const typeId = in__17.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetricPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetricPrivate(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetricPublic ---
export abstract class KeyAsymmetricPublic extends KeyAsymmetric implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetricPublic> = new class implements FastMetaType<KeyAsymmetricPublic>  {
        serialize(sCtx_18: FastFutureContext, obj_20: KeyAsymmetricPublic, _out_21: DataOut): void  {
            const typeId = typeof (obj_20 as any).getAetherTypeId === 'function' ? obj_20.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_21.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_19: FastFutureContext, in__22: DataIn): KeyAsymmetricPublic  {
            const typeId = in__22.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetricPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetricPublic(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySign ---
export abstract class KeySign extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySign> = new class implements FastMetaType<KeySign>  {
        serialize(sCtx_23: FastFutureContext, obj_25: KeySign, _out_26: DataOut): void  {
            const typeId = typeof (obj_25 as any).getAetherTypeId === 'function' ? obj_25.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySign' with invalid type id $ {
                typeId
            }
            `);
            _out_26.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_24: FastFutureContext, in__27: DataIn): KeySign  {
            const typeId = in__27.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySign(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySignPrivate ---
export abstract class KeySignPrivate extends KeySign implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySignPrivate> = new class implements FastMetaType<KeySignPrivate>  {
        serialize(sCtx_28: FastFutureContext, obj_30: KeySignPrivate, _out_31: DataOut): void  {
            const typeId = typeof (obj_30 as any).getAetherTypeId === 'function' ? obj_30.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_31.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_29: FastFutureContext, in__32: DataIn): KeySignPrivate  {
            const typeId = in__32.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySignPrivate(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySignPublic ---
export abstract class KeySignPublic extends KeySign implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySignPublic> = new class implements FastMetaType<KeySignPublic>  {
        serialize(sCtx_33: FastFutureContext, obj_35: KeySignPublic, _out_36: DataOut): void  {
            const typeId = typeof (obj_35 as any).getAetherTypeId === 'function' ? obj_35.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_36.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_34: FastFutureContext, in__37: DataIn): KeySignPublic  {
            const typeId = in__37.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySignPublic(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySymmetric ---
export abstract class KeySymmetric extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySymmetric> = new class implements FastMetaType<KeySymmetric>  {
        serialize(sCtx_38: FastFutureContext, obj_40: KeySymmetric, _out_41: DataOut): void  {
            const typeId = typeof (obj_40 as any).getAetherTypeId === 'function' ? obj_40.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySymmetric' with invalid type id $ {
                typeId
            }
            `);
            _out_41.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySymmetric' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_39: FastFutureContext, in__42: DataIn): KeySymmetric  {
            const typeId = in__42.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySymmetric'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySymmetric(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeys ---
export abstract class PairKeys implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<PairKeys> = new class implements FastMetaType<PairKeys>  {
        serialize(sCtx_43: FastFutureContext, obj_44: PairKeys, _out_45: DataOut): void  {
            const typeId = typeof (obj_44 as any).getAetherTypeId === 'function' ? obj_44.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeys' with invalid type id $ {
                typeId
            }
            `);
            _out_45.writeByte(typeId);
            switch(typeId)  {
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysSign, _out_45);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysAsym, _out_45);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysAsymSigned, _out_45);
                break;
                default: throw new Error(`Cannot serialize 'PairKeys' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_43: FastFutureContext, in__46: DataIn): PairKeys  {
            const typeId = in__46.readUByte();
            switch(typeId)  {
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeys'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeys(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Sign ---
export abstract class Sign implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Sign> = new class implements FastMetaType<Sign>  {
        serialize(sCtx_47: FastFutureContext, obj_48: Sign, _out_49: DataOut): void  {
            const typeId = typeof (obj_48 as any).getAetherTypeId === 'function' ? obj_48.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Sign' with invalid type id $ {
                typeId
            }
            `);
            _out_49.writeByte(typeId);
            switch(typeId)  {
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_47, obj_48 as any as SignAE_ED25519, _out_49);
                break;
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_47, obj_48 as any as SignHYDROGEN, _out_49);
                break;
                default: throw new Error(`Cannot serialize 'Sign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_47: FastFutureContext, in__50: DataIn): Sign  {
            const typeId = in__50.readUByte();
            switch(typeId)  {
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_47, in__50) as any as Sign;
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_47, in__50) as any as Sign;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Sign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Sign(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Telemetry ---
export abstract class Telemetry implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Telemetry> = new class implements FastMetaType<Telemetry>  {
        serialize(sCtx_51: FastFutureContext, obj_52: Telemetry, _out_53: DataOut): void  {
            const typeId = typeof (obj_52 as any).getAetherTypeId === 'function' ? obj_52.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Telemetry' with invalid type id $ {
                typeId
            }
            `);
            _out_53.writeByte(typeId);
            switch(typeId)  {
                case 1: (TelemetryCPP as any).META_BODY.serialize(sCtx_51, obj_52 as any as TelemetryCPP, _out_53);
                break;
                default: throw new Error(`Cannot serialize 'Telemetry' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_51: FastFutureContext, in__54: DataIn): Telemetry  {
            const typeId = in__54.readUByte();
            switch(typeId)  {
                case 1: return (TelemetryCPP as any).META_BODY.deserialize(sCtx_51, in__54) as any as Telemetry;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Telemetry'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Telemetry(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofConfig ---
export abstract class WorkProofConfig implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<WorkProofConfig> = new class implements FastMetaType<WorkProofConfig>  {
        serialize(sCtx_55: FastFutureContext, obj_56: WorkProofConfig, _out_57: DataOut): void  {
            const typeId = typeof (obj_56 as any).getAetherTypeId === 'function' ? obj_56.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'WorkProofConfig' with invalid type id $ {
                typeId
            }
            `);
            _out_57.writeByte(typeId);
            switch(typeId)  {
                case 1: (WorkProofBCrypt as any).META_BODY.serialize(sCtx_55, obj_56 as any as WorkProofBCrypt, _out_57);
                break;
                default: throw new Error(`Cannot serialize 'WorkProofConfig' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_55: FastFutureContext, in__58: DataIn): WorkProofConfig  {
            const typeId = in__58.readUByte();
            switch(typeId)  {
                case 1: return (WorkProofBCrypt as any).META_BODY.deserialize(sCtx_55, in__58) as any as WorkProofConfig;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'WorkProofConfig'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofConfig(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: AccessGroup ---
export class AccessGroup implements ToString  {
    public readonly owner: UUID;
    public readonly id: number;
    public readonly data: UUID[];
    public static readonly META_BODY: FastMetaType<AccessGroup> = new class implements FastMetaType<AccessGroup>  {
        serialize(sCtx_59: FastFutureContext, obj_60: AccessGroup, _out_61: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_59, obj_60.owner, _out_61);
            _out_61.writeLong(obj_60.id);
            SerializerPackNumber.INSTANCE.put(_out_61, obj_60.data.length);
            for (const el_65 of obj_60.data)  {
                FastMeta.META_UUID.serialize(sCtx_59, el_65, _out_61);
                
            }
            
        }
        deserialize(sCtx_59: FastFutureContext, in__62: DataIn): AccessGroup  {
            let owner_67: UUID;
            let id_68: number;
            let data_69: UUID[];
            owner_67 = FastMeta.META_UUID.deserialize(sCtx_59, in__62);
            id_68 = in__62.readLong();
            const len_73 = DeserializerPackNumber.INSTANCE.put(in__62).valueOf();
            data_69 = new Array<UUID>(len_73);
            for (let idx_72 = 0;
            idx_72 < len_73;
            idx_72++)  {
                data_69[idx_72] = FastMeta.META_UUID.deserialize(sCtx_59, in__62);
                
            }
            return new AccessGroup(owner_67, id_68, data_69);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<AccessGroup> = AccessGroup.META_BODY;
    constructor(owner: UUID, id: number, data: UUID[])  {
        this.owner = owner;
        this.id = id;
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type AccessGroup.`);
        
    }
    public getOwner(): UUID  {
        return this.owner;
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getData(): UUID[]  {
        return this.data;
        
    }
    public dataContains(el: UUID): boolean  {
        return (this.data as UUID[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('AccessGroup(');
        result.add('owner:').add(this.owner);
        result.add(', ');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ClientInfo ---
export class ClientInfo implements ToString  {
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<ClientInfo> = new class implements FastMetaType<ClientInfo>  {
        serialize(sCtx_75: FastFutureContext, obj_76: ClientInfo, _out_77: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_75, obj_76.uid, _out_77);
            Cloud.META.serialize(sCtx_75, obj_76.cloud, _out_77);
            
        }
        deserialize(sCtx_75: FastFutureContext, in__78: DataIn): ClientInfo  {
            let uid_81: UUID;
            let cloud_82: Cloud;
            uid_81 = FastMeta.META_UUID.deserialize(sCtx_75, in__78);
            cloud_82 = Cloud.META.deserialize(sCtx_75, in__78);
            return new ClientInfo(uid_81, cloud_82);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ClientInfo> = ClientInfo.META_BODY;
    constructor(uid: UUID, cloud: Cloud)  {
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type ClientInfo.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('ClientInfo(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ClientStateForSave ---
export class ClientStateForSave implements ToString  {
    public readonly registrationUri: URI[];
    public readonly servers: ServerDescriptor[];
    public readonly clients: ClientInfo[];
    public readonly rootSigners: Key[];
    public readonly cryptoLib: CryptoLib;
    public readonly pingDuration: number;
    public readonly parentUid: UUID;
    public readonly countServersForRegistration: number;
    public readonly timeoutForConnectToRegistrationServer: number;
    public readonly uid: UUID;
    public readonly alias: UUID;
    public readonly masterKey: Key;
    public static readonly META_BODY: FastMetaType<ClientStateForSave> = new class implements FastMetaType<ClientStateForSave>  {
        serialize(sCtx_85: FastFutureContext, obj_86: ClientStateForSave, _out_87: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_87, obj_86.registrationUri.length);
            for (const el_89 of obj_86.registrationUri)  {
                FastMeta.META_URI.serialize(sCtx_85, el_89, _out_87);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_87, obj_86.servers.length);
            for (const el_91 of obj_86.servers)  {
                ServerDescriptor.META.serialize(sCtx_85, el_91, _out_87);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_87, obj_86.clients.length);
            for (const el_93 of obj_86.clients)  {
                ClientInfo.META.serialize(sCtx_85, el_93, _out_87);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_87, obj_86.rootSigners.length);
            for (const el_95 of obj_86.rootSigners)  {
                Key.META.serialize(sCtx_85, el_95, _out_87);
                
            }
            CryptoLib.META.serialize(sCtx_85, obj_86.cryptoLib, _out_87);
            _out_87.writeLong(obj_86.pingDuration);
            FastMeta.META_UUID.serialize(sCtx_85, obj_86.parentUid, _out_87);
            _out_87.writeInt(obj_86.countServersForRegistration);
            _out_87.writeLong(obj_86.timeoutForConnectToRegistrationServer);
            FastMeta.META_UUID.serialize(sCtx_85, obj_86.uid, _out_87);
            FastMeta.META_UUID.serialize(sCtx_85, obj_86.alias, _out_87);
            Key.META.serialize(sCtx_85, obj_86.masterKey, _out_87);
            
        }
        deserialize(sCtx_85: FastFutureContext, in__88: DataIn): ClientStateForSave  {
            let registrationUri_105: URI[];
            let servers_106: ServerDescriptor[];
            let clients_107: ClientInfo[];
            let rootSigners_108: Key[];
            let cryptoLib_109: CryptoLib;
            let pingDuration_110: number;
            let parentUid_111: UUID;
            let countServersForRegistration_112: number;
            let timeoutForConnectToRegistrationServer_113: number;
            let uid_114: UUID;
            let alias_115: UUID;
            let masterKey_116: Key;
            const len_118 = DeserializerPackNumber.INSTANCE.put(in__88).valueOf();
            registrationUri_105 = new Array<URI>(len_118);
            for (let idx_117 = 0;
            idx_117 < len_118;
            idx_117++)  {
                registrationUri_105[idx_117] = FastMeta.META_URI.deserialize(sCtx_85, in__88);
                
            }
            const len_121 = DeserializerPackNumber.INSTANCE.put(in__88).valueOf();
            servers_106 = new Array<ServerDescriptor>(len_121);
            for (let idx_120 = 0;
            idx_120 < len_121;
            idx_120++)  {
                servers_106[idx_120] = ServerDescriptor.META.deserialize(sCtx_85, in__88);
                
            }
            const len_124 = DeserializerPackNumber.INSTANCE.put(in__88).valueOf();
            clients_107 = new Array<ClientInfo>(len_124);
            for (let idx_123 = 0;
            idx_123 < len_124;
            idx_123++)  {
                clients_107[idx_123] = ClientInfo.META.deserialize(sCtx_85, in__88);
                
            }
            const len_127 = DeserializerPackNumber.INSTANCE.put(in__88).valueOf();
            rootSigners_108 = new Array<Key>(len_127);
            for (let idx_126 = 0;
            idx_126 < len_127;
            idx_126++)  {
                rootSigners_108[idx_126] = Key.META.deserialize(sCtx_85, in__88);
                
            }
            cryptoLib_109 = CryptoLib.META.deserialize(sCtx_85, in__88);
            pingDuration_110 = in__88.readLong();
            parentUid_111 = FastMeta.META_UUID.deserialize(sCtx_85, in__88);
            countServersForRegistration_112 = in__88.readInt();
            timeoutForConnectToRegistrationServer_113 = in__88.readLong();
            uid_114 = FastMeta.META_UUID.deserialize(sCtx_85, in__88);
            alias_115 = FastMeta.META_UUID.deserialize(sCtx_85, in__88);
            masterKey_116 = Key.META.deserialize(sCtx_85, in__88);
            return new ClientStateForSave(registrationUri_105, servers_106, clients_107, rootSigners_108, cryptoLib_109, pingDuration_110, parentUid_111, countServersForRegistration_112, timeoutForConnectToRegistrationServer_113, uid_114, alias_115, masterKey_116);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ClientStateForSave> = ClientStateForSave.META_BODY;
    constructor(registrationUri: URI[], servers: ServerDescriptor[], clients: ClientInfo[], rootSigners: Key[], cryptoLib: CryptoLib, pingDuration: number, parentUid: UUID, countServersForRegistration: number, timeoutForConnectToRegistrationServer: number, uid: UUID, alias: UUID, masterKey: Key)  {
        this.registrationUri = registrationUri;
        this.servers = servers;
        this.clients = clients;
        this.rootSigners = rootSigners;
        this.cryptoLib = cryptoLib;
        this.pingDuration = pingDuration;
        this.parentUid = parentUid;
        this.countServersForRegistration = countServersForRegistration;
        this.timeoutForConnectToRegistrationServer = timeoutForConnectToRegistrationServer;
        this.uid = uid;
        this.alias = alias;
        this.masterKey = masterKey;
        if (registrationUri === null || registrationUri === undefined) throw new Error(`Field 'registrationUri' cannot be null for type ClientStateForSave.`);
        if (servers === null || servers === undefined) throw new Error(`Field 'servers' cannot be null for type ClientStateForSave.`);
        if (clients === null || clients === undefined) throw new Error(`Field 'clients' cannot be null for type ClientStateForSave.`);
        if (rootSigners === null || rootSigners === undefined) throw new Error(`Field 'rootSigners' cannot be null for type ClientStateForSave.`);
        if (cryptoLib === null || cryptoLib === undefined) throw new Error(`Field 'cryptoLib' cannot be null for type ClientStateForSave.`);
        if (masterKey === null || masterKey === undefined) throw new Error(`Field 'masterKey' cannot be null for type ClientStateForSave.`);
        
    }
    public getRegistrationUri(): URI[]  {
        return this.registrationUri;
        
    }
    public registrationUriContains(el: URI): boolean  {
        return (this.registrationUri as URI[]).includes(el as any);
        
    }
    public getServers(): ServerDescriptor[]  {
        return this.servers;
        
    }
    public serversContains(el: ServerDescriptor): boolean  {
        return (this.servers as ServerDescriptor[]).includes(el as any);
        
    }
    public getClients(): ClientInfo[]  {
        return this.clients;
        
    }
    public clientsContains(el: ClientInfo): boolean  {
        return (this.clients as ClientInfo[]).includes(el as any);
        
    }
    public getRootSigners(): Key[]  {
        return this.rootSigners;
        
    }
    public rootSignersContains(el: Key): boolean  {
        return (this.rootSigners as Key[]).includes(el as any);
        
    }
    public getCryptoLib(): CryptoLib  {
        return this.cryptoLib;
        
    }
    public getPingDuration(): number  {
        return this.pingDuration;
        
    }
    public getParentUid(): UUID  {
        return this.parentUid;
        
    }
    public getCountServersForRegistration(): number  {
        return this.countServersForRegistration;
        
    }
    public getTimeoutForConnectToRegistrationServer(): number  {
        return this.timeoutForConnectToRegistrationServer;
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getAlias(): UUID  {
        return this.alias;
        
    }
    public getMasterKey(): Key  {
        return this.masterKey;
        
    }
    public toString(result: AString): AString  {
        result.add('ClientStateForSave(');
        result.add('registrationUri:').add(this.registrationUri);
        result.add(', ');
        result.add('servers:').add(this.servers);
        result.add(', ');
        result.add('clients:').add(this.clients);
        result.add(', ');
        result.add('rootSigners:').add(this.rootSigners);
        result.add(', ');
        result.add('cryptoLib:').add(this.cryptoLib);
        result.add(', ');
        result.add('pingDuration:').add(this.pingDuration);
        result.add(', ');
        result.add('parentUid:').add(this.parentUid);
        result.add(', ');
        result.add('countServersForRegistration:').add(this.countServersForRegistration);
        result.add(', ');
        result.add('timeoutForConnectToRegistrationServer:').add(this.timeoutForConnectToRegistrationServer);
        result.add(', ');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('alias:').add(this.alias);
        result.add(', ');
        result.add('masterKey:').add(this.masterKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Cloud ---
export class Cloud implements ToString  {
    public readonly data: number[];
    public static readonly META_BODY: FastMetaType<Cloud> = new class implements FastMetaType<Cloud>  {
        serialize(sCtx_137: FastFutureContext, obj_138: Cloud, _out_139: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_139, obj_138.data.length);
            for (const el_141 of obj_138.data)  {
                _out_139.writeShort(el_141);
                
            }
            
        }
        deserialize(sCtx_137: FastFutureContext, in__140: DataIn): Cloud  {
            let data_143: number[];
            const len_145 = DeserializerPackNumber.INSTANCE.put(in__140).valueOf();
            data_143 = new Array<number>(len_145);
            for (let idx_144 = 0;
            idx_144 < len_145;
            idx_144++)  {
                data_143[idx_144] = in__140.readShort();
                
            }
            return new Cloud(data_143);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<Cloud> = Cloud.META_BODY;
    constructor(data: number[])  {
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type Cloud.`);
        
    }
    public getData(): number[]  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as number[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('Cloud(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: CoderAndPort ---
export class CoderAndPort implements ToString  {
    public readonly codec: AetherCodec;
    public readonly port: number;
    public static readonly META_BODY: FastMetaType<CoderAndPort> = new class implements FastMetaType<CoderAndPort>  {
        serialize(sCtx_147: FastFutureContext, obj_148: CoderAndPort, _out_149: DataOut): void  {
            AetherCodec.META.serialize(sCtx_147, obj_148.codec, _out_149);
            _out_149.writeShort(obj_148.port);
            
        }
        deserialize(sCtx_147: FastFutureContext, in__150: DataIn): CoderAndPort  {
            let codec_153: AetherCodec;
            let port_154: number;
            codec_153 = AetherCodec.META.deserialize(sCtx_147, in__150);
            port_154 = in__150.readShort();
            return new CoderAndPort(codec_153, port_154);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<CoderAndPort> = CoderAndPort.META_BODY;
    constructor(codec: AetherCodec, port: number)  {
        this.codec = codec;
        this.port = port;
        if (codec === null || codec === undefined) throw new Error(`Field 'codec' cannot be null for type CoderAndPort.`);
        
    }
    public getCodec(): AetherCodec  {
        return this.codec;
        
    }
    public getPort(): number  {
        return this.port;
        
    }
    public toString(result: AString): AString  {
        result.add('CoderAndPort(');
        result.add('codec:').add(this.codec);
        result.add(', ');
        result.add('port:').add(this.port);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: FinishResultGlobalRegServerApi ---
export class FinishResultGlobalRegServerApi implements ToString  {
    public readonly alias: UUID;
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<FinishResultGlobalRegServerApi> = new class implements FastMetaType<FinishResultGlobalRegServerApi>  {
        serialize(sCtx_157: FastFutureContext, obj_158: FinishResultGlobalRegServerApi, _out_159: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_157, obj_158.alias, _out_159);
            FastMeta.META_UUID.serialize(sCtx_157, obj_158.uid, _out_159);
            Cloud.META.serialize(sCtx_157, obj_158.cloud, _out_159);
            
        }
        deserialize(sCtx_157: FastFutureContext, in__160: DataIn): FinishResultGlobalRegServerApi  {
            let alias_164: UUID;
            let uid_165: UUID;
            let cloud_166: Cloud;
            alias_164 = FastMeta.META_UUID.deserialize(sCtx_157, in__160);
            uid_165 = FastMeta.META_UUID.deserialize(sCtx_157, in__160);
            cloud_166 = Cloud.META.deserialize(sCtx_157, in__160);
            return new FinishResultGlobalRegServerApi(alias_164, uid_165, cloud_166);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<FinishResultGlobalRegServerApi> = FinishResultGlobalRegServerApi.META_BODY;
    constructor(alias: UUID, uid: UUID, cloud: Cloud)  {
        this.alias = alias;
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type FinishResultGlobalRegServerApi.`);
        
    }
    public getAlias(): UUID  {
        return this.alias;
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('FinishResultGlobalRegServerApi(');
        result.add('alias:').add(this.alias);
        result.add(', ');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenCurvePrivate ---
export class HydrogenCurvePrivate extends KeyAsymmetricPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenCurvePrivate> = new class implements FastMetaType<HydrogenCurvePrivate>  {
        serialize(sCtx_170: FastFutureContext, obj_171: HydrogenCurvePrivate, _out_172: DataOut): void  {
            if (obj_171.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_171.data must be 32 but was $ {
                obj_171.data.length
            }
            `);
            _out_172.write(obj_171.data);
            
        }
        deserialize(sCtx_170: FastFutureContext, in__173: DataIn): HydrogenCurvePrivate  {
            let data_175: Uint8Array;
            const len_177 = 32;
            const bytes_178 = in__173.readBytes(len_177);
            data_175 = bytes_178;
            return new HydrogenCurvePrivate(data_175);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenCurvePrivate> = new class implements FastMetaType<HydrogenCurvePrivate>  {
        serialize(sCtx_179: FastFutureContext, obj_180: HydrogenCurvePrivate, _out_181: DataOut): void  {
            const typeId = typeof (obj_180 as any).getAetherTypeId === 'function' ? obj_180.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_181.writeByte(typeId);
            switch(typeId)  {
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_179, obj_180 as any as HydrogenCurvePrivate, _out_181);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_179, obj_180 as any as SodiumChacha20Poly1305, _out_181);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_179, obj_180 as any as HydrogenSecretBox, _out_181);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_179, obj_180 as any as HydrogenCurvePublic, _out_181);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_179, obj_180 as any as SodiumCurvePublic, _out_181);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_179, obj_180 as any as SodiumCurvePrivate, _out_181);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_179, obj_180 as any as SodiumSignPublic, _out_181);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_179, obj_180 as any as HydrogenSignPublic, _out_181);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_179, obj_180 as any as SodiumSignPrivate, _out_181);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_179, obj_180 as any as HydrogenSignPrivate, _out_181);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_179: FastFutureContext, in__182: DataIn): HydrogenCurvePrivate  {
            const typeId = in__182.readUByte();
            switch(typeId)  {
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_179, in__182) as any as HydrogenCurvePrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenCurvePrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenCurvePrivate.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenCurvePrivate must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenCurvePrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenCurvePublic ---
export class HydrogenCurvePublic extends KeyAsymmetricPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenCurvePublic> = new class implements FastMetaType<HydrogenCurvePublic>  {
        serialize(sCtx_183: FastFutureContext, obj_184: HydrogenCurvePublic, _out_185: DataOut): void  {
            if (obj_184.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_184.data must be 32 but was $ {
                obj_184.data.length
            }
            `);
            _out_185.write(obj_184.data);
            
        }
        deserialize(sCtx_183: FastFutureContext, in__186: DataIn): HydrogenCurvePublic  {
            let data_188: Uint8Array;
            const len_190 = 32;
            const bytes_191 = in__186.readBytes(len_190);
            data_188 = bytes_191;
            return new HydrogenCurvePublic(data_188);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenCurvePublic> = new class implements FastMetaType<HydrogenCurvePublic>  {
        serialize(sCtx_192: FastFutureContext, obj_193: HydrogenCurvePublic, _out_194: DataOut): void  {
            const typeId = typeof (obj_193 as any).getAetherTypeId === 'function' ? obj_193.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenCurvePublic' with invalid type id $ {
                typeId
            }
            `);
            _out_194.writeByte(typeId);
            switch(typeId)  {
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_192, obj_193 as any as HydrogenCurvePublic, _out_194);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_192, obj_193 as any as SodiumChacha20Poly1305, _out_194);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_192, obj_193 as any as HydrogenSecretBox, _out_194);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_192, obj_193 as any as SodiumCurvePublic, _out_194);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_192, obj_193 as any as HydrogenCurvePrivate, _out_194);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_192, obj_193 as any as SodiumCurvePrivate, _out_194);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_192, obj_193 as any as SodiumSignPublic, _out_194);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_192, obj_193 as any as HydrogenSignPublic, _out_194);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_192, obj_193 as any as SodiumSignPrivate, _out_194);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_192, obj_193 as any as HydrogenSignPrivate, _out_194);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenCurvePublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_192: FastFutureContext, in__195: DataIn): HydrogenCurvePublic  {
            const typeId = in__195.readUByte();
            switch(typeId)  {
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_192, in__195) as any as HydrogenCurvePublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenCurvePublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenCurvePublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenCurvePublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenCurvePublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSecretBox ---
export class HydrogenSecretBox extends KeySymmetric implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 3;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSecretBox> = new class implements FastMetaType<HydrogenSecretBox>  {
        serialize(sCtx_196: FastFutureContext, obj_197: HydrogenSecretBox, _out_198: DataOut): void  {
            if (obj_197.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_197.data must be 32 but was $ {
                obj_197.data.length
            }
            `);
            _out_198.write(obj_197.data);
            
        }
        deserialize(sCtx_196: FastFutureContext, in__199: DataIn): HydrogenSecretBox  {
            let data_201: Uint8Array;
            const len_203 = 32;
            const bytes_204 = in__199.readBytes(len_203);
            data_201 = bytes_204;
            return new HydrogenSecretBox(data_201);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSecretBox> = new class implements FastMetaType<HydrogenSecretBox>  {
        serialize(sCtx_205: FastFutureContext, obj_206: HydrogenSecretBox, _out_207: DataOut): void  {
            const typeId = typeof (obj_206 as any).getAetherTypeId === 'function' ? obj_206.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSecretBox' with invalid type id $ {
                typeId
            }
            `);
            _out_207.writeByte(typeId);
            switch(typeId)  {
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_205, obj_206 as any as HydrogenSecretBox, _out_207);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_205, obj_206 as any as SodiumChacha20Poly1305, _out_207);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_205, obj_206 as any as HydrogenCurvePublic, _out_207);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_205, obj_206 as any as SodiumCurvePublic, _out_207);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_205, obj_206 as any as HydrogenCurvePrivate, _out_207);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_205, obj_206 as any as SodiumCurvePrivate, _out_207);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_205, obj_206 as any as SodiumSignPublic, _out_207);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_205, obj_206 as any as HydrogenSignPublic, _out_207);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_205, obj_206 as any as SodiumSignPrivate, _out_207);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_205, obj_206 as any as HydrogenSignPrivate, _out_207);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSecretBox' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_205: FastFutureContext, in__208: DataIn): HydrogenSecretBox  {
            const typeId = in__208.readUByte();
            switch(typeId)  {
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_205, in__208) as any as HydrogenSecretBox;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSecretBox'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSecretBox.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenSecretBox must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSecretBox(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSignPrivate ---
export class HydrogenSignPrivate extends KeySignPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 4;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSignPrivate> = new class implements FastMetaType<HydrogenSignPrivate>  {
        serialize(sCtx_209: FastFutureContext, obj_210: HydrogenSignPrivate, _out_211: DataOut): void  {
            if (obj_210.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_210.data must be 64 but was $ {
                obj_210.data.length
            }
            `);
            _out_211.write(obj_210.data);
            
        }
        deserialize(sCtx_209: FastFutureContext, in__212: DataIn): HydrogenSignPrivate  {
            let data_214: Uint8Array;
            const len_216 = 64;
            const bytes_217 = in__212.readBytes(len_216);
            data_214 = bytes_217;
            return new HydrogenSignPrivate(data_214);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSignPrivate> = new class implements FastMetaType<HydrogenSignPrivate>  {
        serialize(sCtx_218: FastFutureContext, obj_219: HydrogenSignPrivate, _out_220: DataOut): void  {
            const typeId = typeof (obj_219 as any).getAetherTypeId === 'function' ? obj_219.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_220.writeByte(typeId);
            switch(typeId)  {
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_218, obj_219 as any as HydrogenSignPrivate, _out_220);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_218, obj_219 as any as SodiumChacha20Poly1305, _out_220);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_218, obj_219 as any as HydrogenSecretBox, _out_220);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_218, obj_219 as any as HydrogenCurvePublic, _out_220);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_218, obj_219 as any as SodiumCurvePublic, _out_220);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_218, obj_219 as any as HydrogenCurvePrivate, _out_220);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_218, obj_219 as any as SodiumCurvePrivate, _out_220);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_218, obj_219 as any as SodiumSignPublic, _out_220);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_218, obj_219 as any as HydrogenSignPublic, _out_220);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_218, obj_219 as any as SodiumSignPrivate, _out_220);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_218: FastFutureContext, in__221: DataIn): HydrogenSignPrivate  {
            const typeId = in__221.readUByte();
            switch(typeId)  {
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_218, in__221) as any as HydrogenSignPrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSignPrivate.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type HydrogenSignPrivate must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSignPrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSignPublic ---
export class HydrogenSignPublic extends KeySignPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 5;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSignPublic> = new class implements FastMetaType<HydrogenSignPublic>  {
        serialize(sCtx_222: FastFutureContext, obj_223: HydrogenSignPublic, _out_224: DataOut): void  {
            if (obj_223.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_223.data must be 32 but was $ {
                obj_223.data.length
            }
            `);
            _out_224.write(obj_223.data);
            
        }
        deserialize(sCtx_222: FastFutureContext, in__225: DataIn): HydrogenSignPublic  {
            let data_227: Uint8Array;
            const len_229 = 32;
            const bytes_230 = in__225.readBytes(len_229);
            data_227 = bytes_230;
            return new HydrogenSignPublic(data_227);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSignPublic> = new class implements FastMetaType<HydrogenSignPublic>  {
        serialize(sCtx_231: FastFutureContext, obj_232: HydrogenSignPublic, _out_233: DataOut): void  {
            const typeId = typeof (obj_232 as any).getAetherTypeId === 'function' ? obj_232.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_233.writeByte(typeId);
            switch(typeId)  {
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_231, obj_232 as any as HydrogenSignPublic, _out_233);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_231, obj_232 as any as SodiumChacha20Poly1305, _out_233);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_231, obj_232 as any as HydrogenSecretBox, _out_233);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_231, obj_232 as any as HydrogenCurvePublic, _out_233);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_231, obj_232 as any as SodiumCurvePublic, _out_233);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_231, obj_232 as any as HydrogenCurvePrivate, _out_233);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_231, obj_232 as any as SodiumCurvePrivate, _out_233);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_231, obj_232 as any as SodiumSignPublic, _out_233);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_231, obj_232 as any as SodiumSignPrivate, _out_233);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_231, obj_232 as any as HydrogenSignPrivate, _out_233);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_231: FastFutureContext, in__234: DataIn): HydrogenSignPublic  {
            const typeId = in__234.readUByte();
            switch(typeId)  {
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_231, in__234) as any as HydrogenSignPublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSignPublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenSignPublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSignPublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressAndPorts ---
export class IPAddressAndPorts implements ToString  {
    public readonly address: IPAddress;
    public readonly coderAndPorts: CoderAndPort[];
    public static readonly META_BODY: FastMetaType<IPAddressAndPorts> = new class implements FastMetaType<IPAddressAndPorts>  {
        serialize(sCtx_235: FastFutureContext, obj_236: IPAddressAndPorts, _out_237: DataOut): void  {
            IPAddress.META.serialize(sCtx_235, obj_236.address, _out_237);
            SerializerPackNumber.INSTANCE.put(_out_237, obj_236.coderAndPorts.length);
            for (const el_240 of obj_236.coderAndPorts)  {
                CoderAndPort.META.serialize(sCtx_235, el_240, _out_237);
                
            }
            
        }
        deserialize(sCtx_235: FastFutureContext, in__238: DataIn): IPAddressAndPorts  {
            let address_242: IPAddress;
            let coderAndPorts_243: CoderAndPort[];
            address_242 = IPAddress.META.deserialize(sCtx_235, in__238);
            const len_246 = DeserializerPackNumber.INSTANCE.put(in__238).valueOf();
            coderAndPorts_243 = new Array<CoderAndPort>(len_246);
            for (let idx_245 = 0;
            idx_245 < len_246;
            idx_245++)  {
                coderAndPorts_243[idx_245] = CoderAndPort.META.deserialize(sCtx_235, in__238);
                
            }
            return new IPAddressAndPorts(address_242, coderAndPorts_243);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressAndPorts> = IPAddressAndPorts.META_BODY;
    constructor(address: IPAddress, coderAndPorts: CoderAndPort[])  {
        this.address = address;
        this.coderAndPorts = coderAndPorts;
        if (address === null || address === undefined) throw new Error(`Field 'address' cannot be null for type IPAddressAndPorts.`);
        if (coderAndPorts === null || coderAndPorts === undefined) throw new Error(`Field 'coderAndPorts' cannot be null for type IPAddressAndPorts.`);
        
    }
    public getAddress(): IPAddress  {
        return this.address;
        
    }
    public getCoderAndPorts(): CoderAndPort[]  {
        return this.coderAndPorts;
        
    }
    public coderAndPortsContains(el: CoderAndPort): boolean  {
        return (this.coderAndPorts as CoderAndPort[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressAndPorts(');
        result.add('address:').add(this.address);
        result.add(', ');
        result.add('coderAndPorts:').add(this.coderAndPorts);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressAndPortsList ---
export class IPAddressAndPortsList implements ToString  {
    public readonly addresses: IPAddressAndPorts[];
    public static readonly META_BODY: FastMetaType<IPAddressAndPortsList> = new class implements FastMetaType<IPAddressAndPortsList>  {
        serialize(sCtx_248: FastFutureContext, obj_249: IPAddressAndPortsList, _out_250: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_250, obj_249.addresses.length);
            for (const el_252 of obj_249.addresses)  {
                IPAddressAndPorts.META.serialize(sCtx_248, el_252, _out_250);
                
            }
            
        }
        deserialize(sCtx_248: FastFutureContext, in__251: DataIn): IPAddressAndPortsList  {
            let addresses_254: IPAddressAndPorts[];
            const len_256 = DeserializerPackNumber.INSTANCE.put(in__251).valueOf();
            addresses_254 = new Array<IPAddressAndPorts>(len_256);
            for (let idx_255 = 0;
            idx_255 < len_256;
            idx_255++)  {
                addresses_254[idx_255] = IPAddressAndPorts.META.deserialize(sCtx_248, in__251);
                
            }
            return new IPAddressAndPortsList(addresses_254);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressAndPortsList> = IPAddressAndPortsList.META_BODY;
    constructor(addresses: IPAddressAndPorts[])  {
        this.addresses = addresses;
        if (addresses === null || addresses === undefined) throw new Error(`Field 'addresses' cannot be null for type IPAddressAndPortsList.`);
        
    }
    public getAddresses(): IPAddressAndPorts[]  {
        return this.addresses;
        
    }
    public addressesContains(el: IPAddressAndPorts): boolean  {
        return (this.addresses as IPAddressAndPorts[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressAndPortsList(');
        result.add('addresses:').add(this.addresses);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressV4 ---
export class IPAddressV4 extends IPAddress implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<IPAddressV4> = new class implements FastMetaType<IPAddressV4>  {
        serialize(sCtx_258: FastFutureContext, obj_259: IPAddressV4, _out_260: DataOut): void  {
            if (obj_259.data.length !== 4) throw new Error(`IllegalStateException: Array length for obj_259.data must be 4 but was $ {
                obj_259.data.length
            }
            `);
            _out_260.write(obj_259.data);
            
        }
        deserialize(sCtx_258: FastFutureContext, in__261: DataIn): IPAddressV4  {
            let data_263: Uint8Array;
            const len_265 = 4;
            const bytes_266 = in__261.readBytes(len_265);
            data_263 = bytes_266;
            return new IPAddressV4(data_263);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressV4> = new class implements FastMetaType<IPAddressV4>  {
        serialize(sCtx_267: FastFutureContext, obj_268: IPAddressV4, _out_269: DataOut): void  {
            const typeId = typeof (obj_268 as any).getAetherTypeId === 'function' ? obj_268.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddressV4' with invalid type id $ {
                typeId
            }
            `);
            _out_269.writeByte(typeId);
            switch(typeId)  {
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_267, obj_268 as any as IPAddressV4, _out_269);
                break;
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_267, obj_268 as any as IPAddressV6, _out_269);
                break;
                default: throw new Error(`Cannot serialize 'IPAddressV4' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_267: FastFutureContext, in__270: DataIn): IPAddressV4  {
            const typeId = in__270.readUByte();
            switch(typeId)  {
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_267, in__270) as any as IPAddressV4;
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_267, in__270) as any as IPAddressV4;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddressV4'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type IPAddressV4.`);
        if (data.length !== 4) throw new Error(`Array length for field 'data' in type IPAddressV4 must be 4 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressV4(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressV6 ---
export class IPAddressV6 extends IPAddress implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<IPAddressV6> = new class implements FastMetaType<IPAddressV6>  {
        serialize(sCtx_271: FastFutureContext, obj_272: IPAddressV6, _out_273: DataOut): void  {
            if (obj_272.data.length !== 6) throw new Error(`IllegalStateException: Array length for obj_272.data must be 6 but was $ {
                obj_272.data.length
            }
            `);
            _out_273.write(obj_272.data);
            
        }
        deserialize(sCtx_271: FastFutureContext, in__274: DataIn): IPAddressV6  {
            let data_276: Uint8Array;
            const len_278 = 6;
            const bytes_279 = in__274.readBytes(len_278);
            data_276 = bytes_279;
            return new IPAddressV6(data_276);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressV6> = new class implements FastMetaType<IPAddressV6>  {
        serialize(sCtx_280: FastFutureContext, obj_281: IPAddressV6, _out_282: DataOut): void  {
            const typeId = typeof (obj_281 as any).getAetherTypeId === 'function' ? obj_281.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddressV6' with invalid type id $ {
                typeId
            }
            `);
            _out_282.writeByte(typeId);
            switch(typeId)  {
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_280, obj_281 as any as IPAddressV6, _out_282);
                break;
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_280, obj_281 as any as IPAddressV4, _out_282);
                break;
                default: throw new Error(`Cannot serialize 'IPAddressV6' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_280: FastFutureContext, in__283: DataIn): IPAddressV6  {
            const typeId = in__283.readUByte();
            switch(typeId)  {
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_280, in__283) as any as IPAddressV6;
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_280, in__283) as any as IPAddressV6;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddressV6'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type IPAddressV6.`);
        if (data.length !== 6) throw new Error(`Array length for field 'data' in type IPAddressV6 must be 6 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressV6(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Message ---
export class Message implements ToString  {
    public readonly uid: UUID;
    public readonly data: Uint8Array;
    public static readonly META_BODY: FastMetaType<Message> = new class implements FastMetaType<Message>  {
        serialize(sCtx_284: FastFutureContext, obj_285: Message, _out_286: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_284, obj_285.uid, _out_286);
            SerializerPackNumber.INSTANCE.put(_out_286, obj_285.data.length);
            _out_286.write(obj_285.data);
            
        }
        deserialize(sCtx_284: FastFutureContext, in__287: DataIn): Message  {
            let uid_290: UUID;
            let data_291: Uint8Array;
            uid_290 = FastMeta.META_UUID.deserialize(sCtx_284, in__287);
            const len_294 = DeserializerPackNumber.INSTANCE.put(in__287).valueOf();
            const bytes_295 = in__287.readBytes(len_294);
            data_291 = bytes_295;
            return new Message(uid_290, data_291);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<Message> = Message.META_BODY;
    constructor(uid: UUID, data: Uint8Array)  {
        this.uid = uid;
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type Message.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('Message(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: MoneyOperation ---
export class MoneyOperation implements ToString  {
    public readonly id: number;
    public readonly from: UUID;
    public readonly to: UUID;
    public readonly amount: number;
    public readonly time: number;
    public readonly credit: boolean;
    public readonly status: Status;
    public static readonly META_BODY: FastMetaType<MoneyOperation> = new class implements FastMetaType<MoneyOperation>  {
        serialize(sCtx_296: FastFutureContext, obj_297: MoneyOperation, _out_298: DataOut): void  {
            _out_298.writeLong(obj_297.id);
            FastMeta.META_UUID.serialize(sCtx_296, obj_297.from, _out_298);
            FastMeta.META_UUID.serialize(sCtx_296, obj_297.to, _out_298);
            _out_298.writeLong(obj_297.amount);
            _out_298.writeLong(obj_297.time);
            _out_298.writeBoolean(obj_297.credit);
            Status.META.serialize(sCtx_296, obj_297.status, _out_298);
            
        }
        deserialize(sCtx_296: FastFutureContext, in__299: DataIn): MoneyOperation  {
            let id_307: number;
            let from_308: UUID;
            let to_309: UUID;
            let amount_310: number;
            let time_311: number;
            let credit_312: boolean;
            let status_313: Status;
            id_307 = in__299.readLong();
            from_308 = FastMeta.META_UUID.deserialize(sCtx_296, in__299);
            to_309 = FastMeta.META_UUID.deserialize(sCtx_296, in__299);
            amount_310 = in__299.readLong();
            time_311 = in__299.readLong();
            credit_312 = in__299.readBoolean();
            status_313 = Status.META.deserialize(sCtx_296, in__299);
            return new MoneyOperation(id_307, from_308, to_309, amount_310, time_311, credit_312, status_313);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<MoneyOperation> = MoneyOperation.META_BODY;
    constructor(id: number, from: UUID, to: UUID, amount: number, time: number, credit: boolean, status: Status)  {
        this.id = id;
        this.from = from;
        this.to = to;
        this.amount = amount;
        this.time = time;
        this.credit = credit;
        this.status = status;
        if (status === null || status === undefined) throw new Error(`Field 'status' cannot be null for type MoneyOperation.`);
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getFrom(): UUID  {
        return this.from;
        
    }
    public getTo(): UUID  {
        return this.to;
        
    }
    public getAmount(): number  {
        return this.amount;
        
    }
    public getTime(): number  {
        return this.time;
        
    }
    public isCredit(): boolean  {
        return this.credit;
        
    }
    public getStatus(): Status  {
        return this.status;
        
    }
    public toString(result: AString): AString  {
        result.add('MoneyOperation(');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('from:').add(this.from);
        result.add(', ');
        result.add('to:').add(this.to);
        result.add(', ');
        result.add('amount:').add(this.amount);
        result.add(', ');
        result.add('time:').add(this.time);
        result.add(', ');
        result.add('credit:').add(this.credit);
        result.add(', ');
        result.add('status:').add(this.status);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysAsym ---
export class PairKeysAsym extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: Key;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysAsym> = new class implements FastMetaType<PairKeysAsym>  {
        serialize(sCtx_321: FastFutureContext, obj_322: PairKeysAsym, _out_323: DataOut): void  {
            Key.META.serialize(sCtx_321, obj_322.privateKey, _out_323);
            Key.META.serialize(sCtx_321, obj_322.publicKey, _out_323);
            
        }
        deserialize(sCtx_321: FastFutureContext, in__324: DataIn): PairKeysAsym  {
            let privateKey_327: Key;
            let publicKey_328: Key;
            privateKey_327 = Key.META.deserialize(sCtx_321, in__324);
            publicKey_328 = Key.META.deserialize(sCtx_321, in__324);
            return new PairKeysAsym(privateKey_327, publicKey_328);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysAsym> = new class implements FastMetaType<PairKeysAsym>  {
        serialize(sCtx_331: FastFutureContext, obj_332: PairKeysAsym, _out_333: DataOut): void  {
            const typeId = typeof (obj_332 as any).getAetherTypeId === 'function' ? obj_332.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysAsym' with invalid type id $ {
                typeId
            }
            `);
            _out_333.writeByte(typeId);
            switch(typeId)  {
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_331, obj_332 as any as PairKeysAsym, _out_333);
                break;
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_331, obj_332 as any as PairKeysSign, _out_333);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_331, obj_332 as any as PairKeysAsymSigned, _out_333);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysAsym' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_331: FastFutureContext, in__334: DataIn): PairKeysAsym  {
            const typeId = in__334.readUByte();
            switch(typeId)  {
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_331, in__334) as any as PairKeysAsym;
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_331, in__334) as any as PairKeysAsym;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_331, in__334) as any as PairKeysAsym;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysAsym'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: Key)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsym.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsym.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): Key  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysAsym(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysAsymSigned ---
export class PairKeysAsymSigned extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: SignedKey;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysAsymSigned> = new class implements FastMetaType<PairKeysAsymSigned>  {
        serialize(sCtx_335: FastFutureContext, obj_336: PairKeysAsymSigned, _out_337: DataOut): void  {
            Key.META.serialize(sCtx_335, obj_336.privateKey, _out_337);
            SignedKey.META.serialize(sCtx_335, obj_336.publicKey, _out_337);
            
        }
        deserialize(sCtx_335: FastFutureContext, in__338: DataIn): PairKeysAsymSigned  {
            let privateKey_341: Key;
            let publicKey_342: SignedKey;
            privateKey_341 = Key.META.deserialize(sCtx_335, in__338);
            publicKey_342 = SignedKey.META.deserialize(sCtx_335, in__338);
            return new PairKeysAsymSigned(privateKey_341, publicKey_342);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysAsymSigned> = new class implements FastMetaType<PairKeysAsymSigned>  {
        serialize(sCtx_345: FastFutureContext, obj_346: PairKeysAsymSigned, _out_347: DataOut): void  {
            const typeId = typeof (obj_346 as any).getAetherTypeId === 'function' ? obj_346.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysAsymSigned' with invalid type id $ {
                typeId
            }
            `);
            _out_347.writeByte(typeId);
            switch(typeId)  {
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_345, obj_346 as any as PairKeysAsymSigned, _out_347);
                break;
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_345, obj_346 as any as PairKeysSign, _out_347);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_345, obj_346 as any as PairKeysAsym, _out_347);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysAsymSigned' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_345: FastFutureContext, in__348: DataIn): PairKeysAsymSigned  {
            const typeId = in__348.readUByte();
            switch(typeId)  {
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_345, in__348) as any as PairKeysAsymSigned;
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_345, in__348) as any as PairKeysAsymSigned;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_345, in__348) as any as PairKeysAsymSigned;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysAsymSigned'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: SignedKey)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsymSigned.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsymSigned.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): SignedKey  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysAsymSigned(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysSign ---
export class PairKeysSign extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: Key;
    public override getAetherTypeId(): number  {
        return 3;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysSign> = new class implements FastMetaType<PairKeysSign>  {
        serialize(sCtx_349: FastFutureContext, obj_350: PairKeysSign, _out_351: DataOut): void  {
            Key.META.serialize(sCtx_349, obj_350.privateKey, _out_351);
            Key.META.serialize(sCtx_349, obj_350.publicKey, _out_351);
            
        }
        deserialize(sCtx_349: FastFutureContext, in__352: DataIn): PairKeysSign  {
            let privateKey_355: Key;
            let publicKey_356: Key;
            privateKey_355 = Key.META.deserialize(sCtx_349, in__352);
            publicKey_356 = Key.META.deserialize(sCtx_349, in__352);
            return new PairKeysSign(privateKey_355, publicKey_356);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysSign> = new class implements FastMetaType<PairKeysSign>  {
        serialize(sCtx_359: FastFutureContext, obj_360: PairKeysSign, _out_361: DataOut): void  {
            const typeId = typeof (obj_360 as any).getAetherTypeId === 'function' ? obj_360.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysSign' with invalid type id $ {
                typeId
            }
            `);
            _out_361.writeByte(typeId);
            switch(typeId)  {
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_359, obj_360 as any as PairKeysSign, _out_361);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_359, obj_360 as any as PairKeysAsym, _out_361);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_359, obj_360 as any as PairKeysAsymSigned, _out_361);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysSign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_359: FastFutureContext, in__362: DataIn): PairKeysSign  {
            const typeId = in__362.readUByte();
            switch(typeId)  {
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_359, in__362) as any as PairKeysSign;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_359, in__362) as any as PairKeysSign;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_359, in__362) as any as PairKeysSign;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysSign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: Key)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysSign.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysSign.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): Key  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysSign(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ServerDescriptor ---
export class ServerDescriptor implements ToString  {
    public readonly id: number;
    public readonly ipAddress: IPAddressAndPortsList;
    public static readonly META_BODY: FastMetaType<ServerDescriptor> = new class implements FastMetaType<ServerDescriptor>  {
        serialize(sCtx_363: FastFutureContext, obj_364: ServerDescriptor, _out_365: DataOut): void  {
            _out_365.writeShort(obj_364.id);
            IPAddressAndPortsList.META.serialize(sCtx_363, obj_364.ipAddress, _out_365);
            
        }
        deserialize(sCtx_363: FastFutureContext, in__366: DataIn): ServerDescriptor  {
            let id_369: number;
            let ipAddress_370: IPAddressAndPortsList;
            id_369 = in__366.readShort();
            ipAddress_370 = IPAddressAndPortsList.META.deserialize(sCtx_363, in__366);
            return new ServerDescriptor(id_369, ipAddress_370);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ServerDescriptor> = ServerDescriptor.META_BODY;
    constructor(id: number, ipAddress: IPAddressAndPortsList)  {
        this.id = id;
        this.ipAddress = ipAddress;
        if (ipAddress === null || ipAddress === undefined) throw new Error(`Field 'ipAddress' cannot be null for type ServerDescriptor.`);
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getIpAddress(): IPAddressAndPortsList  {
        return this.ipAddress;
        
    }
    public toString(result: AString): AString  {
        result.add('ServerDescriptor(');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('ipAddress:').add(this.ipAddress);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignAE_ED25519 ---
export class SignAE_ED25519 extends Sign implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<SignAE_ED25519> = new class implements FastMetaType<SignAE_ED25519>  {
        serialize(sCtx_373: FastFutureContext, obj_374: SignAE_ED25519, _out_375: DataOut): void  {
            if (obj_374.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_374.data must be 64 but was $ {
                obj_374.data.length
            }
            `);
            _out_375.write(obj_374.data);
            
        }
        deserialize(sCtx_373: FastFutureContext, in__376: DataIn): SignAE_ED25519  {
            let data_378: Uint8Array;
            const len_380 = 64;
            const bytes_381 = in__376.readBytes(len_380);
            data_378 = bytes_381;
            return new SignAE_ED25519(data_378);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignAE_ED25519> = new class implements FastMetaType<SignAE_ED25519>  {
        serialize(sCtx_382: FastFutureContext, obj_383: SignAE_ED25519, _out_384: DataOut): void  {
            const typeId = typeof (obj_383 as any).getAetherTypeId === 'function' ? obj_383.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SignAE_ED25519' with invalid type id $ {
                typeId
            }
            `);
            _out_384.writeByte(typeId);
            switch(typeId)  {
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_382, obj_383 as any as SignAE_ED25519, _out_384);
                break;
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_382, obj_383 as any as SignHYDROGEN, _out_384);
                break;
                default: throw new Error(`Cannot serialize 'SignAE_ED25519' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_382: FastFutureContext, in__385: DataIn): SignAE_ED25519  {
            const typeId = in__385.readUByte();
            switch(typeId)  {
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_382, in__385) as any as SignAE_ED25519;
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_382, in__385) as any as SignAE_ED25519;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SignAE_ED25519'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SignAE_ED25519.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SignAE_ED25519 must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SignAE_ED25519(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignedKey ---
export class SignedKey implements ToString  {
    public readonly key: Key;
    public readonly sign: Sign;
    public static readonly META_BODY: FastMetaType<SignedKey> = new class implements FastMetaType<SignedKey>  {
        serialize(sCtx_386: FastFutureContext, obj_387: SignedKey, _out_388: DataOut): void  {
            Key.META.serialize(sCtx_386, obj_387.key, _out_388);
            Sign.META.serialize(sCtx_386, obj_387.sign, _out_388);
            
        }
        deserialize(sCtx_386: FastFutureContext, in__389: DataIn): SignedKey  {
            let _key_392: Key;
            let sign_393: Sign;
            _key_392 = Key.META.deserialize(sCtx_386, in__389);
            sign_393 = Sign.META.deserialize(sCtx_386, in__389);
            return new SignedKey(_key_392, sign_393);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignedKey> = SignedKey.META_BODY;
    constructor(key: Key, sign: Sign)  {
        this.key = key;
        this.sign = sign;
        if (key === null || key === undefined) throw new Error(`Field 'key' cannot be null for type SignedKey.`);
        if (sign === null || sign === undefined) throw new Error(`Field 'sign' cannot be null for type SignedKey.`);
        
    }
    public getKey(): Key  {
        return this.key;
        
    }
    public getSign(): Sign  {
        return this.sign;
        
    }
    public toString(result: AString): AString  {
        result.add('SignedKey(');
        result.add('key:').add(this.key);
        result.add(', ');
        result.add('sign:').add(this.sign);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignHYDROGEN ---
export class SignHYDROGEN extends Sign implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<SignHYDROGEN> = new class implements FastMetaType<SignHYDROGEN>  {
        serialize(sCtx_396: FastFutureContext, obj_397: SignHYDROGEN, _out_398: DataOut): void  {
            if (obj_397.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_397.data must be 64 but was $ {
                obj_397.data.length
            }
            `);
            _out_398.write(obj_397.data);
            
        }
        deserialize(sCtx_396: FastFutureContext, in__399: DataIn): SignHYDROGEN  {
            let data_401: Uint8Array;
            const len_403 = 64;
            const bytes_404 = in__399.readBytes(len_403);
            data_401 = bytes_404;
            return new SignHYDROGEN(data_401);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignHYDROGEN> = new class implements FastMetaType<SignHYDROGEN>  {
        serialize(sCtx_405: FastFutureContext, obj_406: SignHYDROGEN, _out_407: DataOut): void  {
            const typeId = typeof (obj_406 as any).getAetherTypeId === 'function' ? obj_406.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SignHYDROGEN' with invalid type id $ {
                typeId
            }
            `);
            _out_407.writeByte(typeId);
            switch(typeId)  {
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_405, obj_406 as any as SignHYDROGEN, _out_407);
                break;
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_405, obj_406 as any as SignAE_ED25519, _out_407);
                break;
                default: throw new Error(`Cannot serialize 'SignHYDROGEN' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_405: FastFutureContext, in__408: DataIn): SignHYDROGEN  {
            const typeId = in__408.readUByte();
            switch(typeId)  {
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_405, in__408) as any as SignHYDROGEN;
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_405, in__408) as any as SignHYDROGEN;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SignHYDROGEN'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SignHYDROGEN.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SignHYDROGEN must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SignHYDROGEN(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumChacha20Poly1305 ---
export class SodiumChacha20Poly1305 extends KeySymmetric implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 6;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumChacha20Poly1305> = new class implements FastMetaType<SodiumChacha20Poly1305>  {
        serialize(sCtx_409: FastFutureContext, obj_410: SodiumChacha20Poly1305, _out_411: DataOut): void  {
            if (obj_410.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_410.data must be 32 but was $ {
                obj_410.data.length
            }
            `);
            _out_411.write(obj_410.data);
            
        }
        deserialize(sCtx_409: FastFutureContext, in__412: DataIn): SodiumChacha20Poly1305  {
            let data_414: Uint8Array;
            const len_416 = 32;
            const bytes_417 = in__412.readBytes(len_416);
            data_414 = bytes_417;
            return new SodiumChacha20Poly1305(data_414);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumChacha20Poly1305> = new class implements FastMetaType<SodiumChacha20Poly1305>  {
        serialize(sCtx_418: FastFutureContext, obj_419: SodiumChacha20Poly1305, _out_420: DataOut): void  {
            const typeId = typeof (obj_419 as any).getAetherTypeId === 'function' ? obj_419.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with invalid type id $ {
                typeId
            }
            `);
            _out_420.writeByte(typeId);
            switch(typeId)  {
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_418, obj_419 as any as SodiumChacha20Poly1305, _out_420);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_418, obj_419 as any as HydrogenSecretBox, _out_420);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_418, obj_419 as any as HydrogenCurvePublic, _out_420);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_418, obj_419 as any as SodiumCurvePublic, _out_420);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_418, obj_419 as any as HydrogenCurvePrivate, _out_420);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_418, obj_419 as any as SodiumCurvePrivate, _out_420);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_418, obj_419 as any as SodiumSignPublic, _out_420);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_418, obj_419 as any as HydrogenSignPublic, _out_420);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_418, obj_419 as any as SodiumSignPrivate, _out_420);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_418, obj_419 as any as HydrogenSignPrivate, _out_420);
                break;
                default: throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_418: FastFutureContext, in__421: DataIn): SodiumChacha20Poly1305  {
            const typeId = in__421.readUByte();
            switch(typeId)  {
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_418, in__421) as any as SodiumChacha20Poly1305;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumChacha20Poly1305'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumChacha20Poly1305.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumChacha20Poly1305 must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumChacha20Poly1305(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumCurvePrivate ---
export class SodiumCurvePrivate extends KeyAsymmetricPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 7;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumCurvePrivate> = new class implements FastMetaType<SodiumCurvePrivate>  {
        serialize(sCtx_422: FastFutureContext, obj_423: SodiumCurvePrivate, _out_424: DataOut): void  {
            if (obj_423.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_423.data must be 32 but was $ {
                obj_423.data.length
            }
            `);
            _out_424.write(obj_423.data);
            
        }
        deserialize(sCtx_422: FastFutureContext, in__425: DataIn): SodiumCurvePrivate  {
            let data_427: Uint8Array;
            const len_429 = 32;
            const bytes_430 = in__425.readBytes(len_429);
            data_427 = bytes_430;
            return new SodiumCurvePrivate(data_427);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumCurvePrivate> = new class implements FastMetaType<SodiumCurvePrivate>  {
        serialize(sCtx_431: FastFutureContext, obj_432: SodiumCurvePrivate, _out_433: DataOut): void  {
            const typeId = typeof (obj_432 as any).getAetherTypeId === 'function' ? obj_432.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumCurvePrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_433.writeByte(typeId);
            switch(typeId)  {
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_431, obj_432 as any as SodiumCurvePrivate, _out_433);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_431, obj_432 as any as SodiumChacha20Poly1305, _out_433);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_431, obj_432 as any as HydrogenSecretBox, _out_433);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_431, obj_432 as any as HydrogenCurvePublic, _out_433);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_431, obj_432 as any as SodiumCurvePublic, _out_433);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_431, obj_432 as any as HydrogenCurvePrivate, _out_433);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_431, obj_432 as any as SodiumSignPublic, _out_433);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_431, obj_432 as any as HydrogenSignPublic, _out_433);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_431, obj_432 as any as SodiumSignPrivate, _out_433);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_431, obj_432 as any as HydrogenSignPrivate, _out_433);
                break;
                default: throw new Error(`Cannot serialize 'SodiumCurvePrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_431: FastFutureContext, in__434: DataIn): SodiumCurvePrivate  {
            const typeId = in__434.readUByte();
            switch(typeId)  {
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_431, in__434) as any as SodiumCurvePrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumCurvePrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumCurvePrivate.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumCurvePrivate must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumCurvePrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumCurvePublic ---
export class SodiumCurvePublic extends KeyAsymmetricPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 8;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumCurvePublic> = new class implements FastMetaType<SodiumCurvePublic>  {
        serialize(sCtx_435: FastFutureContext, obj_436: SodiumCurvePublic, _out_437: DataOut): void  {
            if (obj_436.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_436.data must be 32 but was $ {
                obj_436.data.length
            }
            `);
            _out_437.write(obj_436.data);
            
        }
        deserialize(sCtx_435: FastFutureContext, in__438: DataIn): SodiumCurvePublic  {
            let data_440: Uint8Array;
            const len_442 = 32;
            const bytes_443 = in__438.readBytes(len_442);
            data_440 = bytes_443;
            return new SodiumCurvePublic(data_440);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumCurvePublic> = new class implements FastMetaType<SodiumCurvePublic>  {
        serialize(sCtx_444: FastFutureContext, obj_445: SodiumCurvePublic, _out_446: DataOut): void  {
            const typeId = typeof (obj_445 as any).getAetherTypeId === 'function' ? obj_445.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumCurvePublic' with invalid type id $ {
                typeId
            }
            `);
            _out_446.writeByte(typeId);
            switch(typeId)  {
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_444, obj_445 as any as SodiumCurvePublic, _out_446);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_444, obj_445 as any as SodiumChacha20Poly1305, _out_446);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_444, obj_445 as any as HydrogenSecretBox, _out_446);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_444, obj_445 as any as HydrogenCurvePublic, _out_446);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_444, obj_445 as any as HydrogenCurvePrivate, _out_446);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_444, obj_445 as any as SodiumCurvePrivate, _out_446);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_444, obj_445 as any as SodiumSignPublic, _out_446);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_444, obj_445 as any as HydrogenSignPublic, _out_446);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_444, obj_445 as any as SodiumSignPrivate, _out_446);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_444, obj_445 as any as HydrogenSignPrivate, _out_446);
                break;
                default: throw new Error(`Cannot serialize 'SodiumCurvePublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_444: FastFutureContext, in__447: DataIn): SodiumCurvePublic  {
            const typeId = in__447.readUByte();
            switch(typeId)  {
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_444, in__447) as any as SodiumCurvePublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumCurvePublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumCurvePublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumCurvePublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumCurvePublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumSignPrivate ---
export class SodiumSignPrivate extends KeySignPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 9;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumSignPrivate> = new class implements FastMetaType<SodiumSignPrivate>  {
        serialize(sCtx_448: FastFutureContext, obj_449: SodiumSignPrivate, _out_450: DataOut): void  {
            if (obj_449.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_449.data must be 64 but was $ {
                obj_449.data.length
            }
            `);
            _out_450.write(obj_449.data);
            
        }
        deserialize(sCtx_448: FastFutureContext, in__451: DataIn): SodiumSignPrivate  {
            let data_453: Uint8Array;
            const len_455 = 64;
            const bytes_456 = in__451.readBytes(len_455);
            data_453 = bytes_456;
            return new SodiumSignPrivate(data_453);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumSignPrivate> = new class implements FastMetaType<SodiumSignPrivate>  {
        serialize(sCtx_457: FastFutureContext, obj_458: SodiumSignPrivate, _out_459: DataOut): void  {
            const typeId = typeof (obj_458 as any).getAetherTypeId === 'function' ? obj_458.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumSignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_459.writeByte(typeId);
            switch(typeId)  {
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_457, obj_458 as any as SodiumSignPrivate, _out_459);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_457, obj_458 as any as SodiumChacha20Poly1305, _out_459);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_457, obj_458 as any as HydrogenSecretBox, _out_459);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_457, obj_458 as any as HydrogenCurvePublic, _out_459);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_457, obj_458 as any as SodiumCurvePublic, _out_459);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_457, obj_458 as any as HydrogenCurvePrivate, _out_459);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_457, obj_458 as any as SodiumCurvePrivate, _out_459);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_457, obj_458 as any as SodiumSignPublic, _out_459);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_457, obj_458 as any as HydrogenSignPublic, _out_459);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_457, obj_458 as any as HydrogenSignPrivate, _out_459);
                break;
                default: throw new Error(`Cannot serialize 'SodiumSignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_457: FastFutureContext, in__460: DataIn): SodiumSignPrivate  {
            const typeId = in__460.readUByte();
            switch(typeId)  {
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_457, in__460) as any as SodiumSignPrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumSignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumSignPrivate.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SodiumSignPrivate must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumSignPrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumSignPublic ---
export class SodiumSignPublic extends KeySignPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 10;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumSignPublic> = new class implements FastMetaType<SodiumSignPublic>  {
        serialize(sCtx_461: FastFutureContext, obj_462: SodiumSignPublic, _out_463: DataOut): void  {
            if (obj_462.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_462.data must be 32 but was $ {
                obj_462.data.length
            }
            `);
            _out_463.write(obj_462.data);
            
        }
        deserialize(sCtx_461: FastFutureContext, in__464: DataIn): SodiumSignPublic  {
            let data_466: Uint8Array;
            const len_468 = 32;
            const bytes_469 = in__464.readBytes(len_468);
            data_466 = bytes_469;
            return new SodiumSignPublic(data_466);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumSignPublic> = new class implements FastMetaType<SodiumSignPublic>  {
        serialize(sCtx_470: FastFutureContext, obj_471: SodiumSignPublic, _out_472: DataOut): void  {
            const typeId = typeof (obj_471 as any).getAetherTypeId === 'function' ? obj_471.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumSignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_472.writeByte(typeId);
            switch(typeId)  {
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_470, obj_471 as any as SodiumSignPublic, _out_472);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_470, obj_471 as any as SodiumChacha20Poly1305, _out_472);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_470, obj_471 as any as HydrogenSecretBox, _out_472);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_470, obj_471 as any as HydrogenCurvePublic, _out_472);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_470, obj_471 as any as SodiumCurvePublic, _out_472);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_470, obj_471 as any as HydrogenCurvePrivate, _out_472);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_470, obj_471 as any as SodiumCurvePrivate, _out_472);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_470, obj_471 as any as HydrogenSignPublic, _out_472);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_470, obj_471 as any as SodiumSignPrivate, _out_472);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_470, obj_471 as any as HydrogenSignPrivate, _out_472);
                break;
                default: throw new Error(`Cannot serialize 'SodiumSignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_470: FastFutureContext, in__473: DataIn): SodiumSignPublic  {
            const typeId = in__473.readUByte();
            switch(typeId)  {
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_470, in__473) as any as SodiumSignPublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumSignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumSignPublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumSignPublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumSignPublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: TelemetryCPP ---
export class TelemetryCPP extends Telemetry implements ToString  {
    public readonly utm_id: number;
    public readonly blob: Uint8Array;
    public readonly lib_version: string;
    public readonly os: string;
    public readonly compiler: string;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<TelemetryCPP> = new class implements FastMetaType<TelemetryCPP>  {
        serialize(sCtx_474: FastFutureContext, obj_475: TelemetryCPP, _out_476: DataOut): void  {
            _out_476.writeInt(obj_475.utm_id);
            SerializerPackNumber.INSTANCE.put(_out_476, obj_475.blob.length);
            _out_476.write(obj_475.blob);
            const stringBytes_481 = new TextEncoder().encode(obj_475.lib_version);
            SerializerPackNumber.INSTANCE.put(_out_476, stringBytes_481.length);
            _out_476.write(stringBytes_481);
            const stringBytes_484 = new TextEncoder().encode(obj_475.os);
            SerializerPackNumber.INSTANCE.put(_out_476, stringBytes_484.length);
            _out_476.write(stringBytes_484);
            const stringBytes_487 = new TextEncoder().encode(obj_475.compiler);
            SerializerPackNumber.INSTANCE.put(_out_476, stringBytes_487.length);
            _out_476.write(stringBytes_487);
            
        }
        deserialize(sCtx_474: FastFutureContext, in__477: DataIn): TelemetryCPP  {
            let utm_id_489: number;
            let blob_490: Uint8Array;
            let lib_version_491: string;
            let os_492: string;
            let compiler_493: string;
            utm_id_489 = in__477.readInt();
            const len_496 = DeserializerPackNumber.INSTANCE.put(in__477).valueOf();
            const bytes_497 = in__477.readBytes(len_496);
            blob_490 = bytes_497;
            let stringBytes_499: Uint8Array;
            const len_501 = DeserializerPackNumber.INSTANCE.put(in__477).valueOf();
            const bytes_502 = in__477.readBytes(len_501);
            stringBytes_499 = bytes_502;
            lib_version_491 = new TextDecoder('utf-8').decode(stringBytes_499);
            let stringBytes_504: Uint8Array;
            const len_506 = DeserializerPackNumber.INSTANCE.put(in__477).valueOf();
            const bytes_507 = in__477.readBytes(len_506);
            stringBytes_504 = bytes_507;
            os_492 = new TextDecoder('utf-8').decode(stringBytes_504);
            let stringBytes_509: Uint8Array;
            const len_511 = DeserializerPackNumber.INSTANCE.put(in__477).valueOf();
            const bytes_512 = in__477.readBytes(len_511);
            stringBytes_509 = bytes_512;
            compiler_493 = new TextDecoder('utf-8').decode(stringBytes_509);
            return new TelemetryCPP(utm_id_489, blob_490, lib_version_491, os_492, compiler_493);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<TelemetryCPP> = new class implements FastMetaType<TelemetryCPP>  {
        serialize(sCtx_513: FastFutureContext, obj_514: TelemetryCPP, _out_515: DataOut): void  {
            const typeId = typeof (obj_514 as any).getAetherTypeId === 'function' ? obj_514.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'TelemetryCPP' with invalid type id $ {
                typeId
            }
            `);
            _out_515.writeByte(typeId);
            switch(typeId)  {
                case 1: (TelemetryCPP as any).META_BODY.serialize(sCtx_513, obj_514 as any as TelemetryCPP, _out_515);
                break;
                default: throw new Error(`Cannot serialize 'TelemetryCPP' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_513: FastFutureContext, in__516: DataIn): TelemetryCPP  {
            const typeId = in__516.readUByte();
            switch(typeId)  {
                case 1: return (TelemetryCPP as any).META_BODY.deserialize(sCtx_513, in__516) as any as TelemetryCPP;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'TelemetryCPP'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(utm_id: number, blob: Uint8Array, lib_version: string, os: string, compiler: string)  {
        super();
        this.utm_id = utm_id;
        this.blob = blob;
        this.lib_version = lib_version;
        this.os = os;
        this.compiler = compiler;
        if (blob === null || blob === undefined) throw new Error(`Field 'blob' cannot be null for type TelemetryCPP.`);
        if (lib_version === null || lib_version === undefined) throw new Error(`Field 'lib_version' cannot be null for type TelemetryCPP.`);
        if (os === null || os === undefined) throw new Error(`Field 'os' cannot be null for type TelemetryCPP.`);
        if (compiler === null || compiler === undefined) throw new Error(`Field 'compiler' cannot be null for type TelemetryCPP.`);
        
    }
    public getUtm_id(): number  {
        return this.utm_id;
        
    }
    public getBlob(): Uint8Array  {
        return this.blob;
        
    }
    public blobContains(el: number): boolean  {
        return (this.blob as Uint8Array).includes(el as any);
        
    }
    public getLib_version(): string  {
        return this.lib_version;
        
    }
    public getOs(): string  {
        return this.os;
        
    }
    public getCompiler(): string  {
        return this.compiler;
        
    }
    public toString(result: AString): AString  {
        result.add('TelemetryCPP(');
        result.add('utm_id:').add(this.utm_id);
        result.add(', ');
        result.add('blob:').add(this.blob);
        result.add(', ');
        result.add('lib_version:').add(this.lib_version);
        result.add(', ');
        result.add('os:').add(this.os);
        result.add(', ');
        result.add('compiler:').add(this.compiler);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: UUIDAndCloud ---
export class UUIDAndCloud implements ToString  {
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<UUIDAndCloud> = new class implements FastMetaType<UUIDAndCloud>  {
        serialize(sCtx_517: FastFutureContext, obj_518: UUIDAndCloud, _out_519: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_517, obj_518.uid, _out_519);
            Cloud.META.serialize(sCtx_517, obj_518.cloud, _out_519);
            
        }
        deserialize(sCtx_517: FastFutureContext, in__520: DataIn): UUIDAndCloud  {
            let uid_523: UUID;
            let cloud_524: Cloud;
            uid_523 = FastMeta.META_UUID.deserialize(sCtx_517, in__520);
            cloud_524 = Cloud.META.deserialize(sCtx_517, in__520);
            return new UUIDAndCloud(uid_523, cloud_524);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<UUIDAndCloud> = UUIDAndCloud.META_BODY;
    constructor(uid: UUID, cloud: Cloud)  {
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type UUIDAndCloud.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('UUIDAndCloud(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofBCrypt ---
export class WorkProofBCrypt extends WorkProofConfig implements ToString  {
    public readonly costBCrypt: number;
    public readonly poolSize: number;
    public readonly maxHashVal: number;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<WorkProofBCrypt> = new class implements FastMetaType<WorkProofBCrypt>  {
        serialize(sCtx_527: FastFutureContext, obj_528: WorkProofBCrypt, _out_529: DataOut): void  {
            _out_529.writeByte(obj_528.costBCrypt);
            _out_529.writeByte(obj_528.poolSize);
            _out_529.writeInt(obj_528.maxHashVal);
            
        }
        deserialize(sCtx_527: FastFutureContext, in__530: DataIn): WorkProofBCrypt  {
            let costBCrypt_534: number;
            let poolSize_535: number;
            let maxHashVal_536: number;
            costBCrypt_534 = in__530.readByte();
            poolSize_535 = in__530.readByte();
            maxHashVal_536 = in__530.readInt();
            return new WorkProofBCrypt(costBCrypt_534, poolSize_535, maxHashVal_536);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<WorkProofBCrypt> = new class implements FastMetaType<WorkProofBCrypt>  {
        serialize(sCtx_540: FastFutureContext, obj_541: WorkProofBCrypt, _out_542: DataOut): void  {
            const typeId = typeof (obj_541 as any).getAetherTypeId === 'function' ? obj_541.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'WorkProofBCrypt' with invalid type id $ {
                typeId
            }
            `);
            _out_542.writeByte(typeId);
            switch(typeId)  {
                case 1: (WorkProofBCrypt as any).META_BODY.serialize(sCtx_540, obj_541 as any as WorkProofBCrypt, _out_542);
                break;
                default: throw new Error(`Cannot serialize 'WorkProofBCrypt' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_540: FastFutureContext, in__543: DataIn): WorkProofBCrypt  {
            const typeId = in__543.readUByte();
            switch(typeId)  {
                case 1: return (WorkProofBCrypt as any).META_BODY.deserialize(sCtx_540, in__543) as any as WorkProofBCrypt;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'WorkProofBCrypt'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(costBCrypt: number, poolSize: number, maxHashVal: number)  {
        super();
        this.costBCrypt = costBCrypt;
        this.poolSize = poolSize;
        this.maxHashVal = maxHashVal;
        
    }
    public getCostBCrypt(): number  {
        return this.costBCrypt;
        
    }
    public getPoolSize(): number  {
        return this.poolSize;
        
    }
    public getMaxHashVal(): number  {
        return this.maxHashVal;
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofBCrypt(');
        result.add('costBCrypt:').add(this.costBCrypt);
        result.add(', ');
        result.add('poolSize:').add(this.poolSize);
        result.add(', ');
        result.add('maxHashVal:').add(this.maxHashVal);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofDTO ---
export class WorkProofDTO implements ToString  {
    public readonly salt: string;
    public readonly suffix: string;
    public readonly poolSize: number;
    public readonly maxHashVal: number;
    public readonly globalKey: SignedKey;
    public static readonly META_BODY: FastMetaType<WorkProofDTO> = new class implements FastMetaType<WorkProofDTO>  {
        serialize(sCtx_544: FastFutureContext, obj_545: WorkProofDTO, _out_546: DataOut): void  {
            const stringBytes_549 = new TextEncoder().encode(obj_545.salt);
            SerializerPackNumber.INSTANCE.put(_out_546, stringBytes_549.length);
            _out_546.write(stringBytes_549);
            const stringBytes_552 = new TextEncoder().encode(obj_545.suffix);
            SerializerPackNumber.INSTANCE.put(_out_546, stringBytes_552.length);
            _out_546.write(stringBytes_552);
            _out_546.writeByte(obj_545.poolSize);
            _out_546.writeInt(obj_545.maxHashVal);
            SignedKey.META.serialize(sCtx_544, obj_545.globalKey, _out_546);
            
        }
        deserialize(sCtx_544: FastFutureContext, in__547: DataIn): WorkProofDTO  {
            let salt_557: string;
            let suffix_558: string;
            let poolSize_559: number;
            let maxHashVal_560: number;
            let globalKey_561: SignedKey;
            let stringBytes_563: Uint8Array;
            const len_565 = DeserializerPackNumber.INSTANCE.put(in__547).valueOf();
            const bytes_566 = in__547.readBytes(len_565);
            stringBytes_563 = bytes_566;
            salt_557 = new TextDecoder('utf-8').decode(stringBytes_563);
            let stringBytes_568: Uint8Array;
            const len_570 = DeserializerPackNumber.INSTANCE.put(in__547).valueOf();
            const bytes_571 = in__547.readBytes(len_570);
            stringBytes_568 = bytes_571;
            suffix_558 = new TextDecoder('utf-8').decode(stringBytes_568);
            poolSize_559 = in__547.readByte();
            maxHashVal_560 = in__547.readInt();
            globalKey_561 = SignedKey.META.deserialize(sCtx_544, in__547);
            return new WorkProofDTO(salt_557, suffix_558, poolSize_559, maxHashVal_560, globalKey_561);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<WorkProofDTO> = WorkProofDTO.META_BODY;
    constructor(salt: string, suffix: string, poolSize: number, maxHashVal: number, globalKey: SignedKey)  {
        this.salt = salt;
        this.suffix = suffix;
        this.poolSize = poolSize;
        this.maxHashVal = maxHashVal;
        this.globalKey = globalKey;
        if (salt === null || salt === undefined) throw new Error(`Field 'salt' cannot be null for type WorkProofDTO.`);
        if (suffix === null || suffix === undefined) throw new Error(`Field 'suffix' cannot be null for type WorkProofDTO.`);
        if (globalKey === null || globalKey === undefined) throw new Error(`Field 'globalKey' cannot be null for type WorkProofDTO.`);
        
    }
    public getSalt(): string  {
        return this.salt;
        
    }
    public getSuffix(): string  {
        return this.suffix;
        
    }
    public getPoolSize(): number  {
        return this.poolSize;
        
    }
    public getMaxHashVal(): number  {
        return this.maxHashVal;
        
    }
    public getGlobalKey(): SignedKey  {
        return this.globalKey;
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofDTO(');
        result.add('salt:').add(this.salt);
        result.add(', ');
        result.add('suffix:').add(this.suffix);
        result.add(', ');
        result.add('poolSize:').add(this.poolSize);
        result.add(', ');
        result.add('maxHashVal:').add(this.maxHashVal);
        result.add(', ');
        result.add('globalKey:').add(this.globalKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Stream: ClientApiRegSafeStream ---
export class ClientApiRegSafeStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientApiRegSafeStream> = new class implements FastMetaType<ClientApiRegSafeStream>  {
        serialize(ctx: FastFutureContext, obj: ClientApiRegSafeStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientApiRegSafeStream  {
            return new ClientApiRegSafeStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientApiRegSafeStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ClientApiRegSafe): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ClientApiRegSafe as any).META) throw new Error(`META not found for API type ClientApiRegSafe`);
        (ClientApiRegSafe as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ClientApiRegSafeRemote>, sendFuture: AFuture): ClientApiRegSafeStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ClientApiRegSafeRemote>): ClientApiRegSafeStream  {
        const api = (ClientApiRegSafe as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): ClientApiRegSafeStream  {
        const encryptedData = provider(remoteData);
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    
}
// --- Generated Stream: ClientApiStream ---
export class ClientApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientApiStream> = new class implements FastMetaType<ClientApiStream>  {
        serialize(ctx: FastFutureContext, obj: ClientApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientApiStream  {
            return new ClientApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, localApi: ServerApiByUid): void  {
        const dataInStatic = new DataInOutStatic(this.data);
        if (!(ServerApiByUid as any).META) throw new Error(`META not found for API type ServerApiByUid`);
        (ServerApiByUid as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, remote: RemoteApiFuture<ServerApiByUidRemote>, sendFuture: AFuture): ClientApiStream  {
        remote.executeAll(context, sendFuture);
        return new ClientApiStream(context.remoteDataToArrayAsArray());
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, remoteConsumer: AConsumer<ServerApiByUidRemote>): ClientApiStream  {
        const api = (ServerApiByUid as any).META.makeRemote(context);
        remoteConsumer(api);
        return new ClientApiStream(context.remoteDataToArrayAsArray());
        
    }
    
}
// --- Generated Stream: ClientInteractionClientStream ---
export class ClientInteractionClientStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientInteractionClientStream> = new class implements FastMetaType<ClientInteractionClientStream>  {
        serialize(ctx: FastFutureContext, obj: ClientInteractionClientStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientInteractionClientStream  {
            return new ClientInteractionClientStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientInteractionClientStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, localApi: ServerApiByUidClient): void  {
        const dataInStatic = new DataInOutStatic(this.data);
        if (!(ServerApiByUidClient as any).META) throw new Error(`META not found for API type ServerApiByUidClient`);
        (ServerApiByUidClient as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, remote: RemoteApiFuture<ServerApiByUidClientRemote>, sendFuture: AFuture): ClientInteractionClientStream  {
        remote.executeAll(context, sendFuture);
        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, remoteConsumer: AConsumer<ServerApiByUidClientRemote>): ClientInteractionClientStream  {
        const api = (ServerApiByUidClient as any).META.makeRemote(context);
        remoteConsumer(api);
        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());
        
    }
    
}
// --- Generated Stream: GlobalApiRegistrationServerRegistrationApi ---
export class GlobalApiRegistrationServerRegistrationApi implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<GlobalApiRegistrationServerRegistrationApi> = new class implements FastMetaType<GlobalApiRegistrationServerRegistrationApi>  {
        serialize(ctx: FastFutureContext, obj: GlobalApiRegistrationServerRegistrationApi, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): GlobalApiRegistrationServerRegistrationApi  {
            return new GlobalApiRegistrationServerRegistrationApi(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('GlobalApiRegistrationServerRegistrationApi(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: GlobalRegServerApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(GlobalRegServerApi as any).META) throw new Error(`META not found for API type GlobalRegServerApi`);
        (GlobalRegServerApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<GlobalRegServerApiRemote>, sendFuture: AFuture): GlobalApiRegistrationServerRegistrationApi  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<GlobalRegServerApiRemote>): GlobalApiRegistrationServerRegistrationApi  {
        const api = (GlobalRegServerApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): GlobalApiRegistrationServerRegistrationApi  {
        const encryptedData = provider(remoteData);
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    
}
// --- Generated Stream: GlobalRegClientApiStream ---
export class GlobalRegClientApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<GlobalRegClientApiStream> = new class implements FastMetaType<GlobalRegClientApiStream>  {
        serialize(ctx: FastFutureContext, obj: GlobalRegClientApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): GlobalRegClientApiStream  {
            return new GlobalRegClientApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('GlobalRegClientApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: GlobalRegClientApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(GlobalRegClientApi as any).META) throw new Error(`META not found for API type GlobalRegClientApi`);
        (GlobalRegClientApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<GlobalRegClientApiRemote>, sendFuture: AFuture): GlobalRegClientApiStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<GlobalRegClientApiRemote>): GlobalRegClientApiStream  {
        const api = (GlobalRegClientApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): GlobalRegClientApiStream  {
        const encryptedData = provider(remoteData);
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    
}
// --- Generated Stream: LoginClientStream ---
export class LoginClientStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<LoginClientStream> = new class implements FastMetaType<LoginClientStream>  {
        serialize(ctx: FastFutureContext, obj: LoginClientStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): LoginClientStream  {
            return new LoginClientStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('LoginClientStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ClientApiSafe): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ClientApiSafe as any).META) throw new Error(`META not found for API type ClientApiSafe`);
        (ClientApiSafe as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ClientApiSafeRemote>, sendFuture: AFuture): LoginClientStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginClientStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ClientApiSafeRemote>): LoginClientStream  {
        const api = (ClientApiSafe as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginClientStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): LoginClientStream  {
        const encryptedData = provider(remoteData);
        return new LoginClientStream(encryptedData);
        
    }
    
}
// --- Generated Stream: LoginStream ---
export class LoginStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<LoginStream> = new class implements FastMetaType<LoginStream>  {
        serialize(ctx: FastFutureContext, obj: LoginStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): LoginStream  {
            return new LoginStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('LoginStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: AuthorizedApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(AuthorizedApi as any).META) throw new Error(`META not found for API type AuthorizedApi`);
        (AuthorizedApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<AuthorizedApiRemote>, sendFuture: AFuture): LoginStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<AuthorizedApiRemote>): LoginStream  {
        const api = (AuthorizedApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): LoginStream  {
        const encryptedData = provider(remoteData);
        return new LoginStream(encryptedData);
        
    }
    
}
// --- Generated Stream: ServerRegistrationApiStream ---
export class ServerRegistrationApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ServerRegistrationApiStream> = new class implements FastMetaType<ServerRegistrationApiStream>  {
        serialize(ctx: FastFutureContext, obj: ServerRegistrationApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ServerRegistrationApiStream  {
            return new ServerRegistrationApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ServerRegistrationApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ServerRegistrationApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ServerRegistrationApi as any).META) throw new Error(`META not found for API type ServerRegistrationApi`);
        (ServerRegistrationApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ServerRegistrationApiRemote>, sendFuture: AFuture): ServerRegistrationApiStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ServerRegistrationApiRemote>): ServerRegistrationApiStream  {
        const api = (ServerRegistrationApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): ServerRegistrationApiStream  {
        const encryptedData = provider(remoteData);
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    
}
// --- Generated API Interface: ClientApiUnsafe ---
export interface ClientApiUnsafe  {
    sendSafeApiDataMulti(backId: number, data: LoginClientStream): AFuture;
    sendSafeApiData(data: LoginClientStream): AFuture;
    
}
export namespace ClientApiUnsafe  {
    export const META: FastMetaApi<ClientApiUnsafe, ClientApiUnsafeRemote> = new class implements FastMetaApi<ClientApiUnsafe, ClientApiUnsafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiUnsafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let backId_576: number;
                        let data_577: LoginClientStream;
                        backId_576 = dataIn.readByte();
                        data_577 = LoginClientStream.META.deserialize(ctx, dataIn);
                        const argsNames_580: string[] = ["backId", "data"];
                        const argsValues_581: any[] = [backId_576, data_577];
                        ctx.invokeLocalMethodBefore("sendSafeApiDataMulti", argsNames_580, argsValues_581);
                        localApi.sendSafeApiDataMulti(backId_576, data_577);
                        ctx.invokeLocalMethodAfter("sendSafeApiDataMulti", null, argsNames_580, argsValues_581);
                        break;
                        
                    }
                    case 4:  {
                        let data_583: LoginClientStream;
                        data_583 = LoginClientStream.META.deserialize(ctx, dataIn);
                        const argsNames_585: string[] = ["data"];
                        const argsValues_586: any[] = [data_583];
                        ctx.invokeLocalMethodBefore("sendSafeApiData", argsNames_585, argsValues_586);
                        localApi.sendSafeApiData(data_583);
                        ctx.invokeLocalMethodAfter("sendSafeApiData", null, argsNames_585, argsValues_586);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiUnsafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiUnsafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_587: FastFutureContext): ClientApiUnsafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_587.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_587, sendSafeApiDataMulti: (backId: number, data: LoginClientStream): AFuture =>  {
                    const dataOut_589 = new DataInOut();
                    dataOut_589.writeByte(3);
                    const argsNames_591: string[] = ["backId", "data"];
                    const argsValues_592: any[] = [backId, data];
                    sCtx_587.invokeRemoteMethodAfter("sendSafeApiDataMulti", null, argsNames_591, argsValues_592);
                    dataOut_589.writeByte(backId);
                    LoginClientStream.META.serialize(sCtx_587, data, dataOut_589);
                    sCtx_587.sendToRemote(dataOut_589.toArray());
                    return AFuture.of();
                    
                }
                , sendSafeApiData: (data: LoginClientStream): AFuture =>  {
                    const dataOut_596 = new DataInOut();
                    dataOut_596.writeByte(4);
                    const argsNames_598: string[] = ["data"];
                    const argsValues_599: any[] = [data];
                    sCtx_587.invokeRemoteMethodAfter("sendSafeApiData", null, argsNames_598, argsValues_599);
                    LoginClientStream.META.serialize(sCtx_587, data, dataOut_596);
                    sCtx_587.sendToRemote(dataOut_596.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiUnsafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiUnsafeRemote ---
export interface ClientApiUnsafeRemote extends ClientApiUnsafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiUnsafeLocal ---
export abstract class ClientApiUnsafeLocal<RT extends ClientApiUnsafeRemote> implements ClientApiUnsafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract sendSafeApiDataMulti(backId: number, data: LoginClientStream): AFuture;
    public abstract sendSafeApiData(data: LoginClientStream): AFuture;
    
}
// --- Generated API Interface: ClientApiSafe ---
export interface ClientApiSafe  {
    changeParent(uid: UUID): AFuture;
    changeAlias(alias: UUID): AFuture;
    newChild(uid: UUID): AFuture;
    sendMessages(msg: Message[]): AFuture;
    sendServerDescriptor(serverDescriptor: ServerDescriptor): AFuture;
    sendServerDescriptors(serverDescriptors: ServerDescriptor[]): AFuture;
    sendCloud(uid: UUID, cloud: Cloud): AFuture;
    sendClouds(clouds: UUIDAndCloud[]): AFuture;
    requestTelemetry(): AFuture;
    
}
export namespace ClientApiSafe  {
    export const META: FastMetaApi<ClientApiSafe, ClientApiSafeRemote> = new class implements FastMetaApi<ClientApiSafe, ClientApiSafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiSafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let uid_602: UUID;
                        uid_602 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_604: string[] = ["uid"];
                        const argsValues_605: any[] = [uid_602];
                        ctx.invokeLocalMethodBefore("changeParent", argsNames_604, argsValues_605);
                        localApi.changeParent(uid_602);
                        ctx.invokeLocalMethodAfter("changeParent", null, argsNames_604, argsValues_605);
                        break;
                        
                    }
                    case 4:  {
                        let alias_607: UUID;
                        alias_607 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_609: string[] = ["alias"];
                        const argsValues_610: any[] = [alias_607];
                        ctx.invokeLocalMethodBefore("changeAlias", argsNames_609, argsValues_610);
                        localApi.changeAlias(alias_607);
                        ctx.invokeLocalMethodAfter("changeAlias", null, argsNames_609, argsValues_610);
                        break;
                        
                    }
                    case 5:  {
                        let uid_612: UUID;
                        uid_612 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_614: string[] = ["uid"];
                        const argsValues_615: any[] = [uid_612];
                        ctx.invokeLocalMethodBefore("newChild", argsNames_614, argsValues_615);
                        localApi.newChild(uid_612);
                        ctx.invokeLocalMethodAfter("newChild", null, argsNames_614, argsValues_615);
                        break;
                        
                    }
                    case 6:  {
                        let msg_617: Message[];
                        const len_619 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        msg_617 = new Array<Message>(len_619);
                        for (let idx_618 = 0;
                        idx_618 < len_619;
                        idx_618++)  {
                            msg_617[idx_618] = Message.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_621: string[] = ["msg"];
                        const argsValues_622: any[] = [msg_617];
                        ctx.invokeLocalMethodBefore("sendMessages", argsNames_621, argsValues_622);
                        localApi.sendMessages(msg_617);
                        ctx.invokeLocalMethodAfter("sendMessages", null, argsNames_621, argsValues_622);
                        break;
                        
                    }
                    case 7:  {
                        let serverDescriptor_624: ServerDescriptor;
                        serverDescriptor_624 = ServerDescriptor.META.deserialize(ctx, dataIn);
                        const argsNames_626: string[] = ["serverDescriptor"];
                        const argsValues_627: any[] = [serverDescriptor_624];
                        ctx.invokeLocalMethodBefore("sendServerDescriptor", argsNames_626, argsValues_627);
                        localApi.sendServerDescriptor(serverDescriptor_624);
                        ctx.invokeLocalMethodAfter("sendServerDescriptor", null, argsNames_626, argsValues_627);
                        break;
                        
                    }
                    case 8:  {
                        let serverDescriptors_629: ServerDescriptor[];
                        const len_631 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        serverDescriptors_629 = new Array<ServerDescriptor>(len_631);
                        for (let idx_630 = 0;
                        idx_630 < len_631;
                        idx_630++)  {
                            serverDescriptors_629[idx_630] = ServerDescriptor.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_633: string[] = ["serverDescriptors"];
                        const argsValues_634: any[] = [serverDescriptors_629];
                        ctx.invokeLocalMethodBefore("sendServerDescriptors", argsNames_633, argsValues_634);
                        localApi.sendServerDescriptors(serverDescriptors_629);
                        ctx.invokeLocalMethodAfter("sendServerDescriptors", null, argsNames_633, argsValues_634);
                        break;
                        
                    }
                    case 9:  {
                        let uid_636: UUID;
                        let cloud_637: Cloud;
                        uid_636 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        cloud_637 = Cloud.META.deserialize(ctx, dataIn);
                        const argsNames_640: string[] = ["uid", "cloud"];
                        const argsValues_641: any[] = [uid_636, cloud_637];
                        ctx.invokeLocalMethodBefore("sendCloud", argsNames_640, argsValues_641);
                        localApi.sendCloud(uid_636, cloud_637);
                        ctx.invokeLocalMethodAfter("sendCloud", null, argsNames_640, argsValues_641);
                        break;
                        
                    }
                    case 10:  {
                        let clouds_643: UUIDAndCloud[];
                        const len_645 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        clouds_643 = new Array<UUIDAndCloud>(len_645);
                        for (let idx_644 = 0;
                        idx_644 < len_645;
                        idx_644++)  {
                            clouds_643[idx_644] = UUIDAndCloud.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_647: string[] = ["clouds"];
                        const argsValues_648: any[] = [clouds_643];
                        ctx.invokeLocalMethodBefore("sendClouds", argsNames_647, argsValues_648);
                        localApi.sendClouds(clouds_643);
                        ctx.invokeLocalMethodAfter("sendClouds", null, argsNames_647, argsValues_648);
                        break;
                        
                    }
                    case 11:  {
                        const argsNames_650: string[] = [];
                        const argsValues_651: any[] = [];
                        ctx.invokeLocalMethodBefore("requestTelemetry", argsNames_650, argsValues_651);
                        localApi.requestTelemetry();
                        ctx.invokeLocalMethodAfter("requestTelemetry", null, argsNames_650, argsValues_651);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiSafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiSafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_652: FastFutureContext): ClientApiSafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_652.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_652, changeParent: (uid: UUID): AFuture =>  {
                    const dataOut_654 = new DataInOut();
                    dataOut_654.writeByte(3);
                    const argsNames_656: string[] = ["uid"];
                    const argsValues_657: any[] = [uid];
                    sCtx_652.invokeRemoteMethodAfter("changeParent", null, argsNames_656, argsValues_657);
                    FastMeta.META_UUID.serialize(sCtx_652, uid, dataOut_654);
                    sCtx_652.sendToRemote(dataOut_654.toArray());
                    return AFuture.of();
                    
                }
                , changeAlias: (alias: UUID): AFuture =>  {
                    const dataOut_660 = new DataInOut();
                    dataOut_660.writeByte(4);
                    const argsNames_662: string[] = ["alias"];
                    const argsValues_663: any[] = [alias];
                    sCtx_652.invokeRemoteMethodAfter("changeAlias", null, argsNames_662, argsValues_663);
                    FastMeta.META_UUID.serialize(sCtx_652, alias, dataOut_660);
                    sCtx_652.sendToRemote(dataOut_660.toArray());
                    return AFuture.of();
                    
                }
                , newChild: (uid: UUID): AFuture =>  {
                    const dataOut_666 = new DataInOut();
                    dataOut_666.writeByte(5);
                    const argsNames_668: string[] = ["uid"];
                    const argsValues_669: any[] = [uid];
                    sCtx_652.invokeRemoteMethodAfter("newChild", null, argsNames_668, argsValues_669);
                    FastMeta.META_UUID.serialize(sCtx_652, uid, dataOut_666);
                    sCtx_652.sendToRemote(dataOut_666.toArray());
                    return AFuture.of();
                    
                }
                , sendMessages: (msg: Message[]): AFuture =>  {
                    const dataOut_672 = new DataInOut();
                    dataOut_672.writeByte(6);
                    const argsNames_674: string[] = ["msg"];
                    const argsValues_675: any[] = [msg];
                    sCtx_652.invokeRemoteMethodAfter("sendMessages", null, argsNames_674, argsValues_675);
                    SerializerPackNumber.INSTANCE.put(dataOut_672, msg.length);
                    for (const el_676 of msg)  {
                        Message.META.serialize(sCtx_652, el_676, dataOut_672);
                        
                    }
                    sCtx_652.sendToRemote(dataOut_672.toArray());
                    return AFuture.of();
                    
                }
                , sendServerDescriptor: (serverDescriptor: ServerDescriptor): AFuture =>  {
                    const dataOut_679 = new DataInOut();
                    dataOut_679.writeByte(7);
                    const argsNames_681: string[] = ["serverDescriptor"];
                    const argsValues_682: any[] = [serverDescriptor];
                    sCtx_652.invokeRemoteMethodAfter("sendServerDescriptor", null, argsNames_681, argsValues_682);
                    ServerDescriptor.META.serialize(sCtx_652, serverDescriptor, dataOut_679);
                    sCtx_652.sendToRemote(dataOut_679.toArray());
                    return AFuture.of();
                    
                }
                , sendServerDescriptors: (serverDescriptors: ServerDescriptor[]): AFuture =>  {
                    const dataOut_685 = new DataInOut();
                    dataOut_685.writeByte(8);
                    const argsNames_687: string[] = ["serverDescriptors"];
                    const argsValues_688: any[] = [serverDescriptors];
                    sCtx_652.invokeRemoteMethodAfter("sendServerDescriptors", null, argsNames_687, argsValues_688);
                    SerializerPackNumber.INSTANCE.put(dataOut_685, serverDescriptors.length);
                    for (const el_689 of serverDescriptors)  {
                        ServerDescriptor.META.serialize(sCtx_652, el_689, dataOut_685);
                        
                    }
                    sCtx_652.sendToRemote(dataOut_685.toArray());
                    return AFuture.of();
                    
                }
                , sendCloud: (uid: UUID, cloud: Cloud): AFuture =>  {
                    const dataOut_692 = new DataInOut();
                    dataOut_692.writeByte(9);
                    const argsNames_694: string[] = ["uid", "cloud"];
                    const argsValues_695: any[] = [uid, cloud];
                    sCtx_652.invokeRemoteMethodAfter("sendCloud", null, argsNames_694, argsValues_695);
                    FastMeta.META_UUID.serialize(sCtx_652, uid, dataOut_692);
                    Cloud.META.serialize(sCtx_652, cloud, dataOut_692);
                    sCtx_652.sendToRemote(dataOut_692.toArray());
                    return AFuture.of();
                    
                }
                , sendClouds: (clouds: UUIDAndCloud[]): AFuture =>  {
                    const dataOut_699 = new DataInOut();
                    dataOut_699.writeByte(10);
                    const argsNames_701: string[] = ["clouds"];
                    const argsValues_702: any[] = [clouds];
                    sCtx_652.invokeRemoteMethodAfter("sendClouds", null, argsNames_701, argsValues_702);
                    SerializerPackNumber.INSTANCE.put(dataOut_699, clouds.length);
                    for (const el_703 of clouds)  {
                        UUIDAndCloud.META.serialize(sCtx_652, el_703, dataOut_699);
                        
                    }
                    sCtx_652.sendToRemote(dataOut_699.toArray());
                    return AFuture.of();
                    
                }
                , requestTelemetry: (): AFuture =>  {
                    const dataOut_706 = new DataInOut();
                    dataOut_706.writeByte(11);
                    const argsNames_708: string[] = [];
                    const argsValues_709: any[] = [];
                    sCtx_652.invokeRemoteMethodAfter("requestTelemetry", null, argsNames_708, argsValues_709);
                    sCtx_652.sendToRemote(dataOut_706.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiSafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiSafeRemote ---
export interface ClientApiSafeRemote extends ClientApiSafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiSafeLocal ---
export abstract class ClientApiSafeLocal<RT extends ClientApiSafeRemote> implements ClientApiSafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract changeParent(uid: UUID): AFuture;
    public abstract changeAlias(alias: UUID): AFuture;
    public abstract newChild(uid: UUID): AFuture;
    public abstract sendMessages(msg: Message[]): AFuture;
    public abstract sendServerDescriptor(serverDescriptor: ServerDescriptor): AFuture;
    public abstract sendServerDescriptors(serverDescriptors: ServerDescriptor[]): AFuture;
    public abstract sendCloud(uid: UUID, cloud: Cloud): AFuture;
    public abstract sendClouds(clouds: UUIDAndCloud[]): AFuture;
    public abstract requestTelemetry(): AFuture;
    
}
// --- Generated API Interface: AuthorizedApi ---
export interface AuthorizedApi  {
    backId(id: number): AFuture;
    ping(nextConnectMsDuration: number): AFuture;
    client(uid: UUID, stream: ClientApiStream): AFuture;
    sendMessage(msg: Message): AFuture;
    sendMessages(msg: Message[]): AFuture;
    createAccessGroup(owner: UUID, uids: UUID[]): ARFuture<number>;
    addToAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    removeFromAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    checkAccessForSendMessage(uid: UUID): AFuture;
    resolverServers(sid: number[]): AFuture;
    resolverClouds(uids: UUID[]): AFuture;
    getAccessGroups(uid: UUID): ARFuture<number[]>;
    getAccessGroup(groupId: number): ARFuture<AccessGroup>;
    getAllAccessedClients(uid: UUID): ARFuture<UUID[]>;
    checkAccessForSendMessage2(uid1: UUID, uid2: UUID): ARFuture<boolean>;
    sendTelemetry(telemetry: Telemetry): AFuture;
    
}
export namespace AuthorizedApi  {
    export const META: FastMetaApi<AuthorizedApi, AuthorizedApiRemote> = new class implements FastMetaApi<AuthorizedApi, AuthorizedApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: AuthorizedApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let id_711: number;
                        id_711 = dataIn.readByte();
                        const argsNames_713: string[] = ["id"];
                        const argsValues_714: any[] = [id_711];
                        ctx.invokeLocalMethodBefore("backId", argsNames_713, argsValues_714);
                        localApi.backId(id_711);
                        ctx.invokeLocalMethodAfter("backId", null, argsNames_713, argsValues_714);
                        break;
                        
                    }
                    case 4:  {
                        let nextConnectMsDuration_716: number;
                        nextConnectMsDuration_716 = dataIn.readLong();
                        const argsNames_718: string[] = ["nextConnectMsDuration"];
                        const argsValues_719: any[] = [nextConnectMsDuration_716];
                        ctx.invokeLocalMethodBefore("ping", argsNames_718, argsValues_719);
                        localApi.ping(nextConnectMsDuration_716);
                        ctx.invokeLocalMethodAfter("ping", null, argsNames_718, argsValues_719);
                        break;
                        
                    }
                    case 5:  {
                        let uid_721: UUID;
                        let stream_722: ClientApiStream;
                        uid_721 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        stream_722 = ClientApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_725: string[] = ["uid", "stream"];
                        const argsValues_726: any[] = [uid_721, stream_722];
                        ctx.invokeLocalMethodBefore("client", argsNames_725, argsValues_726);
                        localApi.client(uid_721, stream_722);
                        ctx.invokeLocalMethodAfter("client", null, argsNames_725, argsValues_726);
                        break;
                        
                    }
                    case 6:  {
                        let msg_728: Message;
                        msg_728 = Message.META.deserialize(ctx, dataIn);
                        const argsNames_730: string[] = ["msg"];
                        const argsValues_731: any[] = [msg_728];
                        ctx.invokeLocalMethodBefore("sendMessage", argsNames_730, argsValues_731);
                        localApi.sendMessage(msg_728);
                        ctx.invokeLocalMethodAfter("sendMessage", null, argsNames_730, argsValues_731);
                        break;
                        
                    }
                    case 7:  {
                        let msg_733: Message[];
                        const len_735 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        msg_733 = new Array<Message>(len_735);
                        for (let idx_734 = 0;
                        idx_734 < len_735;
                        idx_734++)  {
                            msg_733[idx_734] = Message.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_737: string[] = ["msg"];
                        const argsValues_738: any[] = [msg_733];
                        ctx.invokeLocalMethodBefore("sendMessages", argsNames_737, argsValues_738);
                        localApi.sendMessages(msg_733);
                        ctx.invokeLocalMethodAfter("sendMessages", null, argsNames_737, argsValues_738);
                        break;
                        
                    }
                    case 8:  {
                        const reqId_739 = dataIn.readInt();
                        let owner_740: UUID;
                        let uids_741: UUID[];
                        owner_740 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_744 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_741 = new Array<UUID>(len_744);
                        for (let idx_743 = 0;
                        idx_743 < len_744;
                        idx_743++)  {
                            uids_741[idx_743] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_746: string[] = ["owner", "uids"];
                        const argsValues_747: any[] = [owner_740, uids_741];
                        ctx.invokeLocalMethodBefore("createAccessGroup", argsNames_746, argsValues_747);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.createAccessGroup(owner_740, uids_741);
                        ctx.invokeLocalMethodAfter("createAccessGroup", resultFuture, argsNames_746, argsValues_747);
                        resultFuture.to((v_749: number) =>  {
                            const data_748 = new DataInOut();
                            data_748.writeLong(v_749);
                            ctx.sendResultToRemote(reqId_739, data_748.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 9:  {
                        const reqId_751 = dataIn.readInt();
                        let groupId_752: number;
                        let uid_753: UUID;
                        groupId_752 = dataIn.readLong();
                        uid_753 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_756: string[] = ["groupId", "uid"];
                        const argsValues_757: any[] = [groupId_752, uid_753];
                        ctx.invokeLocalMethodBefore("addToAccessGroup", argsNames_756, argsValues_757);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.addToAccessGroup(groupId_752, uid_753);
                        ctx.invokeLocalMethodAfter("addToAccessGroup", resultFuture, argsNames_756, argsValues_757);
                        resultFuture.to((v_759: boolean) =>  {
                            const data_758 = new DataInOut();
                            data_758.writeBoolean(v_759);
                            ctx.sendResultToRemote(reqId_751, data_758.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 10:  {
                        const reqId_761 = dataIn.readInt();
                        let groupId_762: number;
                        let uid_763: UUID;
                        groupId_762 = dataIn.readLong();
                        uid_763 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_766: string[] = ["groupId", "uid"];
                        const argsValues_767: any[] = [groupId_762, uid_763];
                        ctx.invokeLocalMethodBefore("removeFromAccessGroup", argsNames_766, argsValues_767);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.removeFromAccessGroup(groupId_762, uid_763);
                        ctx.invokeLocalMethodAfter("removeFromAccessGroup", resultFuture, argsNames_766, argsValues_767);
                        resultFuture.to((v_769: boolean) =>  {
                            const data_768 = new DataInOut();
                            data_768.writeBoolean(v_769);
                            ctx.sendResultToRemote(reqId_761, data_768.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 11:  {
                        let uid_772: UUID;
                        uid_772 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_774: string[] = ["uid"];
                        const argsValues_775: any[] = [uid_772];
                        ctx.invokeLocalMethodBefore("checkAccessForSendMessage", argsNames_774, argsValues_775);
                        localApi.checkAccessForSendMessage(uid_772);
                        ctx.invokeLocalMethodAfter("checkAccessForSendMessage", null, argsNames_774, argsValues_775);
                        break;
                        
                    }
                    case 12:  {
                        let sid_777: number[];
                        const len_779 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        sid_777 = new Array<number>(len_779);
                        for (let idx_778 = 0;
                        idx_778 < len_779;
                        idx_778++)  {
                            sid_777[idx_778] = dataIn.readShort();
                            
                        }
                        const argsNames_781: string[] = ["sid"];
                        const argsValues_782: any[] = [sid_777];
                        ctx.invokeLocalMethodBefore("resolverServers", argsNames_781, argsValues_782);
                        localApi.resolverServers(sid_777);
                        ctx.invokeLocalMethodAfter("resolverServers", null, argsNames_781, argsValues_782);
                        break;
                        
                    }
                    case 13:  {
                        let uids_784: UUID[];
                        const len_786 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_784 = new Array<UUID>(len_786);
                        for (let idx_785 = 0;
                        idx_785 < len_786;
                        idx_785++)  {
                            uids_784[idx_785] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_788: string[] = ["uids"];
                        const argsValues_789: any[] = [uids_784];
                        ctx.invokeLocalMethodBefore("resolverClouds", argsNames_788, argsValues_789);
                        localApi.resolverClouds(uids_784);
                        ctx.invokeLocalMethodAfter("resolverClouds", null, argsNames_788, argsValues_789);
                        break;
                        
                    }
                    case 14:  {
                        const reqId_790 = dataIn.readInt();
                        let uid_791: UUID;
                        uid_791 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_793: string[] = ["uid"];
                        const argsValues_794: any[] = [uid_791];
                        ctx.invokeLocalMethodBefore("getAccessGroups", argsNames_793, argsValues_794);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAccessGroups(uid_791);
                        ctx.invokeLocalMethodAfter("getAccessGroups", resultFuture, argsNames_793, argsValues_794);
                        resultFuture.to((v_796: number[]) =>  {
                            const data_795 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_795, v_796.length);
                            for (const el_797 of v_796)  {
                                data_795.writeLong(el_797);
                                
                            }
                            ctx.sendResultToRemote(reqId_790, data_795.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 15:  {
                        const reqId_799 = dataIn.readInt();
                        let groupId_800: number;
                        groupId_800 = dataIn.readLong();
                        const argsNames_802: string[] = ["groupId"];
                        const argsValues_803: any[] = [groupId_800];
                        ctx.invokeLocalMethodBefore("getAccessGroup", argsNames_802, argsValues_803);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAccessGroup(groupId_800);
                        ctx.invokeLocalMethodAfter("getAccessGroup", resultFuture, argsNames_802, argsValues_803);
                        resultFuture.to((v_805: AccessGroup) =>  {
                            const data_804 = new DataInOut();
                            AccessGroup.META.serialize(ctx, v_805, data_804);
                            ctx.sendResultToRemote(reqId_799, data_804.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 16:  {
                        const reqId_807 = dataIn.readInt();
                        let uid_808: UUID;
                        uid_808 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_810: string[] = ["uid"];
                        const argsValues_811: any[] = [uid_808];
                        ctx.invokeLocalMethodBefore("getAllAccessedClients", argsNames_810, argsValues_811);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAllAccessedClients(uid_808);
                        ctx.invokeLocalMethodAfter("getAllAccessedClients", resultFuture, argsNames_810, argsValues_811);
                        resultFuture.to((v_813: UUID[]) =>  {
                            const data_812 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_812, v_813.length);
                            for (const el_814 of v_813)  {
                                FastMeta.META_UUID.serialize(ctx, el_814, data_812);
                                
                            }
                            ctx.sendResultToRemote(reqId_807, data_812.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 17:  {
                        const reqId_816 = dataIn.readInt();
                        let uid1_817: UUID;
                        let uid2_818: UUID;
                        uid1_817 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        uid2_818 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_821: string[] = ["uid1", "uid2"];
                        const argsValues_822: any[] = [uid1_817, uid2_818];
                        ctx.invokeLocalMethodBefore("checkAccessForSendMessage2", argsNames_821, argsValues_822);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.checkAccessForSendMessage2(uid1_817, uid2_818);
                        ctx.invokeLocalMethodAfter("checkAccessForSendMessage2", resultFuture, argsNames_821, argsValues_822);
                        resultFuture.to((v_824: boolean) =>  {
                            const data_823 = new DataInOut();
                            data_823.writeBoolean(v_824);
                            ctx.sendResultToRemote(reqId_816, data_823.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 18:  {
                        let telemetry_827: Telemetry;
                        telemetry_827 = Telemetry.META.deserialize(ctx, dataIn);
                        const argsNames_829: string[] = ["telemetry"];
                        const argsValues_830: any[] = [telemetry_827];
                        ctx.invokeLocalMethodBefore("sendTelemetry", argsNames_829, argsValues_830);
                        localApi.sendTelemetry(telemetry_827);
                        ctx.invokeLocalMethodAfter("sendTelemetry", null, argsNames_829, argsValues_830);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<AuthorizedApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: AuthorizedApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_831: FastFutureContext): AuthorizedApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_831.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_831, backId: (id: number): AFuture =>  {
                    const dataOut_833 = new DataInOut();
                    dataOut_833.writeByte(3);
                    const argsNames_835: string[] = ["id"];
                    const argsValues_836: any[] = [id];
                    sCtx_831.invokeRemoteMethodAfter("backId", null, argsNames_835, argsValues_836);
                    dataOut_833.writeByte(id);
                    sCtx_831.sendToRemote(dataOut_833.toArray());
                    return AFuture.of();
                    
                }
                , ping: (nextConnectMsDuration: number): AFuture =>  {
                    const dataOut_839 = new DataInOut();
                    dataOut_839.writeByte(4);
                    const argsNames_841: string[] = ["nextConnectMsDuration"];
                    const argsValues_842: any[] = [nextConnectMsDuration];
                    sCtx_831.invokeRemoteMethodAfter("ping", null, argsNames_841, argsValues_842);
                    dataOut_839.writeLong(nextConnectMsDuration);
                    sCtx_831.sendToRemote(dataOut_839.toArray());
                    return AFuture.of();
                    
                }
                , client: (uid: UUID, stream: ClientApiStream): AFuture =>  {
                    const dataOut_845 = new DataInOut();
                    dataOut_845.writeByte(5);
                    const argsNames_847: string[] = ["uid", "stream"];
                    const argsValues_848: any[] = [uid, stream];
                    sCtx_831.invokeRemoteMethodAfter("client", null, argsNames_847, argsValues_848);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_845);
                    ClientApiStream.META.serialize(sCtx_831, stream, dataOut_845);
                    sCtx_831.sendToRemote(dataOut_845.toArray());
                    return AFuture.of();
                    
                }
                , sendMessage: (msg: Message): AFuture =>  {
                    const dataOut_852 = new DataInOut();
                    dataOut_852.writeByte(6);
                    const argsNames_854: string[] = ["msg"];
                    const argsValues_855: any[] = [msg];
                    sCtx_831.invokeRemoteMethodAfter("sendMessage", null, argsNames_854, argsValues_855);
                    Message.META.serialize(sCtx_831, msg, dataOut_852);
                    sCtx_831.sendToRemote(dataOut_852.toArray());
                    return AFuture.of();
                    
                }
                , sendMessages: (msg: Message[]): AFuture =>  {
                    const dataOut_858 = new DataInOut();
                    dataOut_858.writeByte(7);
                    const argsNames_860: string[] = ["msg"];
                    const argsValues_861: any[] = [msg];
                    sCtx_831.invokeRemoteMethodAfter("sendMessages", null, argsNames_860, argsValues_861);
                    SerializerPackNumber.INSTANCE.put(dataOut_858, msg.length);
                    for (const el_862 of msg)  {
                        Message.META.serialize(sCtx_831, el_862, dataOut_858);
                        
                    }
                    sCtx_831.sendToRemote(dataOut_858.toArray());
                    return AFuture.of();
                    
                }
                , createAccessGroup: (owner: UUID, uids: UUID[]): ARFuture<number> =>  {
                    const dataOut_865 = new DataInOut();
                    dataOut_865.writeByte(8);
                    const argsNames_867: string[] = ["owner", "uids"];
                    const argsValues_868: any[] = [owner, uids];
                    const result_866 = ARFuture.of<number>();
                    sCtx_831.invokeRemoteMethodAfter("createAccessGroup", result_866, argsNames_867, argsValues_868);
                    const reqId_864 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_866 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_866.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_865.writeInt(reqId_864);
                    FastMeta.META_UUID.serialize(sCtx_831, owner, dataOut_865);
                    SerializerPackNumber.INSTANCE.put(dataOut_865, uids.length);
                    for (const el_870 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_831, el_870, dataOut_865);
                        
                    }
                    sCtx_831.sendToRemote(dataOut_865.toArray());
                    return result_866;
                    
                }
                , addToAccessGroup: (groupId: number, uid: UUID): ARFuture<boolean> =>  {
                    const dataOut_873 = new DataInOut();
                    dataOut_873.writeByte(9);
                    const argsNames_875: string[] = ["groupId", "uid"];
                    const argsValues_876: any[] = [groupId, uid];
                    const result_874 = ARFuture.of<boolean>();
                    sCtx_831.invokeRemoteMethodAfter("addToAccessGroup", result_874, argsNames_875, argsValues_876);
                    const reqId_872 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_874 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_874.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_873.writeInt(reqId_872);
                    dataOut_873.writeLong(groupId);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_873);
                    sCtx_831.sendToRemote(dataOut_873.toArray());
                    return result_874;
                    
                }
                , removeFromAccessGroup: (groupId: number, uid: UUID): ARFuture<boolean> =>  {
                    const dataOut_880 = new DataInOut();
                    dataOut_880.writeByte(10);
                    const argsNames_882: string[] = ["groupId", "uid"];
                    const argsValues_883: any[] = [groupId, uid];
                    const result_881 = ARFuture.of<boolean>();
                    sCtx_831.invokeRemoteMethodAfter("removeFromAccessGroup", result_881, argsNames_882, argsValues_883);
                    const reqId_879 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_881 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_881.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_880.writeInt(reqId_879);
                    dataOut_880.writeLong(groupId);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_880);
                    sCtx_831.sendToRemote(dataOut_880.toArray());
                    return result_881;
                    
                }
                , checkAccessForSendMessage: (uid: UUID): AFuture =>  {
                    const dataOut_887 = new DataInOut();
                    dataOut_887.writeByte(11);
                    const argsNames_889: string[] = ["uid"];
                    const argsValues_890: any[] = [uid];
                    sCtx_831.invokeRemoteMethodAfter("checkAccessForSendMessage", null, argsNames_889, argsValues_890);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_887);
                    sCtx_831.sendToRemote(dataOut_887.toArray());
                    return AFuture.of();
                    
                }
                , resolverServers: (sid: number[]): AFuture =>  {
                    const dataOut_893 = new DataInOut();
                    dataOut_893.writeByte(12);
                    const argsNames_895: string[] = ["sid"];
                    const argsValues_896: any[] = [sid];
                    sCtx_831.invokeRemoteMethodAfter("resolverServers", null, argsNames_895, argsValues_896);
                    SerializerPackNumber.INSTANCE.put(dataOut_893, sid.length);
                    for (const el_897 of sid)  {
                        dataOut_893.writeShort(el_897);
                        
                    }
                    sCtx_831.sendToRemote(dataOut_893.toArray());
                    return AFuture.of();
                    
                }
                , resolverClouds: (uids: UUID[]): AFuture =>  {
                    const dataOut_900 = new DataInOut();
                    dataOut_900.writeByte(13);
                    const argsNames_902: string[] = ["uids"];
                    const argsValues_903: any[] = [uids];
                    sCtx_831.invokeRemoteMethodAfter("resolverClouds", null, argsNames_902, argsValues_903);
                    SerializerPackNumber.INSTANCE.put(dataOut_900, uids.length);
                    for (const el_904 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_831, el_904, dataOut_900);
                        
                    }
                    sCtx_831.sendToRemote(dataOut_900.toArray());
                    return AFuture.of();
                    
                }
                , getAccessGroups: (uid: UUID): ARFuture<number[]> =>  {
                    const dataOut_907 = new DataInOut();
                    dataOut_907.writeByte(14);
                    const argsNames_909: string[] = ["uid"];
                    const argsValues_910: any[] = [uid];
                    const result_908 = ARFuture.of<number[]>();
                    sCtx_831.invokeRemoteMethodAfter("getAccessGroups", result_908, argsNames_909, argsValues_910);
                    const reqId_906 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_908 as ARFuture<number[]>).tryDone(AllCustomMeta.META_ARRAY_long.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_908.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_907.writeInt(reqId_906);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_907);
                    sCtx_831.sendToRemote(dataOut_907.toArray());
                    return result_908;
                    
                }
                , getAccessGroup: (groupId: number): ARFuture<AccessGroup> =>  {
                    const dataOut_913 = new DataInOut();
                    dataOut_913.writeByte(15);
                    const argsNames_915: string[] = ["groupId"];
                    const argsValues_916: any[] = [groupId];
                    const result_914 = ARFuture.of<AccessGroup>();
                    sCtx_831.invokeRemoteMethodAfter("getAccessGroup", result_914, argsNames_915, argsValues_916);
                    const reqId_912 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_914 as ARFuture<AccessGroup>).tryDone(AccessGroup.META.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_914.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_913.writeInt(reqId_912);
                    dataOut_913.writeLong(groupId);
                    sCtx_831.sendToRemote(dataOut_913.toArray());
                    return result_914;
                    
                }
                , getAllAccessedClients: (uid: UUID): ARFuture<UUID[]> =>  {
                    const dataOut_919 = new DataInOut();
                    dataOut_919.writeByte(16);
                    const argsNames_921: string[] = ["uid"];
                    const argsValues_922: any[] = [uid];
                    const result_920 = ARFuture.of<UUID[]>();
                    sCtx_831.invokeRemoteMethodAfter("getAllAccessedClients", result_920, argsNames_921, argsValues_922);
                    const reqId_918 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_920 as ARFuture<UUID[]>).tryDone(AllCustomMeta.META_ARRAY_UUID.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_920.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_919.writeInt(reqId_918);
                    FastMeta.META_UUID.serialize(sCtx_831, uid, dataOut_919);
                    sCtx_831.sendToRemote(dataOut_919.toArray());
                    return result_920;
                    
                }
                , checkAccessForSendMessage2: (uid1: UUID, uid2: UUID): ARFuture<boolean> =>  {
                    const dataOut_925 = new DataInOut();
                    dataOut_925.writeByte(17);
                    const argsNames_927: string[] = ["uid1", "uid2"];
                    const argsValues_928: any[] = [uid1, uid2];
                    const result_926 = ARFuture.of<boolean>();
                    sCtx_831.invokeRemoteMethodAfter("checkAccessForSendMessage2", result_926, argsNames_927, argsValues_928);
                    const reqId_924 = sCtx_831.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_926 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_831, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_926.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_925.writeInt(reqId_924);
                    FastMeta.META_UUID.serialize(sCtx_831, uid1, dataOut_925);
                    FastMeta.META_UUID.serialize(sCtx_831, uid2, dataOut_925);
                    sCtx_831.sendToRemote(dataOut_925.toArray());
                    return result_926;
                    
                }
                , sendTelemetry: (telemetry: Telemetry): AFuture =>  {
                    const dataOut_932 = new DataInOut();
                    dataOut_932.writeByte(18);
                    const argsNames_934: string[] = ["telemetry"];
                    const argsValues_935: any[] = [telemetry];
                    sCtx_831.invokeRemoteMethodAfter("sendTelemetry", null, argsNames_934, argsValues_935);
                    Telemetry.META.serialize(sCtx_831, telemetry, dataOut_932);
                    sCtx_831.sendToRemote(dataOut_932.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as AuthorizedApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: AuthorizedApiRemote ---
export interface AuthorizedApiRemote extends AuthorizedApi, RemoteApi  {
    
}
// --- Generated API Local Class: AuthorizedApiLocal ---
export abstract class AuthorizedApiLocal<RT extends AuthorizedApiRemote> implements AuthorizedApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract backId(id: number): AFuture;
    public abstract ping(nextConnectMsDuration: number): AFuture;
    public abstract client(uid: UUID, stream: ClientApiStream): AFuture;
    public abstract sendMessage(msg: Message): AFuture;
    public abstract sendMessages(msg: Message[]): AFuture;
    public abstract createAccessGroup(owner: UUID, uids: UUID[]): ARFuture<number>;
    public abstract addToAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    public abstract removeFromAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    public abstract checkAccessForSendMessage(uid: UUID): AFuture;
    public abstract resolverServers(sid: number[]): AFuture;
    public abstract resolverClouds(uids: UUID[]): AFuture;
    public abstract getAccessGroups(uid: UUID): ARFuture<number[]>;
    public abstract getAccessGroup(groupId: number): ARFuture<AccessGroup>;
    public abstract getAllAccessedClients(uid: UUID): ARFuture<UUID[]>;
    public abstract checkAccessForSendMessage2(uid1: UUID, uid2: UUID): ARFuture<boolean>;
    public abstract sendTelemetry(telemetry: Telemetry): AFuture;
    
}
// --- Generated API Interface: LoginApi ---
export interface LoginApi  {
    getTimeUTC(): ARFuture<number>;
    loginByUID(uid: UUID, data: LoginStream): AFuture;
    loginByAlias(alias: UUID, data: LoginStream): AFuture;
    
}
export namespace LoginApi  {
    export const META: FastMetaApi<LoginApi, LoginApiRemote> = new class implements FastMetaApi<LoginApi, LoginApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: LoginApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_937 = dataIn.readInt();
                        const argsNames_938: string[] = [];
                        const argsValues_939: any[] = [];
                        ctx.invokeLocalMethodBefore("getTimeUTC", argsNames_938, argsValues_939);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getTimeUTC();
                        ctx.invokeLocalMethodAfter("getTimeUTC", resultFuture, argsNames_938, argsValues_939);
                        resultFuture.to((v_941: number) =>  {
                            const data_940 = new DataInOut();
                            data_940.writeLong(v_941);
                            ctx.sendResultToRemote(reqId_937, data_940.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let uid_944: UUID;
                        let data_945: LoginStream;
                        uid_944 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        data_945 = LoginStream.META.deserialize(ctx, dataIn);
                        const argsNames_948: string[] = ["uid", "data"];
                        const argsValues_949: any[] = [uid_944, data_945];
                        ctx.invokeLocalMethodBefore("loginByUID", argsNames_948, argsValues_949);
                        localApi.loginByUID(uid_944, data_945);
                        ctx.invokeLocalMethodAfter("loginByUID", null, argsNames_948, argsValues_949);
                        break;
                        
                    }
                    case 5:  {
                        let alias_951: UUID;
                        let data_952: LoginStream;
                        alias_951 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        data_952 = LoginStream.META.deserialize(ctx, dataIn);
                        const argsNames_955: string[] = ["alias", "data"];
                        const argsValues_956: any[] = [alias_951, data_952];
                        ctx.invokeLocalMethodBefore("loginByAlias", argsNames_955, argsValues_956);
                        localApi.loginByAlias(alias_951, data_952);
                        ctx.invokeLocalMethodAfter("loginByAlias", null, argsNames_955, argsValues_956);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<LoginApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: LoginApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_957: FastFutureContext): LoginApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_957.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_957, getTimeUTC: (): ARFuture<number> =>  {
                    const dataOut_959 = new DataInOut();
                    dataOut_959.writeByte(3);
                    const argsNames_961: string[] = [];
                    const argsValues_962: any[] = [];
                    const result_960 = ARFuture.of<number>();
                    sCtx_957.invokeRemoteMethodAfter("getTimeUTC", result_960, argsNames_961, argsValues_962);
                    const reqId_958 = sCtx_957.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_960 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_957, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_960.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_959.writeInt(reqId_958);
                    sCtx_957.sendToRemote(dataOut_959.toArray());
                    return result_960;
                    
                }
                , loginByUID: (uid: UUID, data: LoginStream): AFuture =>  {
                    const dataOut_964 = new DataInOut();
                    dataOut_964.writeByte(4);
                    const argsNames_966: string[] = ["uid", "data"];
                    const argsValues_967: any[] = [uid, data];
                    sCtx_957.invokeRemoteMethodAfter("loginByUID", null, argsNames_966, argsValues_967);
                    FastMeta.META_UUID.serialize(sCtx_957, uid, dataOut_964);
                    LoginStream.META.serialize(sCtx_957, data, dataOut_964);
                    sCtx_957.sendToRemote(dataOut_964.toArray());
                    return AFuture.of();
                    
                }
                , loginByAlias: (alias: UUID, data: LoginStream): AFuture =>  {
                    const dataOut_971 = new DataInOut();
                    dataOut_971.writeByte(5);
                    const argsNames_973: string[] = ["alias", "data"];
                    const argsValues_974: any[] = [alias, data];
                    sCtx_957.invokeRemoteMethodAfter("loginByAlias", null, argsNames_973, argsValues_974);
                    FastMeta.META_UUID.serialize(sCtx_957, alias, dataOut_971);
                    LoginStream.META.serialize(sCtx_957, data, dataOut_971);
                    sCtx_957.sendToRemote(dataOut_971.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as LoginApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: LoginApiRemote ---
export interface LoginApiRemote extends LoginApi, RemoteApi  {
    
}
// --- Generated API Local Class: LoginApiLocal ---
export abstract class LoginApiLocal<RT extends LoginApiRemote> implements LoginApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getTimeUTC(): ARFuture<number>;
    public abstract loginByUID(uid: UUID, data: LoginStream): AFuture;
    public abstract loginByAlias(alias: UUID, data: LoginStream): AFuture;
    
}
// --- Generated API Interface: ServerApiByUidClient ---
export interface ServerApiByUidClient  {
    
}
export namespace ServerApiByUidClient  {
    export const META: FastMetaApi<ServerApiByUidClient, ServerApiByUidClientRemote> = new class implements FastMetaApi<ServerApiByUidClient, ServerApiByUidClientRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: ServerApiByUidClient): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerApiByUidClient>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerApiByUidClient): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_977: FastFutureContext): ServerApiByUidClientRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_977.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_977, 
            };
            return remoteApiImpl as ServerApiByUidClientRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerApiByUidClientRemote ---
export interface ServerApiByUidClientRemote extends ServerApiByUidClient, RemoteApi  {
    
}
// --- Generated API Local Class: ServerApiByUidClientLocal ---
export abstract class ServerApiByUidClientLocal<RT extends ServerApiByUidClientRemote> implements ServerApiByUidClient  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: ServerApiByUid ---
export interface ServerApiByUid  {
    getBalance(): ARFuture<number>;
    setParent(uid: UUID): AFuture;
    block(): AFuture;
    getPosition(): ARFuture<Cloud>;
    getParent(): ARFuture<UUID>;
    getBeneficiary(): ARFuture<UUID>;
    setBeneficiary(uid: UUID): AFuture;
    getBlockTime(): ARFuture<Date>;
    unblock(): AFuture;
    createTime(): ARFuture<Date>;
    onlineTime(): ARFuture<Date>;
    addAccessGroup(groupId: number): ARFuture<boolean>;
    removeAccessGroup(groupId: number): ARFuture<boolean>;
    
}
export namespace ServerApiByUid  {
    export const META: FastMetaApi<ServerApiByUid, ServerApiByUidRemote> = new class implements FastMetaApi<ServerApiByUid, ServerApiByUidRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ServerApiByUid): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_978 = dataIn.readInt();
                        const argsNames_979: string[] = [];
                        const argsValues_980: any[] = [];
                        ctx.invokeLocalMethodBefore("getBalance", argsNames_979, argsValues_980);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBalance();
                        ctx.invokeLocalMethodAfter("getBalance", resultFuture, argsNames_979, argsValues_980);
                        resultFuture.to((v_982: number) =>  {
                            const data_981 = new DataInOut();
                            data_981.writeLong(v_982);
                            ctx.sendResultToRemote(reqId_978, data_981.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let uid_985: UUID;
                        uid_985 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_987: string[] = ["uid"];
                        const argsValues_988: any[] = [uid_985];
                        ctx.invokeLocalMethodBefore("setParent", argsNames_987, argsValues_988);
                        localApi.setParent(uid_985);
                        ctx.invokeLocalMethodAfter("setParent", null, argsNames_987, argsValues_988);
                        break;
                        
                    }
                    case 5:  {
                        const argsNames_990: string[] = [];
                        const argsValues_991: any[] = [];
                        ctx.invokeLocalMethodBefore("block", argsNames_990, argsValues_991);
                        localApi.block();
                        ctx.invokeLocalMethodAfter("block", null, argsNames_990, argsValues_991);
                        break;
                        
                    }
                    case 6:  {
                        const reqId_992 = dataIn.readInt();
                        const argsNames_993: string[] = [];
                        const argsValues_994: any[] = [];
                        ctx.invokeLocalMethodBefore("getPosition", argsNames_993, argsValues_994);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getPosition();
                        ctx.invokeLocalMethodAfter("getPosition", resultFuture, argsNames_993, argsValues_994);
                        resultFuture.to((v_996: Cloud) =>  {
                            const data_995 = new DataInOut();
                            Cloud.META.serialize(ctx, v_996, data_995);
                            ctx.sendResultToRemote(reqId_992, data_995.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 7:  {
                        const reqId_998 = dataIn.readInt();
                        const argsNames_999: string[] = [];
                        const argsValues_1000: any[] = [];
                        ctx.invokeLocalMethodBefore("getParent", argsNames_999, argsValues_1000);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getParent();
                        ctx.invokeLocalMethodAfter("getParent", resultFuture, argsNames_999, argsValues_1000);
                        resultFuture.to((v_1002: UUID) =>  {
                            const data_1001 = new DataInOut();
                            FastMeta.META_UUID.serialize(ctx, v_1002, data_1001);
                            ctx.sendResultToRemote(reqId_998, data_1001.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 8:  {
                        const reqId_1004 = dataIn.readInt();
                        const argsNames_1005: string[] = [];
                        const argsValues_1006: any[] = [];
                        ctx.invokeLocalMethodBefore("getBeneficiary", argsNames_1005, argsValues_1006);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBeneficiary();
                        ctx.invokeLocalMethodAfter("getBeneficiary", resultFuture, argsNames_1005, argsValues_1006);
                        resultFuture.to((v_1008: UUID) =>  {
                            const data_1007 = new DataInOut();
                            FastMeta.META_UUID.serialize(ctx, v_1008, data_1007);
                            ctx.sendResultToRemote(reqId_1004, data_1007.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 9:  {
                        let uid_1011: UUID;
                        uid_1011 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_1013: string[] = ["uid"];
                        const argsValues_1014: any[] = [uid_1011];
                        ctx.invokeLocalMethodBefore("setBeneficiary", argsNames_1013, argsValues_1014);
                        localApi.setBeneficiary(uid_1011);
                        ctx.invokeLocalMethodAfter("setBeneficiary", null, argsNames_1013, argsValues_1014);
                        break;
                        
                    }
                    case 10:  {
                        const reqId_1015 = dataIn.readInt();
                        const argsNames_1016: string[] = [];
                        const argsValues_1017: any[] = [];
                        ctx.invokeLocalMethodBefore("getBlockTime", argsNames_1016, argsValues_1017);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBlockTime();
                        ctx.invokeLocalMethodAfter("getBlockTime", resultFuture, argsNames_1016, argsValues_1017);
                        resultFuture.to((v_1019: Date) =>  {
                            const data_1018 = new DataInOut();
                            data_1018.writeLong(v_1019.getTime());
                            ctx.sendResultToRemote(reqId_1015, data_1018.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 11:  {
                        const argsNames_1022: string[] = [];
                        const argsValues_1023: any[] = [];
                        ctx.invokeLocalMethodBefore("unblock", argsNames_1022, argsValues_1023);
                        localApi.unblock();
                        ctx.invokeLocalMethodAfter("unblock", null, argsNames_1022, argsValues_1023);
                        break;
                        
                    }
                    case 12:  {
                        const reqId_1024 = dataIn.readInt();
                        const argsNames_1025: string[] = [];
                        const argsValues_1026: any[] = [];
                        ctx.invokeLocalMethodBefore("createTime", argsNames_1025, argsValues_1026);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.createTime();
                        ctx.invokeLocalMethodAfter("createTime", resultFuture, argsNames_1025, argsValues_1026);
                        resultFuture.to((v_1028: Date) =>  {
                            const data_1027 = new DataInOut();
                            data_1027.writeLong(v_1028.getTime());
                            ctx.sendResultToRemote(reqId_1024, data_1027.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 13:  {
                        const reqId_1030 = dataIn.readInt();
                        const argsNames_1031: string[] = [];
                        const argsValues_1032: any[] = [];
                        ctx.invokeLocalMethodBefore("onlineTime", argsNames_1031, argsValues_1032);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.onlineTime();
                        ctx.invokeLocalMethodAfter("onlineTime", resultFuture, argsNames_1031, argsValues_1032);
                        resultFuture.to((v_1034: Date) =>  {
                            const data_1033 = new DataInOut();
                            data_1033.writeLong(v_1034.getTime());
                            ctx.sendResultToRemote(reqId_1030, data_1033.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 14:  {
                        const reqId_1036 = dataIn.readInt();
                        let groupId_1037: number;
                        groupId_1037 = dataIn.readLong();
                        const argsNames_1039: string[] = ["groupId"];
                        const argsValues_1040: any[] = [groupId_1037];
                        ctx.invokeLocalMethodBefore("addAccessGroup", argsNames_1039, argsValues_1040);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.addAccessGroup(groupId_1037);
                        ctx.invokeLocalMethodAfter("addAccessGroup", resultFuture, argsNames_1039, argsValues_1040);
                        resultFuture.to((v_1042: boolean) =>  {
                            const data_1041 = new DataInOut();
                            data_1041.writeBoolean(v_1042);
                            ctx.sendResultToRemote(reqId_1036, data_1041.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 15:  {
                        const reqId_1044 = dataIn.readInt();
                        let groupId_1045: number;
                        groupId_1045 = dataIn.readLong();
                        const argsNames_1047: string[] = ["groupId"];
                        const argsValues_1048: any[] = [groupId_1045];
                        ctx.invokeLocalMethodBefore("removeAccessGroup", argsNames_1047, argsValues_1048);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.removeAccessGroup(groupId_1045);
                        ctx.invokeLocalMethodAfter("removeAccessGroup", resultFuture, argsNames_1047, argsValues_1048);
                        resultFuture.to((v_1050: boolean) =>  {
                            const data_1049 = new DataInOut();
                            data_1049.writeBoolean(v_1050);
                            ctx.sendResultToRemote(reqId_1044, data_1049.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerApiByUid>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerApiByUid): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1052: FastFutureContext): ServerApiByUidRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1052.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1052, getBalance: (): ARFuture<number> =>  {
                    const dataOut_1054 = new DataInOut();
                    dataOut_1054.writeByte(3);
                    const argsNames_1056: string[] = [];
                    const argsValues_1057: any[] = [];
                    const result_1055 = ARFuture.of<number>();
                    sCtx_1052.invokeRemoteMethodAfter("getBalance", result_1055, argsNames_1056, argsValues_1057);
                    const reqId_1053 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1055 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1055.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1054.writeInt(reqId_1053);
                    sCtx_1052.sendToRemote(dataOut_1054.toArray());
                    return result_1055;
                    
                }
                , setParent: (uid: UUID): AFuture =>  {
                    const dataOut_1059 = new DataInOut();
                    dataOut_1059.writeByte(4);
                    const argsNames_1061: string[] = ["uid"];
                    const argsValues_1062: any[] = [uid];
                    sCtx_1052.invokeRemoteMethodAfter("setParent", null, argsNames_1061, argsValues_1062);
                    FastMeta.META_UUID.serialize(sCtx_1052, uid, dataOut_1059);
                    sCtx_1052.sendToRemote(dataOut_1059.toArray());
                    return AFuture.of();
                    
                }
                , block: (): AFuture =>  {
                    const dataOut_1065 = new DataInOut();
                    dataOut_1065.writeByte(5);
                    const argsNames_1067: string[] = [];
                    const argsValues_1068: any[] = [];
                    sCtx_1052.invokeRemoteMethodAfter("block", null, argsNames_1067, argsValues_1068);
                    sCtx_1052.sendToRemote(dataOut_1065.toArray());
                    return AFuture.of();
                    
                }
                , getPosition: (): ARFuture<Cloud> =>  {
                    const dataOut_1070 = new DataInOut();
                    dataOut_1070.writeByte(6);
                    const argsNames_1072: string[] = [];
                    const argsValues_1073: any[] = [];
                    const result_1071 = ARFuture.of<Cloud>();
                    sCtx_1052.invokeRemoteMethodAfter("getPosition", result_1071, argsNames_1072, argsValues_1073);
                    const reqId_1069 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1071 as ARFuture<Cloud>).tryDone(Cloud.META.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1071.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1070.writeInt(reqId_1069);
                    sCtx_1052.sendToRemote(dataOut_1070.toArray());
                    return result_1071;
                    
                }
                , getParent: (): ARFuture<UUID> =>  {
                    const dataOut_1075 = new DataInOut();
                    dataOut_1075.writeByte(7);
                    const argsNames_1077: string[] = [];
                    const argsValues_1078: any[] = [];
                    const result_1076 = ARFuture.of<UUID>();
                    sCtx_1052.invokeRemoteMethodAfter("getParent", result_1076, argsNames_1077, argsValues_1078);
                    const reqId_1074 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1076 as ARFuture<UUID>).tryDone(FastMeta.META_UUID.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1076.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1075.writeInt(reqId_1074);
                    sCtx_1052.sendToRemote(dataOut_1075.toArray());
                    return result_1076;
                    
                }
                , getBeneficiary: (): ARFuture<UUID> =>  {
                    const dataOut_1080 = new DataInOut();
                    dataOut_1080.writeByte(8);
                    const argsNames_1082: string[] = [];
                    const argsValues_1083: any[] = [];
                    const result_1081 = ARFuture.of<UUID>();
                    sCtx_1052.invokeRemoteMethodAfter("getBeneficiary", result_1081, argsNames_1082, argsValues_1083);
                    const reqId_1079 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1081 as ARFuture<UUID>).tryDone(FastMeta.META_UUID.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1081.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1080.writeInt(reqId_1079);
                    sCtx_1052.sendToRemote(dataOut_1080.toArray());
                    return result_1081;
                    
                }
                , setBeneficiary: (uid: UUID): AFuture =>  {
                    const dataOut_1085 = new DataInOut();
                    dataOut_1085.writeByte(9);
                    const argsNames_1087: string[] = ["uid"];
                    const argsValues_1088: any[] = [uid];
                    sCtx_1052.invokeRemoteMethodAfter("setBeneficiary", null, argsNames_1087, argsValues_1088);
                    FastMeta.META_UUID.serialize(sCtx_1052, uid, dataOut_1085);
                    sCtx_1052.sendToRemote(dataOut_1085.toArray());
                    return AFuture.of();
                    
                }
                , getBlockTime: (): ARFuture<Date> =>  {
                    const dataOut_1091 = new DataInOut();
                    dataOut_1091.writeByte(10);
                    const argsNames_1093: string[] = [];
                    const argsValues_1094: any[] = [];
                    const result_1092 = ARFuture.of<Date>();
                    sCtx_1052.invokeRemoteMethodAfter("getBlockTime", result_1092, argsNames_1093, argsValues_1094);
                    const reqId_1090 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1092 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1092.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1091.writeInt(reqId_1090);
                    sCtx_1052.sendToRemote(dataOut_1091.toArray());
                    return result_1092;
                    
                }
                , unblock: (): AFuture =>  {
                    const dataOut_1096 = new DataInOut();
                    dataOut_1096.writeByte(11);
                    const argsNames_1098: string[] = [];
                    const argsValues_1099: any[] = [];
                    sCtx_1052.invokeRemoteMethodAfter("unblock", null, argsNames_1098, argsValues_1099);
                    sCtx_1052.sendToRemote(dataOut_1096.toArray());
                    return AFuture.of();
                    
                }
                , createTime: (): ARFuture<Date> =>  {
                    const dataOut_1101 = new DataInOut();
                    dataOut_1101.writeByte(12);
                    const argsNames_1103: string[] = [];
                    const argsValues_1104: any[] = [];
                    const result_1102 = ARFuture.of<Date>();
                    sCtx_1052.invokeRemoteMethodAfter("createTime", result_1102, argsNames_1103, argsValues_1104);
                    const reqId_1100 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1102 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1102.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1101.writeInt(reqId_1100);
                    sCtx_1052.sendToRemote(dataOut_1101.toArray());
                    return result_1102;
                    
                }
                , onlineTime: (): ARFuture<Date> =>  {
                    const dataOut_1106 = new DataInOut();
                    dataOut_1106.writeByte(13);
                    const argsNames_1108: string[] = [];
                    const argsValues_1109: any[] = [];
                    const result_1107 = ARFuture.of<Date>();
                    sCtx_1052.invokeRemoteMethodAfter("onlineTime", result_1107, argsNames_1108, argsValues_1109);
                    const reqId_1105 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1107 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1107.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1106.writeInt(reqId_1105);
                    sCtx_1052.sendToRemote(dataOut_1106.toArray());
                    return result_1107;
                    
                }
                , addAccessGroup: (groupId: number): ARFuture<boolean> =>  {
                    const dataOut_1111 = new DataInOut();
                    dataOut_1111.writeByte(14);
                    const argsNames_1113: string[] = ["groupId"];
                    const argsValues_1114: any[] = [groupId];
                    const result_1112 = ARFuture.of<boolean>();
                    sCtx_1052.invokeRemoteMethodAfter("addAccessGroup", result_1112, argsNames_1113, argsValues_1114);
                    const reqId_1110 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1112 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1112.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1111.writeInt(reqId_1110);
                    dataOut_1111.writeLong(groupId);
                    sCtx_1052.sendToRemote(dataOut_1111.toArray());
                    return result_1112;
                    
                }
                , removeAccessGroup: (groupId: number): ARFuture<boolean> =>  {
                    const dataOut_1117 = new DataInOut();
                    dataOut_1117.writeByte(15);
                    const argsNames_1119: string[] = ["groupId"];
                    const argsValues_1120: any[] = [groupId];
                    const result_1118 = ARFuture.of<boolean>();
                    sCtx_1052.invokeRemoteMethodAfter("removeAccessGroup", result_1118, argsNames_1119, argsValues_1120);
                    const reqId_1116 = sCtx_1052.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1118 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1052, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1118.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1117.writeInt(reqId_1116);
                    dataOut_1117.writeLong(groupId);
                    sCtx_1052.sendToRemote(dataOut_1117.toArray());
                    return result_1118;
                    
                }
                , 
            };
            return remoteApiImpl as ServerApiByUidRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerApiByUidRemote ---
export interface ServerApiByUidRemote extends ServerApiByUid, RemoteApi  {
    
}
// --- Generated API Local Class: ServerApiByUidLocal ---
export abstract class ServerApiByUidLocal<RT extends ServerApiByUidRemote> implements ServerApiByUid  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getBalance(): ARFuture<number>;
    public abstract setParent(uid: UUID): AFuture;
    public abstract block(): AFuture;
    public abstract getPosition(): ARFuture<Cloud>;
    public abstract getParent(): ARFuture<UUID>;
    public abstract getBeneficiary(): ARFuture<UUID>;
    public abstract setBeneficiary(uid: UUID): AFuture;
    public abstract getBlockTime(): ARFuture<Date>;
    public abstract unblock(): AFuture;
    public abstract createTime(): ARFuture<Date>;
    public abstract onlineTime(): ARFuture<Date>;
    public abstract addAccessGroup(groupId: number): ARFuture<boolean>;
    public abstract removeAccessGroup(groupId: number): ARFuture<boolean>;
    
}
// --- Generated API Interface: ClientApiRegSafe ---
export interface ClientApiRegSafe  {
    
}
export namespace ClientApiRegSafe  {
    export const META: FastMetaApi<ClientApiRegSafe, ClientApiRegSafeRemote> = new class implements FastMetaApi<ClientApiRegSafe, ClientApiRegSafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: ClientApiRegSafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiRegSafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiRegSafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1122: FastFutureContext): ClientApiRegSafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1122.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1122, 
            };
            return remoteApiImpl as ClientApiRegSafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiRegSafeRemote ---
export interface ClientApiRegSafeRemote extends ClientApiRegSafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiRegSafeLocal ---
export abstract class ClientApiRegSafeLocal<RT extends ClientApiRegSafeRemote> implements ClientApiRegSafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: GlobalRegClientApi ---
export interface GlobalRegClientApi  {
    
}
export namespace GlobalRegClientApi  {
    export const META: FastMetaApi<GlobalRegClientApi, GlobalRegClientApiRemote> = new class implements FastMetaApi<GlobalRegClientApi, GlobalRegClientApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: GlobalRegClientApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<GlobalRegClientApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: GlobalRegClientApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1123: FastFutureContext): GlobalRegClientApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1123.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1123, 
            };
            return remoteApiImpl as GlobalRegClientApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: GlobalRegClientApiRemote ---
export interface GlobalRegClientApiRemote extends GlobalRegClientApi, RemoteApi  {
    
}
// --- Generated API Local Class: GlobalRegClientApiLocal ---
export abstract class GlobalRegClientApiLocal<RT extends GlobalRegClientApiRemote> implements GlobalRegClientApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: ClientApiRegUnsafe ---
export interface ClientApiRegUnsafe  {
    enter(stream: ClientApiRegSafeStream): AFuture;
    enterGlobal(stream: GlobalRegClientApiStream): AFuture;
    
}
export namespace ClientApiRegUnsafe  {
    export const META: FastMetaApi<ClientApiRegUnsafe, ClientApiRegUnsafeRemote> = new class implements FastMetaApi<ClientApiRegUnsafe, ClientApiRegUnsafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiRegUnsafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let stream_1125: ClientApiRegSafeStream;
                        stream_1125 = ClientApiRegSafeStream.META.deserialize(ctx, dataIn);
                        const argsNames_1127: string[] = ["stream"];
                        const argsValues_1128: any[] = [stream_1125];
                        ctx.invokeLocalMethodBefore("enter", argsNames_1127, argsValues_1128);
                        localApi.enter(stream_1125);
                        ctx.invokeLocalMethodAfter("enter", null, argsNames_1127, argsValues_1128);
                        break;
                        
                    }
                    case 4:  {
                        let stream_1130: GlobalRegClientApiStream;
                        stream_1130 = GlobalRegClientApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_1132: string[] = ["stream"];
                        const argsValues_1133: any[] = [stream_1130];
                        ctx.invokeLocalMethodBefore("enterGlobal", argsNames_1132, argsValues_1133);
                        localApi.enterGlobal(stream_1130);
                        ctx.invokeLocalMethodAfter("enterGlobal", null, argsNames_1132, argsValues_1133);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiRegUnsafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiRegUnsafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1134: FastFutureContext): ClientApiRegUnsafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1134.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1134, enter: (stream: ClientApiRegSafeStream): AFuture =>  {
                    const dataOut_1136 = new DataInOut();
                    dataOut_1136.writeByte(3);
                    const argsNames_1138: string[] = ["stream"];
                    const argsValues_1139: any[] = [stream];
                    sCtx_1134.invokeRemoteMethodAfter("enter", null, argsNames_1138, argsValues_1139);
                    ClientApiRegSafeStream.META.serialize(sCtx_1134, stream, dataOut_1136);
                    sCtx_1134.sendToRemote(dataOut_1136.toArray());
                    return AFuture.of();
                    
                }
                , enterGlobal: (stream: GlobalRegClientApiStream): AFuture =>  {
                    const dataOut_1142 = new DataInOut();
                    dataOut_1142.writeByte(4);
                    const argsNames_1144: string[] = ["stream"];
                    const argsValues_1145: any[] = [stream];
                    sCtx_1134.invokeRemoteMethodAfter("enterGlobal", null, argsNames_1144, argsValues_1145);
                    GlobalRegClientApiStream.META.serialize(sCtx_1134, stream, dataOut_1142);
                    sCtx_1134.sendToRemote(dataOut_1142.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiRegUnsafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiRegUnsafeRemote ---
export interface ClientApiRegUnsafeRemote extends ClientApiRegUnsafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiRegUnsafeLocal ---
export abstract class ClientApiRegUnsafeLocal<RT extends ClientApiRegUnsafeRemote> implements ClientApiRegUnsafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract enter(stream: ClientApiRegSafeStream): AFuture;
    public abstract enterGlobal(stream: GlobalRegClientApiStream): AFuture;
    
}
// --- Generated API Interface: GlobalRegServerApi ---
export interface GlobalRegServerApi  {
    setMasterKey(key: Key): AFuture;
    finish(): ARFuture<FinishResultGlobalRegServerApi>;
    
}
export namespace GlobalRegServerApi  {
    export const META: FastMetaApi<GlobalRegServerApi, GlobalRegServerApiRemote> = new class implements FastMetaApi<GlobalRegServerApi, GlobalRegServerApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: GlobalRegServerApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let _key_1148: Key;
                        _key_1148 = Key.META.deserialize(ctx, dataIn);
                        const argsNames_1150: string[] = ["key"];
                        const argsValues_1151: any[] = [_key_1148];
                        ctx.invokeLocalMethodBefore("setMasterKey", argsNames_1150, argsValues_1151);
                        localApi.setMasterKey(_key_1148);
                        ctx.invokeLocalMethodAfter("setMasterKey", null, argsNames_1150, argsValues_1151);
                        break;
                        
                    }
                    case 4:  {
                        const reqId_1152 = dataIn.readInt();
                        const argsNames_1153: string[] = [];
                        const argsValues_1154: any[] = [];
                        ctx.invokeLocalMethodBefore("finish", argsNames_1153, argsValues_1154);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.finish();
                        ctx.invokeLocalMethodAfter("finish", resultFuture, argsNames_1153, argsValues_1154);
                        resultFuture.to((v_1156: FinishResultGlobalRegServerApi) =>  {
                            const data_1155 = new DataInOut();
                            FinishResultGlobalRegServerApi.META.serialize(ctx, v_1156, data_1155);
                            ctx.sendResultToRemote(reqId_1152, data_1155.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<GlobalRegServerApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: GlobalRegServerApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1158: FastFutureContext): GlobalRegServerApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1158.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1158, setMasterKey: (key: Key): AFuture =>  {
                    const dataOut_1160 = new DataInOut();
                    dataOut_1160.writeByte(3);
                    const argsNames_1162: string[] = ["key"];
                    const argsValues_1163: any[] = [key];
                    sCtx_1158.invokeRemoteMethodAfter("setMasterKey", null, argsNames_1162, argsValues_1163);
                    Key.META.serialize(sCtx_1158, key, dataOut_1160);
                    sCtx_1158.sendToRemote(dataOut_1160.toArray());
                    return AFuture.of();
                    
                }
                , finish: (): ARFuture<FinishResultGlobalRegServerApi> =>  {
                    const dataOut_1166 = new DataInOut();
                    dataOut_1166.writeByte(4);
                    const argsNames_1168: string[] = [];
                    const argsValues_1169: any[] = [];
                    const result_1167 = ARFuture.of<FinishResultGlobalRegServerApi>();
                    sCtx_1158.invokeRemoteMethodAfter("finish", result_1167, argsNames_1168, argsValues_1169);
                    const reqId_1165 = sCtx_1158.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1167 as ARFuture<FinishResultGlobalRegServerApi>).tryDone(FinishResultGlobalRegServerApi.META.deserialize(sCtx_1158, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1167.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1166.writeInt(reqId_1165);
                    sCtx_1158.sendToRemote(dataOut_1166.toArray());
                    return result_1167;
                    
                }
                , 
            };
            return remoteApiImpl as GlobalRegServerApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: GlobalRegServerApiRemote ---
export interface GlobalRegServerApiRemote extends GlobalRegServerApi, RemoteApi  {
    
}
// --- Generated API Local Class: GlobalRegServerApiLocal ---
export abstract class GlobalRegServerApiLocal<RT extends GlobalRegServerApiRemote> implements GlobalRegServerApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract setMasterKey(key: Key): AFuture;
    public abstract finish(): ARFuture<FinishResultGlobalRegServerApi>;
    
}
// --- Generated API Interface: ServerRegistrationApi ---
export interface ServerRegistrationApi  {
    registration(salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture;
    requestWorkProofData(parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO>;
    resolveServers(serverIds: Cloud): ARFuture<ServerDescriptor[]>;
    
}
export namespace ServerRegistrationApi  {
    export const META: FastMetaApi<ServerRegistrationApi, ServerRegistrationApiRemote> = new class implements FastMetaApi<ServerRegistrationApi, ServerRegistrationApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ServerRegistrationApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let salt_1171: string;
                        let suffix_1172: string;
                        let passwords_1173: number[];
                        let parent_1174: UUID;
                        let returnKey_1175: Key;
                        let globalApi_1176: GlobalApiRegistrationServerRegistrationApi;
                        let stringBytes_1178: Uint8Array;
                        const len_1180 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        const bytes_1181 = dataIn.readBytes(len_1180);
                        stringBytes_1178 = bytes_1181;
                        salt_1171 = new TextDecoder('utf-8').decode(stringBytes_1178);
                        let stringBytes_1183: Uint8Array;
                        const len_1185 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        const bytes_1186 = dataIn.readBytes(len_1185);
                        stringBytes_1183 = bytes_1186;
                        suffix_1172 = new TextDecoder('utf-8').decode(stringBytes_1183);
                        const len_1188 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        passwords_1173 = new Array<number>(len_1188);
                        for (let idx_1187 = 0;
                        idx_1187 < len_1188;
                        idx_1187++)  {
                            passwords_1173[idx_1187] = dataIn.readInt();
                            
                        }
                        parent_1174 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        returnKey_1175 = Key.META.deserialize(ctx, dataIn);
                        globalApi_1176 = GlobalApiRegistrationServerRegistrationApi.META.deserialize(ctx, dataIn);
                        const argsNames_1193: string[] = ["salt", "suffix", "passwords", "parent", "returnKey", "globalApi"];
                        const argsValues_1194: any[] = [salt_1171, suffix_1172, passwords_1173, parent_1174, returnKey_1175, globalApi_1176];
                        ctx.invokeLocalMethodBefore("registration", argsNames_1193, argsValues_1194);
                        localApi.registration(salt_1171, suffix_1172, passwords_1173, parent_1174, returnKey_1175, globalApi_1176);
                        ctx.invokeLocalMethodAfter("registration", null, argsNames_1193, argsValues_1194);
                        break;
                        
                    }
                    case 4:  {
                        const reqId_1195 = dataIn.readInt();
                        let parent_1196: UUID;
                        let powMethods_1197: PowMethod;
                        let returnKey_1198: Key;
                        parent_1196 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        powMethods_1197 = PowMethod.META.deserialize(ctx, dataIn);
                        returnKey_1198 = Key.META.deserialize(ctx, dataIn);
                        const argsNames_1202: string[] = ["parent", "powMethods", "returnKey"];
                        const argsValues_1203: any[] = [parent_1196, powMethods_1197, returnKey_1198];
                        ctx.invokeLocalMethodBefore("requestWorkProofData", argsNames_1202, argsValues_1203);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.requestWorkProofData(parent_1196, powMethods_1197, returnKey_1198);
                        ctx.invokeLocalMethodAfter("requestWorkProofData", resultFuture, argsNames_1202, argsValues_1203);
                        resultFuture.to((v_1205: WorkProofDTO) =>  {
                            const data_1204 = new DataInOut();
                            WorkProofDTO.META.serialize(ctx, v_1205, data_1204);
                            ctx.sendResultToRemote(reqId_1195, data_1204.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 5:  {
                        const reqId_1207 = dataIn.readInt();
                        let serverIds_1208: Cloud;
                        serverIds_1208 = Cloud.META.deserialize(ctx, dataIn);
                        const argsNames_1210: string[] = ["serverIds"];
                        const argsValues_1211: any[] = [serverIds_1208];
                        ctx.invokeLocalMethodBefore("resolveServers", argsNames_1210, argsValues_1211);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.resolveServers(serverIds_1208);
                        ctx.invokeLocalMethodAfter("resolveServers", resultFuture, argsNames_1210, argsValues_1211);
                        resultFuture.to((v_1213: ServerDescriptor[]) =>  {
                            const data_1212 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_1212, v_1213.length);
                            for (const el_1214 of v_1213)  {
                                ServerDescriptor.META.serialize(ctx, el_1214, data_1212);
                                
                            }
                            ctx.sendResultToRemote(reqId_1207, data_1212.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerRegistrationApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerRegistrationApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1216: FastFutureContext): ServerRegistrationApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1216.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1216, registration: (salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture =>  {
                    const dataOut_1218 = new DataInOut();
                    dataOut_1218.writeByte(3);
                    const argsNames_1220: string[] = ["salt", "suffix", "passwords", "parent", "returnKey", "globalApi"];
                    const argsValues_1221: any[] = [salt, suffix, passwords, parent, returnKey, globalApi];
                    sCtx_1216.invokeRemoteMethodAfter("registration", null, argsNames_1220, argsValues_1221);
                    const stringBytes_1223 = new TextEncoder().encode(salt);
                    SerializerPackNumber.INSTANCE.put(dataOut_1218, stringBytes_1223.length);
                    dataOut_1218.write(stringBytes_1223);
                    const stringBytes_1226 = new TextEncoder().encode(suffix);
                    SerializerPackNumber.INSTANCE.put(dataOut_1218, stringBytes_1226.length);
                    dataOut_1218.write(stringBytes_1226);
                    SerializerPackNumber.INSTANCE.put(dataOut_1218, passwords.length);
                    for (const el_1228 of passwords)  {
                        dataOut_1218.writeInt(el_1228);
                        
                    }
                    FastMeta.META_UUID.serialize(sCtx_1216, parent, dataOut_1218);
                    Key.META.serialize(sCtx_1216, returnKey, dataOut_1218);
                    GlobalApiRegistrationServerRegistrationApi.META.serialize(sCtx_1216, globalApi, dataOut_1218);
                    sCtx_1216.sendToRemote(dataOut_1218.toArray());
                    return AFuture.of();
                    
                }
                , requestWorkProofData: (parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO> =>  {
                    const dataOut_1234 = new DataInOut();
                    dataOut_1234.writeByte(4);
                    const argsNames_1236: string[] = ["parent", "powMethods", "returnKey"];
                    const argsValues_1237: any[] = [parent, powMethods, returnKey];
                    const result_1235 = ARFuture.of<WorkProofDTO>();
                    sCtx_1216.invokeRemoteMethodAfter("requestWorkProofData", result_1235, argsNames_1236, argsValues_1237);
                    const reqId_1233 = sCtx_1216.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1235 as ARFuture<WorkProofDTO>).tryDone(WorkProofDTO.META.deserialize(sCtx_1216, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1235.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1234.writeInt(reqId_1233);
                    FastMeta.META_UUID.serialize(sCtx_1216, parent, dataOut_1234);
                    PowMethod.META.serialize(sCtx_1216, powMethods, dataOut_1234);
                    Key.META.serialize(sCtx_1216, returnKey, dataOut_1234);
                    sCtx_1216.sendToRemote(dataOut_1234.toArray());
                    return result_1235;
                    
                }
                , resolveServers: (serverIds: Cloud): ARFuture<ServerDescriptor[]> =>  {
                    const dataOut_1242 = new DataInOut();
                    dataOut_1242.writeByte(5);
                    const argsNames_1244: string[] = ["serverIds"];
                    const argsValues_1245: any[] = [serverIds];
                    const result_1243 = ARFuture.of<ServerDescriptor[]>();
                    sCtx_1216.invokeRemoteMethodAfter("resolveServers", result_1243, argsNames_1244, argsValues_1245);
                    const reqId_1241 = sCtx_1216.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1243 as ARFuture<ServerDescriptor[]>).tryDone(AllCustomMeta.META_ARRAY_ServerDescriptor.deserialize(sCtx_1216, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1243.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1242.writeInt(reqId_1241);
                    Cloud.META.serialize(sCtx_1216, serverIds, dataOut_1242);
                    sCtx_1216.sendToRemote(dataOut_1242.toArray());
                    return result_1243;
                    
                }
                , 
            };
            return remoteApiImpl as ServerRegistrationApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerRegistrationApiRemote ---
export interface ServerRegistrationApiRemote extends ServerRegistrationApi, RemoteApi  {
    
}
// --- Generated API Local Class: ServerRegistrationApiLocal ---
export abstract class ServerRegistrationApiLocal<RT extends ServerRegistrationApiRemote> implements ServerRegistrationApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract registration(salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture;
    public abstract requestWorkProofData(parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO>;
    public abstract resolveServers(serverIds: Cloud): ARFuture<ServerDescriptor[]>;
    
}
// --- Generated API Interface: RegistrationRootApi ---
export interface RegistrationRootApi  {
    getAsymmetricPublicKey(cryptoLib: CryptoLib): ARFuture<SignedKey>;
    enter(cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture;
    
}
export namespace RegistrationRootApi  {
    export const META: FastMetaApi<RegistrationRootApi, RegistrationRootApiRemote> = new class implements FastMetaApi<RegistrationRootApi, RegistrationRootApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: RegistrationRootApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_1247 = dataIn.readInt();
                        let cryptoLib_1248: CryptoLib;
                        cryptoLib_1248 = CryptoLib.META.deserialize(ctx, dataIn);
                        const argsNames_1250: string[] = ["cryptoLib"];
                        const argsValues_1251: any[] = [cryptoLib_1248];
                        ctx.invokeLocalMethodBefore("getAsymmetricPublicKey", argsNames_1250, argsValues_1251);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAsymmetricPublicKey(cryptoLib_1248);
                        ctx.invokeLocalMethodAfter("getAsymmetricPublicKey", resultFuture, argsNames_1250, argsValues_1251);
                        resultFuture.to((v_1253: SignedKey) =>  {
                            const data_1252 = new DataInOut();
                            SignedKey.META.serialize(ctx, v_1253, data_1252);
                            ctx.sendResultToRemote(reqId_1247, data_1252.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let cryptoLib_1256: CryptoLib;
                        let stream_1257: ServerRegistrationApiStream;
                        cryptoLib_1256 = CryptoLib.META.deserialize(ctx, dataIn);
                        stream_1257 = ServerRegistrationApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_1260: string[] = ["cryptoLib", "stream"];
                        const argsValues_1261: any[] = [cryptoLib_1256, stream_1257];
                        ctx.invokeLocalMethodBefore("enter", argsNames_1260, argsValues_1261);
                        localApi.enter(cryptoLib_1256, stream_1257);
                        ctx.invokeLocalMethodAfter("enter", null, argsNames_1260, argsValues_1261);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<RegistrationRootApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: RegistrationRootApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1262: FastFutureContext): RegistrationRootApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1262.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1262, getAsymmetricPublicKey: (cryptoLib: CryptoLib): ARFuture<SignedKey> =>  {
                    const dataOut_1264 = new DataInOut();
                    dataOut_1264.writeByte(3);
                    const argsNames_1266: string[] = ["cryptoLib"];
                    const argsValues_1267: any[] = [cryptoLib];
                    const result_1265 = ARFuture.of<SignedKey>();
                    sCtx_1262.invokeRemoteMethodAfter("getAsymmetricPublicKey", result_1265, argsNames_1266, argsValues_1267);
                    const reqId_1263 = sCtx_1262.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1265 as ARFuture<SignedKey>).tryDone(SignedKey.META.deserialize(sCtx_1262, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1265.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1264.writeInt(reqId_1263);
                    CryptoLib.META.serialize(sCtx_1262, cryptoLib, dataOut_1264);
                    sCtx_1262.sendToRemote(dataOut_1264.toArray());
                    return result_1265;
                    
                }
                , enter: (cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture =>  {
                    const dataOut_1270 = new DataInOut();
                    dataOut_1270.writeByte(4);
                    const argsNames_1272: string[] = ["cryptoLib", "stream"];
                    const argsValues_1273: any[] = [cryptoLib, stream];
                    sCtx_1262.invokeRemoteMethodAfter("enter", null, argsNames_1272, argsValues_1273);
                    CryptoLib.META.serialize(sCtx_1262, cryptoLib, dataOut_1270);
                    ServerRegistrationApiStream.META.serialize(sCtx_1262, stream, dataOut_1270);
                    sCtx_1262.sendToRemote(dataOut_1270.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as RegistrationRootApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: RegistrationRootApiRemote ---
export interface RegistrationRootApiRemote extends RegistrationRootApi, RemoteApi  {
    
}
// --- Generated API Local Class: RegistrationRootApiLocal ---
export abstract class RegistrationRootApiLocal<RT extends RegistrationRootApiRemote> implements RegistrationRootApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getAsymmetricPublicKey(cryptoLib: CryptoLib): ARFuture<SignedKey>;
    public abstract enter(cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture;
    
}
// ===============================================================================
// GENERATED META: AllCustomMeta (Custom FastMeta Implementations)
// ===============================================================================
export namespace AllCustomMeta  {
    export const META_ARRAY_long: FastMetaType<number[]> = new class implements FastMetaType<number[]>  {
        serialize(_sCtx: FastFutureContext, obj: number[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                FastMeta.META_LONG.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): number[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<number>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = FastMeta.META_LONG.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    export const META_ARRAY_UUID: FastMetaType<UUID[]> = new class implements FastMetaType<UUID[]>  {
        serialize(_sCtx: FastFutureContext, obj: UUID[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                FastMeta.META_UUID.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): UUID[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<UUID>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = FastMeta.META_UUID.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    export const META_ARRAY_ServerDescriptor: FastMetaType<ServerDescriptor[]> = new class implements FastMetaType<ServerDescriptor[]>  {
        serialize(_sCtx: FastFutureContext, obj: ServerDescriptor[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                ServerDescriptor.META.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): ServerDescriptor[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<ServerDescriptor>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = ServerDescriptor.META.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}