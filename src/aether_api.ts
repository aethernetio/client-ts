// ===============================================================================
// GENERATED FILE: aether_api.ts
// Generated by AetherProtocolGenerator
// ===============================================================================
import  {
    AFuture, ARFuture 
}
from './aether_future';
import  {
    DataIn, DataOut, DataInOut, DataInOutStatic 
}
from './aether_datainout';
import  {
    FastMetaType, FastFutureContext, RemoteApi, FastMeta, SerializerPackNumber, DeserializerPackNumber, FastApiContextLocal, FastMetaApi, BytesConverter, RemoteApiFuture 
}
from './aether_fastmeta';
import  {
    UUID, URI, Uint8Array, AConsumer 
}
from './aether_types';
import  {
    ToString, AString 
}
from './aether_astring';
// NOTE: TextEncoder/TextDecoder should be available globally.
// --- Forward Declarations & Imports ---
// (Not strictly necessary in a single file)
// --- Generated Structures and APIs ---
// --- Generated Enum: AetherCodec ---
export enum AetherCodec  {
    TCP = 'TCP', UDP = 'UDP', WS = 'WS', WSS = 'WSS' 
}
export namespace AetherCodec  {
    export const META: FastMetaType<AetherCodec> = new class implements FastMetaType<AetherCodec>  {
        serialize(_sCtx: FastFutureContext, obj: AetherCodec, out: DataOut): void  {
            const values = Object.keys(AetherCodec).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): AetherCodec  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(AetherCodec).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum AetherCodec`);
            return AetherCodec[keys[ordinal] as keyof typeof AetherCodec] as AetherCodec;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: CryptoLib ---
export enum CryptoLib  {
    SODIUM = 'SODIUM', HYDROGEN = 'HYDROGEN' 
}
export namespace CryptoLib  {
    export const META: FastMetaType<CryptoLib> = new class implements FastMetaType<CryptoLib>  {
        serialize(_sCtx: FastFutureContext, obj: CryptoLib, out: DataOut): void  {
            const values = Object.keys(CryptoLib).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): CryptoLib  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(CryptoLib).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum CryptoLib`);
            return CryptoLib[keys[ordinal] as keyof typeof CryptoLib] as CryptoLib;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: PowMethod ---
export enum PowMethod  {
    AE_BCRYPT_CRC32 = 'AE_BCRYPT_CRC32' 
}
export namespace PowMethod  {
    export const META: FastMetaType<PowMethod> = new class implements FastMetaType<PowMethod>  {
        serialize(_sCtx: FastFutureContext, obj: PowMethod, out: DataOut): void  {
            const values = Object.keys(PowMethod).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): PowMethod  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(PowMethod).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum PowMethod`);
            return PowMethod[keys[ordinal] as keyof typeof PowMethod] as PowMethod;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Enum: Status ---
export enum Status  {
    PENDING = 'PENDING', COMPLETED = 'COMPLETED', FAILED = 'FAILED' 
}
export namespace Status  {
    export const META: FastMetaType<Status> = new class implements FastMetaType<Status>  {
        serialize(_sCtx: FastFutureContext, obj: Status, out: DataOut): void  {
            const values = Object.keys(Status).filter(k => isNaN(parseInt(k)));
            out.writeByte(values.indexOf(obj as string));
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): Status  {
            const ordinal = in_.readUByte();
            const keys = Object.keys(Status).filter(k => isNaN(parseInt(k)));
            if (ordinal < 0 || ordinal >= keys.length) throw new Error(`Invalid ordinal $ {
                ordinal
            }
            for enum Status`);
            return Status[keys[ordinal] as keyof typeof Status] as Status;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}
// --- Generated Structure: IPAddress ---
export abstract class IPAddress implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<IPAddress> = new class implements FastMetaType<IPAddress>  {
        serialize(sCtx_0: FastFutureContext, obj_1: IPAddress, _out_2: DataOut): void  {
            const typeId = typeof (obj_1 as any).getAetherTypeId === 'function' ? obj_1.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddress' with invalid type id $ {
                typeId
            }
            `);
            _out_2.writeByte(typeId);
            switch(typeId)  {
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_0, obj_1 as any as IPAddressV4, _out_2);
                break;
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_0, obj_1 as any as IPAddressV6, _out_2);
                break;
                default: throw new Error(`Cannot serialize 'IPAddress' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_0: FastFutureContext, in__3: DataIn): IPAddress  {
            const typeId = in__3.readUByte();
            switch(typeId)  {
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_0, in__3) as any as IPAddress;
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_0, in__3) as any as IPAddress;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddress'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddress(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Key ---
export abstract class Key implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Key> = new class implements FastMetaType<Key>  {
        serialize(sCtx_4: FastFutureContext, obj_5: Key, _out_6: DataOut): void  {
            const typeId = typeof (obj_5 as any).getAetherTypeId === 'function' ? obj_5.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Key' with invalid type id $ {
                typeId
            }
            `);
            _out_6.writeByte(typeId);
            switch(typeId)  {
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumChacha20Poly1305, _out_6);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSecretBox, _out_6);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenCurvePublic, _out_6);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumCurvePublic, _out_6);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenCurvePrivate, _out_6);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumCurvePrivate, _out_6);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumSignPublic, _out_6);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSignPublic, _out_6);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as SodiumSignPrivate, _out_6);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_4, obj_5 as any as HydrogenSignPrivate, _out_6);
                break;
                default: throw new Error(`Cannot serialize 'Key' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_4: FastFutureContext, in__7: DataIn): Key  {
            const typeId = in__7.readUByte();
            switch(typeId)  {
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_4, in__7) as any as Key;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Key'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Key(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetric ---
export abstract class KeyAsymmetric extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetric> = new class implements FastMetaType<KeyAsymmetric>  {
        serialize(sCtx_8: FastFutureContext, obj_10: KeyAsymmetric, _out_11: DataOut): void  {
            const typeId = typeof (obj_10 as any).getAetherTypeId === 'function' ? obj_10.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetric' with invalid type id $ {
                typeId
            }
            `);
            _out_11.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetric' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_9: FastFutureContext, in__12: DataIn): KeyAsymmetric  {
            const typeId = in__12.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetric'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetric(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetricPrivate ---
export abstract class KeyAsymmetricPrivate extends KeyAsymmetric implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetricPrivate> = new class implements FastMetaType<KeyAsymmetricPrivate>  {
        serialize(sCtx_13: FastFutureContext, obj_15: KeyAsymmetricPrivate, _out_16: DataOut): void  {
            const typeId = typeof (obj_15 as any).getAetherTypeId === 'function' ? obj_15.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_16.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_14: FastFutureContext, in__17: DataIn): KeyAsymmetricPrivate  {
            const typeId = in__17.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetricPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetricPrivate(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeyAsymmetricPublic ---
export abstract class KeyAsymmetricPublic extends KeyAsymmetric implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeyAsymmetricPublic> = new class implements FastMetaType<KeyAsymmetricPublic>  {
        serialize(sCtx_18: FastFutureContext, obj_20: KeyAsymmetricPublic, _out_21: DataOut): void  {
            const typeId = typeof (obj_20 as any).getAetherTypeId === 'function' ? obj_20.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_21.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_19: FastFutureContext, in__22: DataIn): KeyAsymmetricPublic  {
            const typeId = in__22.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeyAsymmetricPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeyAsymmetricPublic(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySign ---
export abstract class KeySign extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySign> = new class implements FastMetaType<KeySign>  {
        serialize(sCtx_23: FastFutureContext, obj_25: KeySign, _out_26: DataOut): void  {
            const typeId = typeof (obj_25 as any).getAetherTypeId === 'function' ? obj_25.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySign' with invalid type id $ {
                typeId
            }
            `);
            _out_26.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_24: FastFutureContext, in__27: DataIn): KeySign  {
            const typeId = in__27.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySign(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySignPrivate ---
export abstract class KeySignPrivate extends KeySign implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySignPrivate> = new class implements FastMetaType<KeySignPrivate>  {
        serialize(sCtx_28: FastFutureContext, obj_30: KeySignPrivate, _out_31: DataOut): void  {
            const typeId = typeof (obj_30 as any).getAetherTypeId === 'function' ? obj_30.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_31.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_29: FastFutureContext, in__32: DataIn): KeySignPrivate  {
            const typeId = in__32.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySignPrivate(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySignPublic ---
export abstract class KeySignPublic extends KeySign implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySignPublic> = new class implements FastMetaType<KeySignPublic>  {
        serialize(sCtx_33: FastFutureContext, obj_35: KeySignPublic, _out_36: DataOut): void  {
            const typeId = typeof (obj_35 as any).getAetherTypeId === 'function' ? obj_35.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_36.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_34: FastFutureContext, in__37: DataIn): KeySignPublic  {
            const typeId = in__37.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySignPublic(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: KeySymmetric ---
export abstract class KeySymmetric extends Key implements ToString  {
    public override getAetherTypeId(): number  {
        return -1;
        // Abstract type without ID
        
    }
    public static readonly META: FastMetaType<KeySymmetric> = new class implements FastMetaType<KeySymmetric>  {
        serialize(sCtx_38: FastFutureContext, obj_40: KeySymmetric, _out_41: DataOut): void  {
            const typeId = typeof (obj_40 as any).getAetherTypeId === 'function' ? obj_40.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'KeySymmetric' with invalid type id $ {
                typeId
            }
            `);
            _out_41.writeByte(typeId);
            switch(typeId)  {
                default: throw new Error(`Cannot serialize 'KeySymmetric' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_39: FastFutureContext, in__42: DataIn): KeySymmetric  {
            const typeId = in__42.readUByte();
            switch(typeId)  {
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'KeySymmetric'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        super();
        
    }
    public toString(result: AString): AString  {
        result.add('KeySymmetric(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeys ---
export abstract class PairKeys implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<PairKeys> = new class implements FastMetaType<PairKeys>  {
        serialize(sCtx_43: FastFutureContext, obj_44: PairKeys, _out_45: DataOut): void  {
            const typeId = typeof (obj_44 as any).getAetherTypeId === 'function' ? obj_44.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeys' with invalid type id $ {
                typeId
            }
            `);
            _out_45.writeByte(typeId);
            switch(typeId)  {
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysSign, _out_45);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysAsym, _out_45);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_43, obj_44 as any as PairKeysAsymSigned, _out_45);
                break;
                default: throw new Error(`Cannot serialize 'PairKeys' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_43: FastFutureContext, in__46: DataIn): PairKeys  {
            const typeId = in__46.readUByte();
            switch(typeId)  {
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_43, in__46) as any as PairKeys;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeys'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeys(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Sign ---
export abstract class Sign implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Sign> = new class implements FastMetaType<Sign>  {
        serialize(sCtx_47: FastFutureContext, obj_48: Sign, _out_49: DataOut): void  {
            const typeId = typeof (obj_48 as any).getAetherTypeId === 'function' ? obj_48.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Sign' with invalid type id $ {
                typeId
            }
            `);
            _out_49.writeByte(typeId);
            switch(typeId)  {
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_47, obj_48 as any as SignAE_ED25519, _out_49);
                break;
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_47, obj_48 as any as SignHYDROGEN, _out_49);
                break;
                default: throw new Error(`Cannot serialize 'Sign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_47: FastFutureContext, in__50: DataIn): Sign  {
            const typeId = in__50.readUByte();
            switch(typeId)  {
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_47, in__50) as any as Sign;
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_47, in__50) as any as Sign;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Sign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Sign(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Telemetry ---
export abstract class Telemetry implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<Telemetry> = new class implements FastMetaType<Telemetry>  {
        serialize(sCtx_51: FastFutureContext, obj_52: Telemetry, _out_53: DataOut): void  {
            const typeId = typeof (obj_52 as any).getAetherTypeId === 'function' ? obj_52.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'Telemetry' with invalid type id $ {
                typeId
            }
            `);
            _out_53.writeByte(typeId);
            switch(typeId)  {
                case 1: (TelemetryCPP as any).META_BODY.serialize(sCtx_51, obj_52 as any as TelemetryCPP, _out_53);
                break;
                default: throw new Error(`Cannot serialize 'Telemetry' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_51: FastFutureContext, in__54: DataIn): Telemetry  {
            const typeId = in__54.readUByte();
            switch(typeId)  {
                case 1: return (TelemetryCPP as any).META_BODY.deserialize(sCtx_51, in__54) as any as Telemetry;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'Telemetry'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('Telemetry(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofConfig ---
export abstract class WorkProofConfig implements ToString  {
    public abstract getAetherTypeId(): number;
    public static readonly META: FastMetaType<WorkProofConfig> = new class implements FastMetaType<WorkProofConfig>  {
        serialize(sCtx_55: FastFutureContext, obj_56: WorkProofConfig, _out_57: DataOut): void  {
            const typeId = typeof (obj_56 as any).getAetherTypeId === 'function' ? obj_56.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'WorkProofConfig' with invalid type id $ {
                typeId
            }
            `);
            _out_57.writeByte(typeId);
            switch(typeId)  {
                case 1: (WorkProofBCrypt as any).META_BODY.serialize(sCtx_55, obj_56 as any as WorkProofBCrypt, _out_57);
                break;
                default: throw new Error(`Cannot serialize 'WorkProofConfig' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_55: FastFutureContext, in__58: DataIn): WorkProofConfig  {
            const typeId = in__58.readUByte();
            switch(typeId)  {
                case 1: return (WorkProofBCrypt as any).META_BODY.deserialize(sCtx_55, in__58) as any as WorkProofConfig;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'WorkProofConfig'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor()  {
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofConfig(');
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: AccessCheckPair ---
export class AccessCheckPair implements ToString  {
    public readonly sourceUid: UUID;
    public readonly targetUid: UUID;
    public static readonly META_BODY: FastMetaType<AccessCheckPair> = new class implements FastMetaType<AccessCheckPair>  {
        serialize(sCtx_59: FastFutureContext, obj_60: AccessCheckPair, _out_61: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_59, obj_60.sourceUid, _out_61);
            FastMeta.META_UUID.serialize(sCtx_59, obj_60.targetUid, _out_61);
            
        }
        deserialize(sCtx_59: FastFutureContext, in__62: DataIn): AccessCheckPair  {
            let sourceUid_65: UUID;
            let targetUid_66: UUID;
            sourceUid_65 = FastMeta.META_UUID.deserialize(sCtx_59, in__62);
            targetUid_66 = FastMeta.META_UUID.deserialize(sCtx_59, in__62);
            return new AccessCheckPair(sourceUid_65, targetUid_66);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<AccessCheckPair> = AccessCheckPair.META_BODY;
    constructor(sourceUid: UUID, targetUid: UUID)  {
        this.sourceUid = sourceUid;
        this.targetUid = targetUid;
        
    }
    public getSourceUid(): UUID  {
        return this.sourceUid;
        
    }
    public getTargetUid(): UUID  {
        return this.targetUid;
        
    }
    public toString(result: AString): AString  {
        result.add('AccessCheckPair(');
        result.add('sourceUid:').add(this.sourceUid);
        result.add(', ');
        result.add('targetUid:').add(this.targetUid);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: AccessCheckResult ---
export class AccessCheckResult implements ToString  {
    public readonly sourceUid: UUID;
    public readonly targetUid: UUID;
    public readonly hasAccess: boolean;
    public static readonly META_BODY: FastMetaType<AccessCheckResult> = new class implements FastMetaType<AccessCheckResult>  {
        serialize(sCtx_69: FastFutureContext, obj_70: AccessCheckResult, _out_71: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_69, obj_70.sourceUid, _out_71);
            FastMeta.META_UUID.serialize(sCtx_69, obj_70.targetUid, _out_71);
            _out_71.writeBoolean(obj_70.hasAccess);
            
        }
        deserialize(sCtx_69: FastFutureContext, in__72: DataIn): AccessCheckResult  {
            let sourceUid_76: UUID;
            let targetUid_77: UUID;
            let hasAccess_78: boolean;
            sourceUid_76 = FastMeta.META_UUID.deserialize(sCtx_69, in__72);
            targetUid_77 = FastMeta.META_UUID.deserialize(sCtx_69, in__72);
            hasAccess_78 = in__72.readBoolean();
            return new AccessCheckResult(sourceUid_76, targetUid_77, hasAccess_78);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<AccessCheckResult> = AccessCheckResult.META_BODY;
    constructor(sourceUid: UUID, targetUid: UUID, hasAccess: boolean)  {
        this.sourceUid = sourceUid;
        this.targetUid = targetUid;
        this.hasAccess = hasAccess;
        
    }
    public getSourceUid(): UUID  {
        return this.sourceUid;
        
    }
    public getTargetUid(): UUID  {
        return this.targetUid;
        
    }
    public isHasAccess(): boolean  {
        return this.hasAccess;
        
    }
    public toString(result: AString): AString  {
        result.add('AccessCheckResult(');
        result.add('sourceUid:').add(this.sourceUid);
        result.add(', ');
        result.add('targetUid:').add(this.targetUid);
        result.add(', ');
        result.add('hasAccess:').add(this.hasAccess);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: AccessGroup ---
export class AccessGroup implements ToString  {
    public readonly owner: UUID;
    public readonly id: number;
    public readonly data: UUID[];
    public static readonly META_BODY: FastMetaType<AccessGroup> = new class implements FastMetaType<AccessGroup>  {
        serialize(sCtx_82: FastFutureContext, obj_83: AccessGroup, _out_84: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_82, obj_83.owner, _out_84);
            _out_84.writeLong(obj_83.id);
            SerializerPackNumber.INSTANCE.put(_out_84, obj_83.data.length);
            for (const el_88 of obj_83.data)  {
                FastMeta.META_UUID.serialize(sCtx_82, el_88, _out_84);
                
            }
            
        }
        deserialize(sCtx_82: FastFutureContext, in__85: DataIn): AccessGroup  {
            let owner_90: UUID;
            let id_91: number;
            let data_92: UUID[];
            owner_90 = FastMeta.META_UUID.deserialize(sCtx_82, in__85);
            id_91 = in__85.readLong();
            const len_96 = DeserializerPackNumber.INSTANCE.put(in__85).valueOf();
            data_92 = new Array<UUID>(len_96);
            for (let idx_95 = 0;
            idx_95 < len_96;
            idx_95++)  {
                data_92[idx_95] = FastMeta.META_UUID.deserialize(sCtx_82, in__85);
                
            }
            return new AccessGroup(owner_90, id_91, data_92);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<AccessGroup> = AccessGroup.META_BODY;
    constructor(owner: UUID, id: number, data: UUID[])  {
        this.owner = owner;
        this.id = id;
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type AccessGroup.`);
        
    }
    public getOwner(): UUID  {
        return this.owner;
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getData(): UUID[]  {
        return this.data;
        
    }
    public dataContains(el: UUID): boolean  {
        return (this.data as UUID[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('AccessGroup(');
        result.add('owner:').add(this.owner);
        result.add(', ');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ClientInfo ---
export class ClientInfo implements ToString  {
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<ClientInfo> = new class implements FastMetaType<ClientInfo>  {
        serialize(sCtx_98: FastFutureContext, obj_99: ClientInfo, _out_100: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_98, obj_99.uid, _out_100);
            Cloud.META.serialize(sCtx_98, obj_99.cloud, _out_100);
            
        }
        deserialize(sCtx_98: FastFutureContext, in__101: DataIn): ClientInfo  {
            let uid_104: UUID;
            let cloud_105: Cloud;
            uid_104 = FastMeta.META_UUID.deserialize(sCtx_98, in__101);
            cloud_105 = Cloud.META.deserialize(sCtx_98, in__101);
            return new ClientInfo(uid_104, cloud_105);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ClientInfo> = ClientInfo.META_BODY;
    constructor(uid: UUID, cloud: Cloud)  {
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type ClientInfo.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('ClientInfo(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ClientStateForSave ---
export class ClientStateForSave implements ToString  {
    public readonly registrationUri: URI[];
    public readonly servers: ServerDescriptor[];
    public readonly clients: ClientInfo[];
    public readonly rootSigners: Key[];
    public readonly cryptoLib: CryptoLib;
    public readonly pingDuration: number;
    public readonly parentUid: UUID;
    public readonly countServersForRegistration: number;
    public readonly timeoutForConnectToRegistrationServer: number;
    public readonly uid: UUID;
    public readonly alias: UUID;
    public readonly masterKey: Key;
    public static readonly META_BODY: FastMetaType<ClientStateForSave> = new class implements FastMetaType<ClientStateForSave>  {
        serialize(sCtx_108: FastFutureContext, obj_109: ClientStateForSave, _out_110: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_110, obj_109.registrationUri.length);
            for (const el_112 of obj_109.registrationUri)  {
                FastMeta.META_URI.serialize(sCtx_108, el_112, _out_110);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_110, obj_109.servers.length);
            for (const el_114 of obj_109.servers)  {
                ServerDescriptor.META.serialize(sCtx_108, el_114, _out_110);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_110, obj_109.clients.length);
            for (const el_116 of obj_109.clients)  {
                ClientInfo.META.serialize(sCtx_108, el_116, _out_110);
                
            }
            SerializerPackNumber.INSTANCE.put(_out_110, obj_109.rootSigners.length);
            for (const el_118 of obj_109.rootSigners)  {
                Key.META.serialize(sCtx_108, el_118, _out_110);
                
            }
            CryptoLib.META.serialize(sCtx_108, obj_109.cryptoLib, _out_110);
            _out_110.writeLong(obj_109.pingDuration);
            FastMeta.META_UUID.serialize(sCtx_108, obj_109.parentUid, _out_110);
            _out_110.writeInt(obj_109.countServersForRegistration);
            _out_110.writeLong(obj_109.timeoutForConnectToRegistrationServer);
            FastMeta.META_UUID.serialize(sCtx_108, obj_109.uid, _out_110);
            FastMeta.META_UUID.serialize(sCtx_108, obj_109.alias, _out_110);
            Key.META.serialize(sCtx_108, obj_109.masterKey, _out_110);
            
        }
        deserialize(sCtx_108: FastFutureContext, in__111: DataIn): ClientStateForSave  {
            let registrationUri_128: URI[];
            let servers_129: ServerDescriptor[];
            let clients_130: ClientInfo[];
            let rootSigners_131: Key[];
            let cryptoLib_132: CryptoLib;
            let pingDuration_133: number;
            let parentUid_134: UUID;
            let countServersForRegistration_135: number;
            let timeoutForConnectToRegistrationServer_136: number;
            let uid_137: UUID;
            let alias_138: UUID;
            let masterKey_139: Key;
            const len_141 = DeserializerPackNumber.INSTANCE.put(in__111).valueOf();
            registrationUri_128 = new Array<URI>(len_141);
            for (let idx_140 = 0;
            idx_140 < len_141;
            idx_140++)  {
                registrationUri_128[idx_140] = FastMeta.META_URI.deserialize(sCtx_108, in__111);
                
            }
            const len_144 = DeserializerPackNumber.INSTANCE.put(in__111).valueOf();
            servers_129 = new Array<ServerDescriptor>(len_144);
            for (let idx_143 = 0;
            idx_143 < len_144;
            idx_143++)  {
                servers_129[idx_143] = ServerDescriptor.META.deserialize(sCtx_108, in__111);
                
            }
            const len_147 = DeserializerPackNumber.INSTANCE.put(in__111).valueOf();
            clients_130 = new Array<ClientInfo>(len_147);
            for (let idx_146 = 0;
            idx_146 < len_147;
            idx_146++)  {
                clients_130[idx_146] = ClientInfo.META.deserialize(sCtx_108, in__111);
                
            }
            const len_150 = DeserializerPackNumber.INSTANCE.put(in__111).valueOf();
            rootSigners_131 = new Array<Key>(len_150);
            for (let idx_149 = 0;
            idx_149 < len_150;
            idx_149++)  {
                rootSigners_131[idx_149] = Key.META.deserialize(sCtx_108, in__111);
                
            }
            cryptoLib_132 = CryptoLib.META.deserialize(sCtx_108, in__111);
            pingDuration_133 = in__111.readLong();
            parentUid_134 = FastMeta.META_UUID.deserialize(sCtx_108, in__111);
            countServersForRegistration_135 = in__111.readInt();
            timeoutForConnectToRegistrationServer_136 = in__111.readLong();
            uid_137 = FastMeta.META_UUID.deserialize(sCtx_108, in__111);
            alias_138 = FastMeta.META_UUID.deserialize(sCtx_108, in__111);
            masterKey_139 = Key.META.deserialize(sCtx_108, in__111);
            return new ClientStateForSave(registrationUri_128, servers_129, clients_130, rootSigners_131, cryptoLib_132, pingDuration_133, parentUid_134, countServersForRegistration_135, timeoutForConnectToRegistrationServer_136, uid_137, alias_138, masterKey_139);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ClientStateForSave> = ClientStateForSave.META_BODY;
    constructor(registrationUri: URI[], servers: ServerDescriptor[], clients: ClientInfo[], rootSigners: Key[], cryptoLib: CryptoLib, pingDuration: number, parentUid: UUID, countServersForRegistration: number, timeoutForConnectToRegistrationServer: number, uid: UUID, alias: UUID, masterKey: Key)  {
        this.registrationUri = registrationUri;
        this.servers = servers;
        this.clients = clients;
        this.rootSigners = rootSigners;
        this.cryptoLib = cryptoLib;
        this.pingDuration = pingDuration;
        this.parentUid = parentUid;
        this.countServersForRegistration = countServersForRegistration;
        this.timeoutForConnectToRegistrationServer = timeoutForConnectToRegistrationServer;
        this.uid = uid;
        this.alias = alias;
        this.masterKey = masterKey;
        if (registrationUri === null || registrationUri === undefined) throw new Error(`Field 'registrationUri' cannot be null for type ClientStateForSave.`);
        if (servers === null || servers === undefined) throw new Error(`Field 'servers' cannot be null for type ClientStateForSave.`);
        if (clients === null || clients === undefined) throw new Error(`Field 'clients' cannot be null for type ClientStateForSave.`);
        if (rootSigners === null || rootSigners === undefined) throw new Error(`Field 'rootSigners' cannot be null for type ClientStateForSave.`);
        if (cryptoLib === null || cryptoLib === undefined) throw new Error(`Field 'cryptoLib' cannot be null for type ClientStateForSave.`);
        if (masterKey === null || masterKey === undefined) throw new Error(`Field 'masterKey' cannot be null for type ClientStateForSave.`);
        
    }
    public getRegistrationUri(): URI[]  {
        return this.registrationUri;
        
    }
    public registrationUriContains(el: URI): boolean  {
        return (this.registrationUri as URI[]).includes(el as any);
        
    }
    public getServers(): ServerDescriptor[]  {
        return this.servers;
        
    }
    public serversContains(el: ServerDescriptor): boolean  {
        return (this.servers as ServerDescriptor[]).includes(el as any);
        
    }
    public getClients(): ClientInfo[]  {
        return this.clients;
        
    }
    public clientsContains(el: ClientInfo): boolean  {
        return (this.clients as ClientInfo[]).includes(el as any);
        
    }
    public getRootSigners(): Key[]  {
        return this.rootSigners;
        
    }
    public rootSignersContains(el: Key): boolean  {
        return (this.rootSigners as Key[]).includes(el as any);
        
    }
    public getCryptoLib(): CryptoLib  {
        return this.cryptoLib;
        
    }
    public getPingDuration(): number  {
        return this.pingDuration;
        
    }
    public getParentUid(): UUID  {
        return this.parentUid;
        
    }
    public getCountServersForRegistration(): number  {
        return this.countServersForRegistration;
        
    }
    public getTimeoutForConnectToRegistrationServer(): number  {
        return this.timeoutForConnectToRegistrationServer;
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getAlias(): UUID  {
        return this.alias;
        
    }
    public getMasterKey(): Key  {
        return this.masterKey;
        
    }
    public toString(result: AString): AString  {
        result.add('ClientStateForSave(');
        result.add('registrationUri:').add(this.registrationUri);
        result.add(', ');
        result.add('servers:').add(this.servers);
        result.add(', ');
        result.add('clients:').add(this.clients);
        result.add(', ');
        result.add('rootSigners:').add(this.rootSigners);
        result.add(', ');
        result.add('cryptoLib:').add(this.cryptoLib);
        result.add(', ');
        result.add('pingDuration:').add(this.pingDuration);
        result.add(', ');
        result.add('parentUid:').add(this.parentUid);
        result.add(', ');
        result.add('countServersForRegistration:').add(this.countServersForRegistration);
        result.add(', ');
        result.add('timeoutForConnectToRegistrationServer:').add(this.timeoutForConnectToRegistrationServer);
        result.add(', ');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('alias:').add(this.alias);
        result.add(', ');
        result.add('masterKey:').add(this.masterKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Cloud ---
export class Cloud implements ToString  {
    public readonly data: number[];
    public static readonly META_BODY: FastMetaType<Cloud> = new class implements FastMetaType<Cloud>  {
        serialize(sCtx_160: FastFutureContext, obj_161: Cloud, _out_162: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_162, obj_161.data.length);
            for (const el_164 of obj_161.data)  {
                _out_162.writeShort(el_164);
                
            }
            
        }
        deserialize(sCtx_160: FastFutureContext, in__163: DataIn): Cloud  {
            let data_166: number[];
            const len_168 = DeserializerPackNumber.INSTANCE.put(in__163).valueOf();
            data_166 = new Array<number>(len_168);
            for (let idx_167 = 0;
            idx_167 < len_168;
            idx_167++)  {
                data_166[idx_167] = in__163.readShort();
                
            }
            return new Cloud(data_166);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<Cloud> = Cloud.META_BODY;
    constructor(data: number[])  {
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type Cloud.`);
        
    }
    public getData(): number[]  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as number[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('Cloud(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: CoderAndPort ---
export class CoderAndPort implements ToString  {
    public readonly codec: AetherCodec;
    public readonly port: number;
    public static readonly META_BODY: FastMetaType<CoderAndPort> = new class implements FastMetaType<CoderAndPort>  {
        serialize(sCtx_170: FastFutureContext, obj_171: CoderAndPort, _out_172: DataOut): void  {
            AetherCodec.META.serialize(sCtx_170, obj_171.codec, _out_172);
            _out_172.writeShort(obj_171.port);
            
        }
        deserialize(sCtx_170: FastFutureContext, in__173: DataIn): CoderAndPort  {
            let codec_176: AetherCodec;
            let port_177: number;
            codec_176 = AetherCodec.META.deserialize(sCtx_170, in__173);
            port_177 = in__173.readShort();
            return new CoderAndPort(codec_176, port_177);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<CoderAndPort> = CoderAndPort.META_BODY;
    constructor(codec: AetherCodec, port: number)  {
        this.codec = codec;
        this.port = port;
        if (codec === null || codec === undefined) throw new Error(`Field 'codec' cannot be null for type CoderAndPort.`);
        
    }
    public getCodec(): AetherCodec  {
        return this.codec;
        
    }
    public getPort(): number  {
        return this.port;
        
    }
    public toString(result: AString): AString  {
        result.add('CoderAndPort(');
        result.add('codec:').add(this.codec);
        result.add(', ');
        result.add('port:').add(this.port);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: FinishResultGlobalRegServerApi ---
export class FinishResultGlobalRegServerApi implements ToString  {
    public readonly alias: UUID;
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<FinishResultGlobalRegServerApi> = new class implements FastMetaType<FinishResultGlobalRegServerApi>  {
        serialize(sCtx_180: FastFutureContext, obj_181: FinishResultGlobalRegServerApi, _out_182: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_180, obj_181.alias, _out_182);
            FastMeta.META_UUID.serialize(sCtx_180, obj_181.uid, _out_182);
            Cloud.META.serialize(sCtx_180, obj_181.cloud, _out_182);
            
        }
        deserialize(sCtx_180: FastFutureContext, in__183: DataIn): FinishResultGlobalRegServerApi  {
            let alias_187: UUID;
            let uid_188: UUID;
            let cloud_189: Cloud;
            alias_187 = FastMeta.META_UUID.deserialize(sCtx_180, in__183);
            uid_188 = FastMeta.META_UUID.deserialize(sCtx_180, in__183);
            cloud_189 = Cloud.META.deserialize(sCtx_180, in__183);
            return new FinishResultGlobalRegServerApi(alias_187, uid_188, cloud_189);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<FinishResultGlobalRegServerApi> = FinishResultGlobalRegServerApi.META_BODY;
    constructor(alias: UUID, uid: UUID, cloud: Cloud)  {
        this.alias = alias;
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type FinishResultGlobalRegServerApi.`);
        
    }
    public getAlias(): UUID  {
        return this.alias;
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('FinishResultGlobalRegServerApi(');
        result.add('alias:').add(this.alias);
        result.add(', ');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenCurvePrivate ---
export class HydrogenCurvePrivate extends KeyAsymmetricPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenCurvePrivate> = new class implements FastMetaType<HydrogenCurvePrivate>  {
        serialize(sCtx_193: FastFutureContext, obj_194: HydrogenCurvePrivate, _out_195: DataOut): void  {
            if (obj_194.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_194.data must be 32 but was $ {
                obj_194.data.length
            }
            `);
            _out_195.write(obj_194.data);
            
        }
        deserialize(sCtx_193: FastFutureContext, in__196: DataIn): HydrogenCurvePrivate  {
            let data_198: Uint8Array;
            const len_200 = 32;
            const bytes_201 = in__196.readBytes(len_200);
            data_198 = bytes_201;
            return new HydrogenCurvePrivate(data_198);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenCurvePrivate> = new class implements FastMetaType<HydrogenCurvePrivate>  {
        serialize(sCtx_202: FastFutureContext, obj_203: HydrogenCurvePrivate, _out_204: DataOut): void  {
            const typeId = typeof (obj_203 as any).getAetherTypeId === 'function' ? obj_203.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_204.writeByte(typeId);
            switch(typeId)  {
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_202, obj_203 as any as HydrogenCurvePrivate, _out_204);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_202, obj_203 as any as SodiumChacha20Poly1305, _out_204);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_202, obj_203 as any as HydrogenSecretBox, _out_204);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_202, obj_203 as any as HydrogenCurvePublic, _out_204);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_202, obj_203 as any as SodiumCurvePublic, _out_204);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_202, obj_203 as any as SodiumCurvePrivate, _out_204);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_202, obj_203 as any as SodiumSignPublic, _out_204);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_202, obj_203 as any as HydrogenSignPublic, _out_204);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_202, obj_203 as any as SodiumSignPrivate, _out_204);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_202, obj_203 as any as HydrogenSignPrivate, _out_204);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_202: FastFutureContext, in__205: DataIn): HydrogenCurvePrivate  {
            const typeId = in__205.readUByte();
            switch(typeId)  {
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_202, in__205) as any as HydrogenCurvePrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenCurvePrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenCurvePrivate.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenCurvePrivate must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenCurvePrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenCurvePublic ---
export class HydrogenCurvePublic extends KeyAsymmetricPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenCurvePublic> = new class implements FastMetaType<HydrogenCurvePublic>  {
        serialize(sCtx_206: FastFutureContext, obj_207: HydrogenCurvePublic, _out_208: DataOut): void  {
            if (obj_207.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_207.data must be 32 but was $ {
                obj_207.data.length
            }
            `);
            _out_208.write(obj_207.data);
            
        }
        deserialize(sCtx_206: FastFutureContext, in__209: DataIn): HydrogenCurvePublic  {
            let data_211: Uint8Array;
            const len_213 = 32;
            const bytes_214 = in__209.readBytes(len_213);
            data_211 = bytes_214;
            return new HydrogenCurvePublic(data_211);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenCurvePublic> = new class implements FastMetaType<HydrogenCurvePublic>  {
        serialize(sCtx_215: FastFutureContext, obj_216: HydrogenCurvePublic, _out_217: DataOut): void  {
            const typeId = typeof (obj_216 as any).getAetherTypeId === 'function' ? obj_216.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenCurvePublic' with invalid type id $ {
                typeId
            }
            `);
            _out_217.writeByte(typeId);
            switch(typeId)  {
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_215, obj_216 as any as HydrogenCurvePublic, _out_217);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_215, obj_216 as any as SodiumChacha20Poly1305, _out_217);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_215, obj_216 as any as HydrogenSecretBox, _out_217);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_215, obj_216 as any as SodiumCurvePublic, _out_217);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_215, obj_216 as any as HydrogenCurvePrivate, _out_217);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_215, obj_216 as any as SodiumCurvePrivate, _out_217);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_215, obj_216 as any as SodiumSignPublic, _out_217);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_215, obj_216 as any as HydrogenSignPublic, _out_217);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_215, obj_216 as any as SodiumSignPrivate, _out_217);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_215, obj_216 as any as HydrogenSignPrivate, _out_217);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenCurvePublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_215: FastFutureContext, in__218: DataIn): HydrogenCurvePublic  {
            const typeId = in__218.readUByte();
            switch(typeId)  {
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_215, in__218) as any as HydrogenCurvePublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenCurvePublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenCurvePublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenCurvePublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenCurvePublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSecretBox ---
export class HydrogenSecretBox extends KeySymmetric implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 3;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSecretBox> = new class implements FastMetaType<HydrogenSecretBox>  {
        serialize(sCtx_219: FastFutureContext, obj_220: HydrogenSecretBox, _out_221: DataOut): void  {
            if (obj_220.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_220.data must be 32 but was $ {
                obj_220.data.length
            }
            `);
            _out_221.write(obj_220.data);
            
        }
        deserialize(sCtx_219: FastFutureContext, in__222: DataIn): HydrogenSecretBox  {
            let data_224: Uint8Array;
            const len_226 = 32;
            const bytes_227 = in__222.readBytes(len_226);
            data_224 = bytes_227;
            return new HydrogenSecretBox(data_224);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSecretBox> = new class implements FastMetaType<HydrogenSecretBox>  {
        serialize(sCtx_228: FastFutureContext, obj_229: HydrogenSecretBox, _out_230: DataOut): void  {
            const typeId = typeof (obj_229 as any).getAetherTypeId === 'function' ? obj_229.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSecretBox' with invalid type id $ {
                typeId
            }
            `);
            _out_230.writeByte(typeId);
            switch(typeId)  {
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_228, obj_229 as any as HydrogenSecretBox, _out_230);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_228, obj_229 as any as SodiumChacha20Poly1305, _out_230);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_228, obj_229 as any as HydrogenCurvePublic, _out_230);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_228, obj_229 as any as SodiumCurvePublic, _out_230);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_228, obj_229 as any as HydrogenCurvePrivate, _out_230);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_228, obj_229 as any as SodiumCurvePrivate, _out_230);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_228, obj_229 as any as SodiumSignPublic, _out_230);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_228, obj_229 as any as HydrogenSignPublic, _out_230);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_228, obj_229 as any as SodiumSignPrivate, _out_230);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_228, obj_229 as any as HydrogenSignPrivate, _out_230);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSecretBox' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_228: FastFutureContext, in__231: DataIn): HydrogenSecretBox  {
            const typeId = in__231.readUByte();
            switch(typeId)  {
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_228, in__231) as any as HydrogenSecretBox;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSecretBox'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSecretBox.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenSecretBox must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSecretBox(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSignPrivate ---
export class HydrogenSignPrivate extends KeySignPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 4;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSignPrivate> = new class implements FastMetaType<HydrogenSignPrivate>  {
        serialize(sCtx_232: FastFutureContext, obj_233: HydrogenSignPrivate, _out_234: DataOut): void  {
            if (obj_233.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_233.data must be 64 but was $ {
                obj_233.data.length
            }
            `);
            _out_234.write(obj_233.data);
            
        }
        deserialize(sCtx_232: FastFutureContext, in__235: DataIn): HydrogenSignPrivate  {
            let data_237: Uint8Array;
            const len_239 = 64;
            const bytes_240 = in__235.readBytes(len_239);
            data_237 = bytes_240;
            return new HydrogenSignPrivate(data_237);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSignPrivate> = new class implements FastMetaType<HydrogenSignPrivate>  {
        serialize(sCtx_241: FastFutureContext, obj_242: HydrogenSignPrivate, _out_243: DataOut): void  {
            const typeId = typeof (obj_242 as any).getAetherTypeId === 'function' ? obj_242.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_243.writeByte(typeId);
            switch(typeId)  {
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_241, obj_242 as any as HydrogenSignPrivate, _out_243);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_241, obj_242 as any as SodiumChacha20Poly1305, _out_243);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_241, obj_242 as any as HydrogenSecretBox, _out_243);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_241, obj_242 as any as HydrogenCurvePublic, _out_243);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_241, obj_242 as any as SodiumCurvePublic, _out_243);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_241, obj_242 as any as HydrogenCurvePrivate, _out_243);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_241, obj_242 as any as SodiumCurvePrivate, _out_243);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_241, obj_242 as any as SodiumSignPublic, _out_243);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_241, obj_242 as any as HydrogenSignPublic, _out_243);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_241, obj_242 as any as SodiumSignPrivate, _out_243);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_241: FastFutureContext, in__244: DataIn): HydrogenSignPrivate  {
            const typeId = in__244.readUByte();
            switch(typeId)  {
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_241, in__244) as any as HydrogenSignPrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSignPrivate.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type HydrogenSignPrivate must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSignPrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: HydrogenSignPublic ---
export class HydrogenSignPublic extends KeySignPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 5;
        
    }
    public static readonly META_BODY: FastMetaType<HydrogenSignPublic> = new class implements FastMetaType<HydrogenSignPublic>  {
        serialize(sCtx_245: FastFutureContext, obj_246: HydrogenSignPublic, _out_247: DataOut): void  {
            if (obj_246.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_246.data must be 32 but was $ {
                obj_246.data.length
            }
            `);
            _out_247.write(obj_246.data);
            
        }
        deserialize(sCtx_245: FastFutureContext, in__248: DataIn): HydrogenSignPublic  {
            let data_250: Uint8Array;
            const len_252 = 32;
            const bytes_253 = in__248.readBytes(len_252);
            data_250 = bytes_253;
            return new HydrogenSignPublic(data_250);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<HydrogenSignPublic> = new class implements FastMetaType<HydrogenSignPublic>  {
        serialize(sCtx_254: FastFutureContext, obj_255: HydrogenSignPublic, _out_256: DataOut): void  {
            const typeId = typeof (obj_255 as any).getAetherTypeId === 'function' ? obj_255.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'HydrogenSignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_256.writeByte(typeId);
            switch(typeId)  {
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_254, obj_255 as any as HydrogenSignPublic, _out_256);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_254, obj_255 as any as SodiumChacha20Poly1305, _out_256);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_254, obj_255 as any as HydrogenSecretBox, _out_256);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_254, obj_255 as any as HydrogenCurvePublic, _out_256);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_254, obj_255 as any as SodiumCurvePublic, _out_256);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_254, obj_255 as any as HydrogenCurvePrivate, _out_256);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_254, obj_255 as any as SodiumCurvePrivate, _out_256);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_254, obj_255 as any as SodiumSignPublic, _out_256);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_254, obj_255 as any as SodiumSignPrivate, _out_256);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_254, obj_255 as any as HydrogenSignPrivate, _out_256);
                break;
                default: throw new Error(`Cannot serialize 'HydrogenSignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_254: FastFutureContext, in__257: DataIn): HydrogenSignPublic  {
            const typeId = in__257.readUByte();
            switch(typeId)  {
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_254, in__257) as any as HydrogenSignPublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'HydrogenSignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type HydrogenSignPublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type HydrogenSignPublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('HydrogenSignPublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressAndPorts ---
export class IPAddressAndPorts implements ToString  {
    public readonly address: IPAddress;
    public readonly coderAndPorts: CoderAndPort[];
    public static readonly META_BODY: FastMetaType<IPAddressAndPorts> = new class implements FastMetaType<IPAddressAndPorts>  {
        serialize(sCtx_258: FastFutureContext, obj_259: IPAddressAndPorts, _out_260: DataOut): void  {
            IPAddress.META.serialize(sCtx_258, obj_259.address, _out_260);
            SerializerPackNumber.INSTANCE.put(_out_260, obj_259.coderAndPorts.length);
            for (const el_263 of obj_259.coderAndPorts)  {
                CoderAndPort.META.serialize(sCtx_258, el_263, _out_260);
                
            }
            
        }
        deserialize(sCtx_258: FastFutureContext, in__261: DataIn): IPAddressAndPorts  {
            let address_265: IPAddress;
            let coderAndPorts_266: CoderAndPort[];
            address_265 = IPAddress.META.deserialize(sCtx_258, in__261);
            const len_269 = DeserializerPackNumber.INSTANCE.put(in__261).valueOf();
            coderAndPorts_266 = new Array<CoderAndPort>(len_269);
            for (let idx_268 = 0;
            idx_268 < len_269;
            idx_268++)  {
                coderAndPorts_266[idx_268] = CoderAndPort.META.deserialize(sCtx_258, in__261);
                
            }
            return new IPAddressAndPorts(address_265, coderAndPorts_266);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressAndPorts> = IPAddressAndPorts.META_BODY;
    constructor(address: IPAddress, coderAndPorts: CoderAndPort[])  {
        this.address = address;
        this.coderAndPorts = coderAndPorts;
        if (address === null || address === undefined) throw new Error(`Field 'address' cannot be null for type IPAddressAndPorts.`);
        if (coderAndPorts === null || coderAndPorts === undefined) throw new Error(`Field 'coderAndPorts' cannot be null for type IPAddressAndPorts.`);
        
    }
    public getAddress(): IPAddress  {
        return this.address;
        
    }
    public getCoderAndPorts(): CoderAndPort[]  {
        return this.coderAndPorts;
        
    }
    public coderAndPortsContains(el: CoderAndPort): boolean  {
        return (this.coderAndPorts as CoderAndPort[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressAndPorts(');
        result.add('address:').add(this.address);
        result.add(', ');
        result.add('coderAndPorts:').add(this.coderAndPorts);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressAndPortsList ---
export class IPAddressAndPortsList implements ToString  {
    public readonly addresses: IPAddressAndPorts[];
    public static readonly META_BODY: FastMetaType<IPAddressAndPortsList> = new class implements FastMetaType<IPAddressAndPortsList>  {
        serialize(sCtx_271: FastFutureContext, obj_272: IPAddressAndPortsList, _out_273: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(_out_273, obj_272.addresses.length);
            for (const el_275 of obj_272.addresses)  {
                IPAddressAndPorts.META.serialize(sCtx_271, el_275, _out_273);
                
            }
            
        }
        deserialize(sCtx_271: FastFutureContext, in__274: DataIn): IPAddressAndPortsList  {
            let addresses_277: IPAddressAndPorts[];
            const len_279 = DeserializerPackNumber.INSTANCE.put(in__274).valueOf();
            addresses_277 = new Array<IPAddressAndPorts>(len_279);
            for (let idx_278 = 0;
            idx_278 < len_279;
            idx_278++)  {
                addresses_277[idx_278] = IPAddressAndPorts.META.deserialize(sCtx_271, in__274);
                
            }
            return new IPAddressAndPortsList(addresses_277);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressAndPortsList> = IPAddressAndPortsList.META_BODY;
    constructor(addresses: IPAddressAndPorts[])  {
        this.addresses = addresses;
        if (addresses === null || addresses === undefined) throw new Error(`Field 'addresses' cannot be null for type IPAddressAndPortsList.`);
        
    }
    public getAddresses(): IPAddressAndPorts[]  {
        return this.addresses;
        
    }
    public addressesContains(el: IPAddressAndPorts): boolean  {
        return (this.addresses as IPAddressAndPorts[]).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressAndPortsList(');
        result.add('addresses:').add(this.addresses);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressV4 ---
export class IPAddressV4 extends IPAddress implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<IPAddressV4> = new class implements FastMetaType<IPAddressV4>  {
        serialize(sCtx_281: FastFutureContext, obj_282: IPAddressV4, _out_283: DataOut): void  {
            if (obj_282.data.length !== 4) throw new Error(`IllegalStateException: Array length for obj_282.data must be 4 but was $ {
                obj_282.data.length
            }
            `);
            _out_283.write(obj_282.data);
            
        }
        deserialize(sCtx_281: FastFutureContext, in__284: DataIn): IPAddressV4  {
            let data_286: Uint8Array;
            const len_288 = 4;
            const bytes_289 = in__284.readBytes(len_288);
            data_286 = bytes_289;
            return new IPAddressV4(data_286);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressV4> = new class implements FastMetaType<IPAddressV4>  {
        serialize(sCtx_290: FastFutureContext, obj_291: IPAddressV4, _out_292: DataOut): void  {
            const typeId = typeof (obj_291 as any).getAetherTypeId === 'function' ? obj_291.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddressV4' with invalid type id $ {
                typeId
            }
            `);
            _out_292.writeByte(typeId);
            switch(typeId)  {
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_290, obj_291 as any as IPAddressV4, _out_292);
                break;
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_290, obj_291 as any as IPAddressV6, _out_292);
                break;
                default: throw new Error(`Cannot serialize 'IPAddressV4' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_290: FastFutureContext, in__293: DataIn): IPAddressV4  {
            const typeId = in__293.readUByte();
            switch(typeId)  {
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_290, in__293) as any as IPAddressV4;
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_290, in__293) as any as IPAddressV4;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddressV4'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type IPAddressV4.`);
        if (data.length !== 4) throw new Error(`Array length for field 'data' in type IPAddressV4 must be 4 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressV4(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: IPAddressV6 ---
export class IPAddressV6 extends IPAddress implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<IPAddressV6> = new class implements FastMetaType<IPAddressV6>  {
        serialize(sCtx_294: FastFutureContext, obj_295: IPAddressV6, _out_296: DataOut): void  {
            if (obj_295.data.length !== 6) throw new Error(`IllegalStateException: Array length for obj_295.data must be 6 but was $ {
                obj_295.data.length
            }
            `);
            _out_296.write(obj_295.data);
            
        }
        deserialize(sCtx_294: FastFutureContext, in__297: DataIn): IPAddressV6  {
            let data_299: Uint8Array;
            const len_301 = 6;
            const bytes_302 = in__297.readBytes(len_301);
            data_299 = bytes_302;
            return new IPAddressV6(data_299);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<IPAddressV6> = new class implements FastMetaType<IPAddressV6>  {
        serialize(sCtx_303: FastFutureContext, obj_304: IPAddressV6, _out_305: DataOut): void  {
            const typeId = typeof (obj_304 as any).getAetherTypeId === 'function' ? obj_304.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'IPAddressV6' with invalid type id $ {
                typeId
            }
            `);
            _out_305.writeByte(typeId);
            switch(typeId)  {
                case 2: (IPAddressV6 as any).META_BODY.serialize(sCtx_303, obj_304 as any as IPAddressV6, _out_305);
                break;
                case 1: (IPAddressV4 as any).META_BODY.serialize(sCtx_303, obj_304 as any as IPAddressV4, _out_305);
                break;
                default: throw new Error(`Cannot serialize 'IPAddressV6' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_303: FastFutureContext, in__306: DataIn): IPAddressV6  {
            const typeId = in__306.readUByte();
            switch(typeId)  {
                case 2: return (IPAddressV6 as any).META_BODY.deserialize(sCtx_303, in__306) as any as IPAddressV6;
                case 1: return (IPAddressV4 as any).META_BODY.deserialize(sCtx_303, in__306) as any as IPAddressV6;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'IPAddressV6'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type IPAddressV6.`);
        if (data.length !== 6) throw new Error(`Array length for field 'data' in type IPAddressV6 must be 6 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('IPAddressV6(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: Message ---
export class Message implements ToString  {
    public readonly uid: UUID;
    public readonly data: Uint8Array;
    public static readonly META_BODY: FastMetaType<Message> = new class implements FastMetaType<Message>  {
        serialize(sCtx_307: FastFutureContext, obj_308: Message, _out_309: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_307, obj_308.uid, _out_309);
            SerializerPackNumber.INSTANCE.put(_out_309, obj_308.data.length);
            _out_309.write(obj_308.data);
            
        }
        deserialize(sCtx_307: FastFutureContext, in__310: DataIn): Message  {
            let uid_313: UUID;
            let data_314: Uint8Array;
            uid_313 = FastMeta.META_UUID.deserialize(sCtx_307, in__310);
            const len_317 = DeserializerPackNumber.INSTANCE.put(in__310).valueOf();
            const bytes_318 = in__310.readBytes(len_317);
            data_314 = bytes_318;
            return new Message(uid_313, data_314);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<Message> = Message.META_BODY;
    constructor(uid: UUID, data: Uint8Array)  {
        this.uid = uid;
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type Message.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('Message(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: MoneyOperation ---
export class MoneyOperation implements ToString  {
    public readonly id: number;
    public readonly from: UUID;
    public readonly to: UUID;
    public readonly amount: number;
    public readonly time: number;
    public readonly credit: boolean;
    public readonly status: Status;
    public static readonly META_BODY: FastMetaType<MoneyOperation> = new class implements FastMetaType<MoneyOperation>  {
        serialize(sCtx_319: FastFutureContext, obj_320: MoneyOperation, _out_321: DataOut): void  {
            _out_321.writeLong(obj_320.id);
            FastMeta.META_UUID.serialize(sCtx_319, obj_320.from, _out_321);
            FastMeta.META_UUID.serialize(sCtx_319, obj_320.to, _out_321);
            _out_321.writeLong(obj_320.amount);
            _out_321.writeLong(obj_320.time);
            _out_321.writeBoolean(obj_320.credit);
            Status.META.serialize(sCtx_319, obj_320.status, _out_321);
            
        }
        deserialize(sCtx_319: FastFutureContext, in__322: DataIn): MoneyOperation  {
            let id_330: number;
            let from_331: UUID;
            let to_332: UUID;
            let amount_333: number;
            let time_334: number;
            let credit_335: boolean;
            let status_336: Status;
            id_330 = in__322.readLong();
            from_331 = FastMeta.META_UUID.deserialize(sCtx_319, in__322);
            to_332 = FastMeta.META_UUID.deserialize(sCtx_319, in__322);
            amount_333 = in__322.readLong();
            time_334 = in__322.readLong();
            credit_335 = in__322.readBoolean();
            status_336 = Status.META.deserialize(sCtx_319, in__322);
            return new MoneyOperation(id_330, from_331, to_332, amount_333, time_334, credit_335, status_336);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<MoneyOperation> = MoneyOperation.META_BODY;
    constructor(id: number, from: UUID, to: UUID, amount: number, time: number, credit: boolean, status: Status)  {
        this.id = id;
        this.from = from;
        this.to = to;
        this.amount = amount;
        this.time = time;
        this.credit = credit;
        this.status = status;
        if (status === null || status === undefined) throw new Error(`Field 'status' cannot be null for type MoneyOperation.`);
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getFrom(): UUID  {
        return this.from;
        
    }
    public getTo(): UUID  {
        return this.to;
        
    }
    public getAmount(): number  {
        return this.amount;
        
    }
    public getTime(): number  {
        return this.time;
        
    }
    public isCredit(): boolean  {
        return this.credit;
        
    }
    public getStatus(): Status  {
        return this.status;
        
    }
    public toString(result: AString): AString  {
        result.add('MoneyOperation(');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('from:').add(this.from);
        result.add(', ');
        result.add('to:').add(this.to);
        result.add(', ');
        result.add('amount:').add(this.amount);
        result.add(', ');
        result.add('time:').add(this.time);
        result.add(', ');
        result.add('credit:').add(this.credit);
        result.add(', ');
        result.add('status:').add(this.status);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysAsym ---
export class PairKeysAsym extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: Key;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysAsym> = new class implements FastMetaType<PairKeysAsym>  {
        serialize(sCtx_344: FastFutureContext, obj_345: PairKeysAsym, _out_346: DataOut): void  {
            Key.META.serialize(sCtx_344, obj_345.privateKey, _out_346);
            Key.META.serialize(sCtx_344, obj_345.publicKey, _out_346);
            
        }
        deserialize(sCtx_344: FastFutureContext, in__347: DataIn): PairKeysAsym  {
            let privateKey_350: Key;
            let publicKey_351: Key;
            privateKey_350 = Key.META.deserialize(sCtx_344, in__347);
            publicKey_351 = Key.META.deserialize(sCtx_344, in__347);
            return new PairKeysAsym(privateKey_350, publicKey_351);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysAsym> = new class implements FastMetaType<PairKeysAsym>  {
        serialize(sCtx_354: FastFutureContext, obj_355: PairKeysAsym, _out_356: DataOut): void  {
            const typeId = typeof (obj_355 as any).getAetherTypeId === 'function' ? obj_355.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysAsym' with invalid type id $ {
                typeId
            }
            `);
            _out_356.writeByte(typeId);
            switch(typeId)  {
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_354, obj_355 as any as PairKeysAsym, _out_356);
                break;
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_354, obj_355 as any as PairKeysSign, _out_356);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_354, obj_355 as any as PairKeysAsymSigned, _out_356);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysAsym' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_354: FastFutureContext, in__357: DataIn): PairKeysAsym  {
            const typeId = in__357.readUByte();
            switch(typeId)  {
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_354, in__357) as any as PairKeysAsym;
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_354, in__357) as any as PairKeysAsym;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_354, in__357) as any as PairKeysAsym;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysAsym'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: Key)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsym.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsym.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): Key  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysAsym(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysAsymSigned ---
export class PairKeysAsymSigned extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: SignedKey;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysAsymSigned> = new class implements FastMetaType<PairKeysAsymSigned>  {
        serialize(sCtx_358: FastFutureContext, obj_359: PairKeysAsymSigned, _out_360: DataOut): void  {
            Key.META.serialize(sCtx_358, obj_359.privateKey, _out_360);
            SignedKey.META.serialize(sCtx_358, obj_359.publicKey, _out_360);
            
        }
        deserialize(sCtx_358: FastFutureContext, in__361: DataIn): PairKeysAsymSigned  {
            let privateKey_364: Key;
            let publicKey_365: SignedKey;
            privateKey_364 = Key.META.deserialize(sCtx_358, in__361);
            publicKey_365 = SignedKey.META.deserialize(sCtx_358, in__361);
            return new PairKeysAsymSigned(privateKey_364, publicKey_365);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysAsymSigned> = new class implements FastMetaType<PairKeysAsymSigned>  {
        serialize(sCtx_368: FastFutureContext, obj_369: PairKeysAsymSigned, _out_370: DataOut): void  {
            const typeId = typeof (obj_369 as any).getAetherTypeId === 'function' ? obj_369.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysAsymSigned' with invalid type id $ {
                typeId
            }
            `);
            _out_370.writeByte(typeId);
            switch(typeId)  {
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_368, obj_369 as any as PairKeysAsymSigned, _out_370);
                break;
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_368, obj_369 as any as PairKeysSign, _out_370);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_368, obj_369 as any as PairKeysAsym, _out_370);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysAsymSigned' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_368: FastFutureContext, in__371: DataIn): PairKeysAsymSigned  {
            const typeId = in__371.readUByte();
            switch(typeId)  {
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_368, in__371) as any as PairKeysAsymSigned;
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_368, in__371) as any as PairKeysAsymSigned;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_368, in__371) as any as PairKeysAsymSigned;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysAsymSigned'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: SignedKey)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsymSigned.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsymSigned.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): SignedKey  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysAsymSigned(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: PairKeysSign ---
export class PairKeysSign extends PairKeys implements ToString  {
    public readonly privateKey: Key;
    public readonly publicKey: Key;
    public override getAetherTypeId(): number  {
        return 3;
        
    }
    public static readonly META_BODY: FastMetaType<PairKeysSign> = new class implements FastMetaType<PairKeysSign>  {
        serialize(sCtx_372: FastFutureContext, obj_373: PairKeysSign, _out_374: DataOut): void  {
            Key.META.serialize(sCtx_372, obj_373.privateKey, _out_374);
            Key.META.serialize(sCtx_372, obj_373.publicKey, _out_374);
            
        }
        deserialize(sCtx_372: FastFutureContext, in__375: DataIn): PairKeysSign  {
            let privateKey_378: Key;
            let publicKey_379: Key;
            privateKey_378 = Key.META.deserialize(sCtx_372, in__375);
            publicKey_379 = Key.META.deserialize(sCtx_372, in__375);
            return new PairKeysSign(privateKey_378, publicKey_379);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<PairKeysSign> = new class implements FastMetaType<PairKeysSign>  {
        serialize(sCtx_382: FastFutureContext, obj_383: PairKeysSign, _out_384: DataOut): void  {
            const typeId = typeof (obj_383 as any).getAetherTypeId === 'function' ? obj_383.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'PairKeysSign' with invalid type id $ {
                typeId
            }
            `);
            _out_384.writeByte(typeId);
            switch(typeId)  {
                case 3: (PairKeysSign as any).META_BODY.serialize(sCtx_382, obj_383 as any as PairKeysSign, _out_384);
                break;
                case 1: (PairKeysAsym as any).META_BODY.serialize(sCtx_382, obj_383 as any as PairKeysAsym, _out_384);
                break;
                case 2: (PairKeysAsymSigned as any).META_BODY.serialize(sCtx_382, obj_383 as any as PairKeysAsymSigned, _out_384);
                break;
                default: throw new Error(`Cannot serialize 'PairKeysSign' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_382: FastFutureContext, in__385: DataIn): PairKeysSign  {
            const typeId = in__385.readUByte();
            switch(typeId)  {
                case 3: return (PairKeysSign as any).META_BODY.deserialize(sCtx_382, in__385) as any as PairKeysSign;
                case 1: return (PairKeysAsym as any).META_BODY.deserialize(sCtx_382, in__385) as any as PairKeysSign;
                case 2: return (PairKeysAsymSigned as any).META_BODY.deserialize(sCtx_382, in__385) as any as PairKeysSign;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'PairKeysSign'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(privateKey: Key, publicKey: Key)  {
        super();
        this.privateKey = privateKey;
        this.publicKey = publicKey;
        if (privateKey === null || privateKey === undefined) throw new Error(`Field 'privateKey' cannot be null for type PairKeysSign.`);
        if (publicKey === null || publicKey === undefined) throw new Error(`Field 'publicKey' cannot be null for type PairKeysSign.`);
        
    }
    public getPrivateKey(): Key  {
        return this.privateKey;
        
    }
    public getPublicKey(): Key  {
        return this.publicKey;
        
    }
    public toString(result: AString): AString  {
        result.add('PairKeysSign(');
        result.add('privateKey:').add(this.privateKey);
        result.add(', ');
        result.add('publicKey:').add(this.publicKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: ServerDescriptor ---
export class ServerDescriptor implements ToString  {
    public readonly id: number;
    public readonly ipAddress: IPAddressAndPortsList;
    public static readonly META_BODY: FastMetaType<ServerDescriptor> = new class implements FastMetaType<ServerDescriptor>  {
        serialize(sCtx_386: FastFutureContext, obj_387: ServerDescriptor, _out_388: DataOut): void  {
            _out_388.writeShort(obj_387.id);
            IPAddressAndPortsList.META.serialize(sCtx_386, obj_387.ipAddress, _out_388);
            
        }
        deserialize(sCtx_386: FastFutureContext, in__389: DataIn): ServerDescriptor  {
            let id_392: number;
            let ipAddress_393: IPAddressAndPortsList;
            id_392 = in__389.readShort();
            ipAddress_393 = IPAddressAndPortsList.META.deserialize(sCtx_386, in__389);
            return new ServerDescriptor(id_392, ipAddress_393);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<ServerDescriptor> = ServerDescriptor.META_BODY;
    constructor(id: number, ipAddress: IPAddressAndPortsList)  {
        this.id = id;
        this.ipAddress = ipAddress;
        if (ipAddress === null || ipAddress === undefined) throw new Error(`Field 'ipAddress' cannot be null for type ServerDescriptor.`);
        
    }
    public getId(): number  {
        return this.id;
        
    }
    public getIpAddress(): IPAddressAndPortsList  {
        return this.ipAddress;
        
    }
    public toString(result: AString): AString  {
        result.add('ServerDescriptor(');
        result.add('id:').add(this.id);
        result.add(', ');
        result.add('ipAddress:').add(this.ipAddress);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignAE_ED25519 ---
export class SignAE_ED25519 extends Sign implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<SignAE_ED25519> = new class implements FastMetaType<SignAE_ED25519>  {
        serialize(sCtx_396: FastFutureContext, obj_397: SignAE_ED25519, _out_398: DataOut): void  {
            if (obj_397.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_397.data must be 64 but was $ {
                obj_397.data.length
            }
            `);
            _out_398.write(obj_397.data);
            
        }
        deserialize(sCtx_396: FastFutureContext, in__399: DataIn): SignAE_ED25519  {
            let data_401: Uint8Array;
            const len_403 = 64;
            const bytes_404 = in__399.readBytes(len_403);
            data_401 = bytes_404;
            return new SignAE_ED25519(data_401);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignAE_ED25519> = new class implements FastMetaType<SignAE_ED25519>  {
        serialize(sCtx_405: FastFutureContext, obj_406: SignAE_ED25519, _out_407: DataOut): void  {
            const typeId = typeof (obj_406 as any).getAetherTypeId === 'function' ? obj_406.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SignAE_ED25519' with invalid type id $ {
                typeId
            }
            `);
            _out_407.writeByte(typeId);
            switch(typeId)  {
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_405, obj_406 as any as SignAE_ED25519, _out_407);
                break;
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_405, obj_406 as any as SignHYDROGEN, _out_407);
                break;
                default: throw new Error(`Cannot serialize 'SignAE_ED25519' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_405: FastFutureContext, in__408: DataIn): SignAE_ED25519  {
            const typeId = in__408.readUByte();
            switch(typeId)  {
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_405, in__408) as any as SignAE_ED25519;
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_405, in__408) as any as SignAE_ED25519;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SignAE_ED25519'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SignAE_ED25519.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SignAE_ED25519 must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SignAE_ED25519(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignedKey ---
export class SignedKey implements ToString  {
    public readonly key: Key;
    public readonly sign: Sign;
    public static readonly META_BODY: FastMetaType<SignedKey> = new class implements FastMetaType<SignedKey>  {
        serialize(sCtx_409: FastFutureContext, obj_410: SignedKey, _out_411: DataOut): void  {
            Key.META.serialize(sCtx_409, obj_410.key, _out_411);
            Sign.META.serialize(sCtx_409, obj_410.sign, _out_411);
            
        }
        deserialize(sCtx_409: FastFutureContext, in__412: DataIn): SignedKey  {
            let _key_415: Key;
            let sign_416: Sign;
            _key_415 = Key.META.deserialize(sCtx_409, in__412);
            sign_416 = Sign.META.deserialize(sCtx_409, in__412);
            return new SignedKey(_key_415, sign_416);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignedKey> = SignedKey.META_BODY;
    constructor(key: Key, sign: Sign)  {
        this.key = key;
        this.sign = sign;
        if (key === null || key === undefined) throw new Error(`Field 'key' cannot be null for type SignedKey.`);
        if (sign === null || sign === undefined) throw new Error(`Field 'sign' cannot be null for type SignedKey.`);
        
    }
    public getKey(): Key  {
        return this.key;
        
    }
    public getSign(): Sign  {
        return this.sign;
        
    }
    public toString(result: AString): AString  {
        result.add('SignedKey(');
        result.add('key:').add(this.key);
        result.add(', ');
        result.add('sign:').add(this.sign);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SignHYDROGEN ---
export class SignHYDROGEN extends Sign implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 2;
        
    }
    public static readonly META_BODY: FastMetaType<SignHYDROGEN> = new class implements FastMetaType<SignHYDROGEN>  {
        serialize(sCtx_419: FastFutureContext, obj_420: SignHYDROGEN, _out_421: DataOut): void  {
            if (obj_420.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_420.data must be 64 but was $ {
                obj_420.data.length
            }
            `);
            _out_421.write(obj_420.data);
            
        }
        deserialize(sCtx_419: FastFutureContext, in__422: DataIn): SignHYDROGEN  {
            let data_424: Uint8Array;
            const len_426 = 64;
            const bytes_427 = in__422.readBytes(len_426);
            data_424 = bytes_427;
            return new SignHYDROGEN(data_424);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SignHYDROGEN> = new class implements FastMetaType<SignHYDROGEN>  {
        serialize(sCtx_428: FastFutureContext, obj_429: SignHYDROGEN, _out_430: DataOut): void  {
            const typeId = typeof (obj_429 as any).getAetherTypeId === 'function' ? obj_429.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SignHYDROGEN' with invalid type id $ {
                typeId
            }
            `);
            _out_430.writeByte(typeId);
            switch(typeId)  {
                case 2: (SignHYDROGEN as any).META_BODY.serialize(sCtx_428, obj_429 as any as SignHYDROGEN, _out_430);
                break;
                case 1: (SignAE_ED25519 as any).META_BODY.serialize(sCtx_428, obj_429 as any as SignAE_ED25519, _out_430);
                break;
                default: throw new Error(`Cannot serialize 'SignHYDROGEN' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_428: FastFutureContext, in__431: DataIn): SignHYDROGEN  {
            const typeId = in__431.readUByte();
            switch(typeId)  {
                case 2: return (SignHYDROGEN as any).META_BODY.deserialize(sCtx_428, in__431) as any as SignHYDROGEN;
                case 1: return (SignAE_ED25519 as any).META_BODY.deserialize(sCtx_428, in__431) as any as SignHYDROGEN;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SignHYDROGEN'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SignHYDROGEN.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SignHYDROGEN must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SignHYDROGEN(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumChacha20Poly1305 ---
export class SodiumChacha20Poly1305 extends KeySymmetric implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 6;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumChacha20Poly1305> = new class implements FastMetaType<SodiumChacha20Poly1305>  {
        serialize(sCtx_432: FastFutureContext, obj_433: SodiumChacha20Poly1305, _out_434: DataOut): void  {
            if (obj_433.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_433.data must be 32 but was $ {
                obj_433.data.length
            }
            `);
            _out_434.write(obj_433.data);
            
        }
        deserialize(sCtx_432: FastFutureContext, in__435: DataIn): SodiumChacha20Poly1305  {
            let data_437: Uint8Array;
            const len_439 = 32;
            const bytes_440 = in__435.readBytes(len_439);
            data_437 = bytes_440;
            return new SodiumChacha20Poly1305(data_437);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumChacha20Poly1305> = new class implements FastMetaType<SodiumChacha20Poly1305>  {
        serialize(sCtx_441: FastFutureContext, obj_442: SodiumChacha20Poly1305, _out_443: DataOut): void  {
            const typeId = typeof (obj_442 as any).getAetherTypeId === 'function' ? obj_442.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with invalid type id $ {
                typeId
            }
            `);
            _out_443.writeByte(typeId);
            switch(typeId)  {
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_441, obj_442 as any as SodiumChacha20Poly1305, _out_443);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_441, obj_442 as any as HydrogenSecretBox, _out_443);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_441, obj_442 as any as HydrogenCurvePublic, _out_443);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_441, obj_442 as any as SodiumCurvePublic, _out_443);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_441, obj_442 as any as HydrogenCurvePrivate, _out_443);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_441, obj_442 as any as SodiumCurvePrivate, _out_443);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_441, obj_442 as any as SodiumSignPublic, _out_443);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_441, obj_442 as any as HydrogenSignPublic, _out_443);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_441, obj_442 as any as SodiumSignPrivate, _out_443);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_441, obj_442 as any as HydrogenSignPrivate, _out_443);
                break;
                default: throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_441: FastFutureContext, in__444: DataIn): SodiumChacha20Poly1305  {
            const typeId = in__444.readUByte();
            switch(typeId)  {
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_441, in__444) as any as SodiumChacha20Poly1305;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumChacha20Poly1305'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumChacha20Poly1305.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumChacha20Poly1305 must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumChacha20Poly1305(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumCurvePrivate ---
export class SodiumCurvePrivate extends KeyAsymmetricPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 7;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumCurvePrivate> = new class implements FastMetaType<SodiumCurvePrivate>  {
        serialize(sCtx_445: FastFutureContext, obj_446: SodiumCurvePrivate, _out_447: DataOut): void  {
            if (obj_446.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_446.data must be 32 but was $ {
                obj_446.data.length
            }
            `);
            _out_447.write(obj_446.data);
            
        }
        deserialize(sCtx_445: FastFutureContext, in__448: DataIn): SodiumCurvePrivate  {
            let data_450: Uint8Array;
            const len_452 = 32;
            const bytes_453 = in__448.readBytes(len_452);
            data_450 = bytes_453;
            return new SodiumCurvePrivate(data_450);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumCurvePrivate> = new class implements FastMetaType<SodiumCurvePrivate>  {
        serialize(sCtx_454: FastFutureContext, obj_455: SodiumCurvePrivate, _out_456: DataOut): void  {
            const typeId = typeof (obj_455 as any).getAetherTypeId === 'function' ? obj_455.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumCurvePrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_456.writeByte(typeId);
            switch(typeId)  {
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_454, obj_455 as any as SodiumCurvePrivate, _out_456);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_454, obj_455 as any as SodiumChacha20Poly1305, _out_456);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_454, obj_455 as any as HydrogenSecretBox, _out_456);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_454, obj_455 as any as HydrogenCurvePublic, _out_456);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_454, obj_455 as any as SodiumCurvePublic, _out_456);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_454, obj_455 as any as HydrogenCurvePrivate, _out_456);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_454, obj_455 as any as SodiumSignPublic, _out_456);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_454, obj_455 as any as HydrogenSignPublic, _out_456);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_454, obj_455 as any as SodiumSignPrivate, _out_456);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_454, obj_455 as any as HydrogenSignPrivate, _out_456);
                break;
                default: throw new Error(`Cannot serialize 'SodiumCurvePrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_454: FastFutureContext, in__457: DataIn): SodiumCurvePrivate  {
            const typeId = in__457.readUByte();
            switch(typeId)  {
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_454, in__457) as any as SodiumCurvePrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumCurvePrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumCurvePrivate.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumCurvePrivate must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumCurvePrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumCurvePublic ---
export class SodiumCurvePublic extends KeyAsymmetricPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 8;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumCurvePublic> = new class implements FastMetaType<SodiumCurvePublic>  {
        serialize(sCtx_458: FastFutureContext, obj_459: SodiumCurvePublic, _out_460: DataOut): void  {
            if (obj_459.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_459.data must be 32 but was $ {
                obj_459.data.length
            }
            `);
            _out_460.write(obj_459.data);
            
        }
        deserialize(sCtx_458: FastFutureContext, in__461: DataIn): SodiumCurvePublic  {
            let data_463: Uint8Array;
            const len_465 = 32;
            const bytes_466 = in__461.readBytes(len_465);
            data_463 = bytes_466;
            return new SodiumCurvePublic(data_463);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumCurvePublic> = new class implements FastMetaType<SodiumCurvePublic>  {
        serialize(sCtx_467: FastFutureContext, obj_468: SodiumCurvePublic, _out_469: DataOut): void  {
            const typeId = typeof (obj_468 as any).getAetherTypeId === 'function' ? obj_468.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumCurvePublic' with invalid type id $ {
                typeId
            }
            `);
            _out_469.writeByte(typeId);
            switch(typeId)  {
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_467, obj_468 as any as SodiumCurvePublic, _out_469);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_467, obj_468 as any as SodiumChacha20Poly1305, _out_469);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_467, obj_468 as any as HydrogenSecretBox, _out_469);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_467, obj_468 as any as HydrogenCurvePublic, _out_469);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_467, obj_468 as any as HydrogenCurvePrivate, _out_469);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_467, obj_468 as any as SodiumCurvePrivate, _out_469);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_467, obj_468 as any as SodiumSignPublic, _out_469);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_467, obj_468 as any as HydrogenSignPublic, _out_469);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_467, obj_468 as any as SodiumSignPrivate, _out_469);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_467, obj_468 as any as HydrogenSignPrivate, _out_469);
                break;
                default: throw new Error(`Cannot serialize 'SodiumCurvePublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_467: FastFutureContext, in__470: DataIn): SodiumCurvePublic  {
            const typeId = in__470.readUByte();
            switch(typeId)  {
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_467, in__470) as any as SodiumCurvePublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumCurvePublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumCurvePublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumCurvePublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumCurvePublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumSignPrivate ---
export class SodiumSignPrivate extends KeySignPrivate implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 9;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumSignPrivate> = new class implements FastMetaType<SodiumSignPrivate>  {
        serialize(sCtx_471: FastFutureContext, obj_472: SodiumSignPrivate, _out_473: DataOut): void  {
            if (obj_472.data.length !== 64) throw new Error(`IllegalStateException: Array length for obj_472.data must be 64 but was $ {
                obj_472.data.length
            }
            `);
            _out_473.write(obj_472.data);
            
        }
        deserialize(sCtx_471: FastFutureContext, in__474: DataIn): SodiumSignPrivate  {
            let data_476: Uint8Array;
            const len_478 = 64;
            const bytes_479 = in__474.readBytes(len_478);
            data_476 = bytes_479;
            return new SodiumSignPrivate(data_476);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumSignPrivate> = new class implements FastMetaType<SodiumSignPrivate>  {
        serialize(sCtx_480: FastFutureContext, obj_481: SodiumSignPrivate, _out_482: DataOut): void  {
            const typeId = typeof (obj_481 as any).getAetherTypeId === 'function' ? obj_481.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumSignPrivate' with invalid type id $ {
                typeId
            }
            `);
            _out_482.writeByte(typeId);
            switch(typeId)  {
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_480, obj_481 as any as SodiumSignPrivate, _out_482);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_480, obj_481 as any as SodiumChacha20Poly1305, _out_482);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_480, obj_481 as any as HydrogenSecretBox, _out_482);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_480, obj_481 as any as HydrogenCurvePublic, _out_482);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_480, obj_481 as any as SodiumCurvePublic, _out_482);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_480, obj_481 as any as HydrogenCurvePrivate, _out_482);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_480, obj_481 as any as SodiumCurvePrivate, _out_482);
                break;
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_480, obj_481 as any as SodiumSignPublic, _out_482);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_480, obj_481 as any as HydrogenSignPublic, _out_482);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_480, obj_481 as any as HydrogenSignPrivate, _out_482);
                break;
                default: throw new Error(`Cannot serialize 'SodiumSignPrivate' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_480: FastFutureContext, in__483: DataIn): SodiumSignPrivate  {
            const typeId = in__483.readUByte();
            switch(typeId)  {
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_480, in__483) as any as SodiumSignPrivate;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumSignPrivate'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumSignPrivate.`);
        if (data.length !== 64) throw new Error(`Array length for field 'data' in type SodiumSignPrivate must be 64 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumSignPrivate(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: SodiumSignPublic ---
export class SodiumSignPublic extends KeySignPublic implements ToString  {
    public readonly data: Uint8Array;
    public override getAetherTypeId(): number  {
        return 10;
        
    }
    public static readonly META_BODY: FastMetaType<SodiumSignPublic> = new class implements FastMetaType<SodiumSignPublic>  {
        serialize(sCtx_484: FastFutureContext, obj_485: SodiumSignPublic, _out_486: DataOut): void  {
            if (obj_485.data.length !== 32) throw new Error(`IllegalStateException: Array length for obj_485.data must be 32 but was $ {
                obj_485.data.length
            }
            `);
            _out_486.write(obj_485.data);
            
        }
        deserialize(sCtx_484: FastFutureContext, in__487: DataIn): SodiumSignPublic  {
            let data_489: Uint8Array;
            const len_491 = 32;
            const bytes_492 = in__487.readBytes(len_491);
            data_489 = bytes_492;
            return new SodiumSignPublic(data_489);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<SodiumSignPublic> = new class implements FastMetaType<SodiumSignPublic>  {
        serialize(sCtx_493: FastFutureContext, obj_494: SodiumSignPublic, _out_495: DataOut): void  {
            const typeId = typeof (obj_494 as any).getAetherTypeId === 'function' ? obj_494.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'SodiumSignPublic' with invalid type id $ {
                typeId
            }
            `);
            _out_495.writeByte(typeId);
            switch(typeId)  {
                case 10: (SodiumSignPublic as any).META_BODY.serialize(sCtx_493, obj_494 as any as SodiumSignPublic, _out_495);
                break;
                case 6: (SodiumChacha20Poly1305 as any).META_BODY.serialize(sCtx_493, obj_494 as any as SodiumChacha20Poly1305, _out_495);
                break;
                case 3: (HydrogenSecretBox as any).META_BODY.serialize(sCtx_493, obj_494 as any as HydrogenSecretBox, _out_495);
                break;
                case 2: (HydrogenCurvePublic as any).META_BODY.serialize(sCtx_493, obj_494 as any as HydrogenCurvePublic, _out_495);
                break;
                case 8: (SodiumCurvePublic as any).META_BODY.serialize(sCtx_493, obj_494 as any as SodiumCurvePublic, _out_495);
                break;
                case 1: (HydrogenCurvePrivate as any).META_BODY.serialize(sCtx_493, obj_494 as any as HydrogenCurvePrivate, _out_495);
                break;
                case 7: (SodiumCurvePrivate as any).META_BODY.serialize(sCtx_493, obj_494 as any as SodiumCurvePrivate, _out_495);
                break;
                case 5: (HydrogenSignPublic as any).META_BODY.serialize(sCtx_493, obj_494 as any as HydrogenSignPublic, _out_495);
                break;
                case 9: (SodiumSignPrivate as any).META_BODY.serialize(sCtx_493, obj_494 as any as SodiumSignPrivate, _out_495);
                break;
                case 4: (HydrogenSignPrivate as any).META_BODY.serialize(sCtx_493, obj_494 as any as HydrogenSignPrivate, _out_495);
                break;
                default: throw new Error(`Cannot serialize 'SodiumSignPublic' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_493: FastFutureContext, in__496: DataIn): SodiumSignPublic  {
            const typeId = in__496.readUByte();
            switch(typeId)  {
                case 10: return (SodiumSignPublic as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 6: return (SodiumChacha20Poly1305 as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 3: return (HydrogenSecretBox as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 2: return (HydrogenCurvePublic as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 8: return (SodiumCurvePublic as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 1: return (HydrogenCurvePrivate as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 7: return (SodiumCurvePrivate as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 5: return (HydrogenSignPublic as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 9: return (SodiumSignPrivate as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                case 4: return (HydrogenSignPrivate as any).META_BODY.deserialize(sCtx_493, in__496) as any as SodiumSignPublic;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'SodiumSignPublic'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(data: Uint8Array)  {
        super();
        this.data = data;
        if (data === null || data === undefined) throw new Error(`Field 'data' cannot be null for type SodiumSignPublic.`);
        if (data.length !== 32) throw new Error(`Array length for field 'data' in type SodiumSignPublic must be 32 but was $ {
            data ? data.length : 'null/undefined'
        }
        .`);
        
    }
    public getData(): Uint8Array  {
        return this.data;
        
    }
    public dataContains(el: number): boolean  {
        return (this.data as Uint8Array).includes(el as any);
        
    }
    public toString(result: AString): AString  {
        result.add('SodiumSignPublic(');
        result.add('data:').add(this.data);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: TelemetryCPP ---
export class TelemetryCPP extends Telemetry implements ToString  {
    public readonly utm_id: number;
    public readonly blob: Uint8Array;
    public readonly lib_version: string;
    public readonly os: string;
    public readonly compiler: string;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<TelemetryCPP> = new class implements FastMetaType<TelemetryCPP>  {
        serialize(sCtx_497: FastFutureContext, obj_498: TelemetryCPP, _out_499: DataOut): void  {
            _out_499.writeInt(obj_498.utm_id);
            SerializerPackNumber.INSTANCE.put(_out_499, obj_498.blob.length);
            _out_499.write(obj_498.blob);
            const stringBytes_504 = new TextEncoder().encode(obj_498.lib_version);
            SerializerPackNumber.INSTANCE.put(_out_499, stringBytes_504.length);
            _out_499.write(stringBytes_504);
            const stringBytes_507 = new TextEncoder().encode(obj_498.os);
            SerializerPackNumber.INSTANCE.put(_out_499, stringBytes_507.length);
            _out_499.write(stringBytes_507);
            const stringBytes_510 = new TextEncoder().encode(obj_498.compiler);
            SerializerPackNumber.INSTANCE.put(_out_499, stringBytes_510.length);
            _out_499.write(stringBytes_510);
            
        }
        deserialize(sCtx_497: FastFutureContext, in__500: DataIn): TelemetryCPP  {
            let utm_id_512: number;
            let blob_513: Uint8Array;
            let lib_version_514: string;
            let os_515: string;
            let compiler_516: string;
            utm_id_512 = in__500.readInt();
            const len_519 = DeserializerPackNumber.INSTANCE.put(in__500).valueOf();
            const bytes_520 = in__500.readBytes(len_519);
            blob_513 = bytes_520;
            let stringBytes_522: Uint8Array;
            const len_524 = DeserializerPackNumber.INSTANCE.put(in__500).valueOf();
            const bytes_525 = in__500.readBytes(len_524);
            stringBytes_522 = bytes_525;
            lib_version_514 = new TextDecoder('utf-8').decode(stringBytes_522);
            let stringBytes_527: Uint8Array;
            const len_529 = DeserializerPackNumber.INSTANCE.put(in__500).valueOf();
            const bytes_530 = in__500.readBytes(len_529);
            stringBytes_527 = bytes_530;
            os_515 = new TextDecoder('utf-8').decode(stringBytes_527);
            let stringBytes_532: Uint8Array;
            const len_534 = DeserializerPackNumber.INSTANCE.put(in__500).valueOf();
            const bytes_535 = in__500.readBytes(len_534);
            stringBytes_532 = bytes_535;
            compiler_516 = new TextDecoder('utf-8').decode(stringBytes_532);
            return new TelemetryCPP(utm_id_512, blob_513, lib_version_514, os_515, compiler_516);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<TelemetryCPP> = new class implements FastMetaType<TelemetryCPP>  {
        serialize(sCtx_536: FastFutureContext, obj_537: TelemetryCPP, _out_538: DataOut): void  {
            const typeId = typeof (obj_537 as any).getAetherTypeId === 'function' ? obj_537.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'TelemetryCPP' with invalid type id $ {
                typeId
            }
            `);
            _out_538.writeByte(typeId);
            switch(typeId)  {
                case 1: (TelemetryCPP as any).META_BODY.serialize(sCtx_536, obj_537 as any as TelemetryCPP, _out_538);
                break;
                default: throw new Error(`Cannot serialize 'TelemetryCPP' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_536: FastFutureContext, in__539: DataIn): TelemetryCPP  {
            const typeId = in__539.readUByte();
            switch(typeId)  {
                case 1: return (TelemetryCPP as any).META_BODY.deserialize(sCtx_536, in__539) as any as TelemetryCPP;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'TelemetryCPP'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(utm_id: number, blob: Uint8Array, lib_version: string, os: string, compiler: string)  {
        super();
        this.utm_id = utm_id;
        this.blob = blob;
        this.lib_version = lib_version;
        this.os = os;
        this.compiler = compiler;
        if (blob === null || blob === undefined) throw new Error(`Field 'blob' cannot be null for type TelemetryCPP.`);
        if (lib_version === null || lib_version === undefined) throw new Error(`Field 'lib_version' cannot be null for type TelemetryCPP.`);
        if (os === null || os === undefined) throw new Error(`Field 'os' cannot be null for type TelemetryCPP.`);
        if (compiler === null || compiler === undefined) throw new Error(`Field 'compiler' cannot be null for type TelemetryCPP.`);
        
    }
    public getUtm_id(): number  {
        return this.utm_id;
        
    }
    public getBlob(): Uint8Array  {
        return this.blob;
        
    }
    public blobContains(el: number): boolean  {
        return (this.blob as Uint8Array).includes(el as any);
        
    }
    public getLib_version(): string  {
        return this.lib_version;
        
    }
    public getOs(): string  {
        return this.os;
        
    }
    public getCompiler(): string  {
        return this.compiler;
        
    }
    public toString(result: AString): AString  {
        result.add('TelemetryCPP(');
        result.add('utm_id:').add(this.utm_id);
        result.add(', ');
        result.add('blob:').add(this.blob);
        result.add(', ');
        result.add('lib_version:').add(this.lib_version);
        result.add(', ');
        result.add('os:').add(this.os);
        result.add(', ');
        result.add('compiler:').add(this.compiler);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: UUIDAndCloud ---
export class UUIDAndCloud implements ToString  {
    public readonly uid: UUID;
    public readonly cloud: Cloud;
    public static readonly META_BODY: FastMetaType<UUIDAndCloud> = new class implements FastMetaType<UUIDAndCloud>  {
        serialize(sCtx_540: FastFutureContext, obj_541: UUIDAndCloud, _out_542: DataOut): void  {
            FastMeta.META_UUID.serialize(sCtx_540, obj_541.uid, _out_542);
            Cloud.META.serialize(sCtx_540, obj_541.cloud, _out_542);
            
        }
        deserialize(sCtx_540: FastFutureContext, in__543: DataIn): UUIDAndCloud  {
            let uid_546: UUID;
            let cloud_547: Cloud;
            uid_546 = FastMeta.META_UUID.deserialize(sCtx_540, in__543);
            cloud_547 = Cloud.META.deserialize(sCtx_540, in__543);
            return new UUIDAndCloud(uid_546, cloud_547);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<UUIDAndCloud> = UUIDAndCloud.META_BODY;
    constructor(uid: UUID, cloud: Cloud)  {
        this.uid = uid;
        this.cloud = cloud;
        if (cloud === null || cloud === undefined) throw new Error(`Field 'cloud' cannot be null for type UUIDAndCloud.`);
        
    }
    public getUid(): UUID  {
        return this.uid;
        
    }
    public getCloud(): Cloud  {
        return this.cloud;
        
    }
    public toString(result: AString): AString  {
        result.add('UUIDAndCloud(');
        result.add('uid:').add(this.uid);
        result.add(', ');
        result.add('cloud:').add(this.cloud);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofBCrypt ---
export class WorkProofBCrypt extends WorkProofConfig implements ToString  {
    public readonly costBCrypt: number;
    public readonly poolSize: number;
    public readonly maxHashVal: number;
    public override getAetherTypeId(): number  {
        return 1;
        
    }
    public static readonly META_BODY: FastMetaType<WorkProofBCrypt> = new class implements FastMetaType<WorkProofBCrypt>  {
        serialize(sCtx_550: FastFutureContext, obj_551: WorkProofBCrypt, _out_552: DataOut): void  {
            _out_552.writeByte(obj_551.costBCrypt);
            _out_552.writeByte(obj_551.poolSize);
            _out_552.writeInt(obj_551.maxHashVal);
            
        }
        deserialize(sCtx_550: FastFutureContext, in__553: DataIn): WorkProofBCrypt  {
            let costBCrypt_557: number;
            let poolSize_558: number;
            let maxHashVal_559: number;
            costBCrypt_557 = in__553.readByte();
            poolSize_558 = in__553.readByte();
            maxHashVal_559 = in__553.readInt();
            return new WorkProofBCrypt(costBCrypt_557, poolSize_558, maxHashVal_559);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<WorkProofBCrypt> = new class implements FastMetaType<WorkProofBCrypt>  {
        serialize(sCtx_563: FastFutureContext, obj_564: WorkProofBCrypt, _out_565: DataOut): void  {
            const typeId = typeof (obj_564 as any).getAetherTypeId === 'function' ? obj_564.getAetherTypeId() : -1;
            if (typeId === undefined || typeId < 0) throw new Error(`Cannot serialize 'WorkProofBCrypt' with invalid type id $ {
                typeId
            }
            `);
            _out_565.writeByte(typeId);
            switch(typeId)  {
                case 1: (WorkProofBCrypt as any).META_BODY.serialize(sCtx_563, obj_564 as any as WorkProofBCrypt, _out_565);
                break;
                default: throw new Error(`Cannot serialize 'WorkProofBCrypt' with unknown type id $ {
                    typeId
                }
                `);
                
            }
            
        }
        deserialize(sCtx_563: FastFutureContext, in__566: DataIn): WorkProofBCrypt  {
            const typeId = in__566.readUByte();
            switch(typeId)  {
                case 1: return (WorkProofBCrypt as any).META_BODY.deserialize(sCtx_563, in__566) as any as WorkProofBCrypt;
                default: throw new Error(`Bad type id $ {
                    typeId
                }
                for type 'WorkProofBCrypt'`);
                
            }
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    constructor(costBCrypt: number, poolSize: number, maxHashVal: number)  {
        super();
        this.costBCrypt = costBCrypt;
        this.poolSize = poolSize;
        this.maxHashVal = maxHashVal;
        
    }
    public getCostBCrypt(): number  {
        return this.costBCrypt;
        
    }
    public getPoolSize(): number  {
        return this.poolSize;
        
    }
    public getMaxHashVal(): number  {
        return this.maxHashVal;
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofBCrypt(');
        result.add('costBCrypt:').add(this.costBCrypt);
        result.add(', ');
        result.add('poolSize:').add(this.poolSize);
        result.add(', ');
        result.add('maxHashVal:').add(this.maxHashVal);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Structure: WorkProofDTO ---
export class WorkProofDTO implements ToString  {
    public readonly salt: string;
    public readonly suffix: string;
    public readonly poolSize: number;
    public readonly maxHashVal: number;
    public readonly globalKey: SignedKey;
    public static readonly META_BODY: FastMetaType<WorkProofDTO> = new class implements FastMetaType<WorkProofDTO>  {
        serialize(sCtx_567: FastFutureContext, obj_568: WorkProofDTO, _out_569: DataOut): void  {
            const stringBytes_572 = new TextEncoder().encode(obj_568.salt);
            SerializerPackNumber.INSTANCE.put(_out_569, stringBytes_572.length);
            _out_569.write(stringBytes_572);
            const stringBytes_575 = new TextEncoder().encode(obj_568.suffix);
            SerializerPackNumber.INSTANCE.put(_out_569, stringBytes_575.length);
            _out_569.write(stringBytes_575);
            _out_569.writeByte(obj_568.poolSize);
            _out_569.writeInt(obj_568.maxHashVal);
            SignedKey.META.serialize(sCtx_567, obj_568.globalKey, _out_569);
            
        }
        deserialize(sCtx_567: FastFutureContext, in__570: DataIn): WorkProofDTO  {
            let salt_580: string;
            let suffix_581: string;
            let poolSize_582: number;
            let maxHashVal_583: number;
            let globalKey_584: SignedKey;
            let stringBytes_586: Uint8Array;
            const len_588 = DeserializerPackNumber.INSTANCE.put(in__570).valueOf();
            const bytes_589 = in__570.readBytes(len_588);
            stringBytes_586 = bytes_589;
            salt_580 = new TextDecoder('utf-8').decode(stringBytes_586);
            let stringBytes_591: Uint8Array;
            const len_593 = DeserializerPackNumber.INSTANCE.put(in__570).valueOf();
            const bytes_594 = in__570.readBytes(len_593);
            stringBytes_591 = bytes_594;
            suffix_581 = new TextDecoder('utf-8').decode(stringBytes_591);
            poolSize_582 = in__570.readByte();
            maxHashVal_583 = in__570.readInt();
            globalKey_584 = SignedKey.META.deserialize(sCtx_567, in__570);
            return new WorkProofDTO(salt_580, suffix_581, poolSize_582, maxHashVal_583, globalKey_584);
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public static readonly META: FastMetaType<WorkProofDTO> = WorkProofDTO.META_BODY;
    constructor(salt: string, suffix: string, poolSize: number, maxHashVal: number, globalKey: SignedKey)  {
        this.salt = salt;
        this.suffix = suffix;
        this.poolSize = poolSize;
        this.maxHashVal = maxHashVal;
        this.globalKey = globalKey;
        if (salt === null || salt === undefined) throw new Error(`Field 'salt' cannot be null for type WorkProofDTO.`);
        if (suffix === null || suffix === undefined) throw new Error(`Field 'suffix' cannot be null for type WorkProofDTO.`);
        if (globalKey === null || globalKey === undefined) throw new Error(`Field 'globalKey' cannot be null for type WorkProofDTO.`);
        
    }
    public getSalt(): string  {
        return this.salt;
        
    }
    public getSuffix(): string  {
        return this.suffix;
        
    }
    public getPoolSize(): number  {
        return this.poolSize;
        
    }
    public getMaxHashVal(): number  {
        return this.maxHashVal;
        
    }
    public getGlobalKey(): SignedKey  {
        return this.globalKey;
        
    }
    public toString(result: AString): AString  {
        result.add('WorkProofDTO(');
        result.add('salt:').add(this.salt);
        result.add(', ');
        result.add('suffix:').add(this.suffix);
        result.add(', ');
        result.add('poolSize:').add(this.poolSize);
        result.add(', ');
        result.add('maxHashVal:').add(this.maxHashVal);
        result.add(', ');
        result.add('globalKey:').add(this.globalKey);
        result.add(')');
        return result;
        
    }
    
}
// --- Generated Stream: ClientApiRegSafeStream ---
export class ClientApiRegSafeStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientApiRegSafeStream> = new class implements FastMetaType<ClientApiRegSafeStream>  {
        serialize(ctx: FastFutureContext, obj: ClientApiRegSafeStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientApiRegSafeStream  {
            return new ClientApiRegSafeStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientApiRegSafeStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ClientApiRegSafe): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ClientApiRegSafe as any).META) throw new Error(`META not found for API type ClientApiRegSafe`);
        (ClientApiRegSafe as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ClientApiRegSafeRemote>, sendFuture: AFuture): ClientApiRegSafeStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ClientApiRegSafeRemote>): ClientApiRegSafeStream  {
        const api = (ClientApiRegSafe as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): ClientApiRegSafeStream  {
        const encryptedData = provider(remoteData);
        return new ClientApiRegSafeStream(encryptedData);
        
    }
    
}
// --- Generated Stream: ClientApiStream ---
export class ClientApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientApiStream> = new class implements FastMetaType<ClientApiStream>  {
        serialize(ctx: FastFutureContext, obj: ClientApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientApiStream  {
            return new ClientApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, localApi: ServerApiByUid): void  {
        const dataInStatic = new DataInOutStatic(this.data);
        if (!(ServerApiByUid as any).META) throw new Error(`META not found for API type ServerApiByUid`);
        (ServerApiByUid as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, remote: RemoteApiFuture<ServerApiByUidRemote>, sendFuture: AFuture): ClientApiStream  {
        remote.executeAll(context, sendFuture);
        return new ClientApiStream(context.remoteDataToArrayAsArray());
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, remoteConsumer: AConsumer<ServerApiByUidRemote>): ClientApiStream  {
        const api = (ServerApiByUid as any).META.makeRemote(context);
        remoteConsumer(api);
        return new ClientApiStream(context.remoteDataToArrayAsArray());
        
    }
    
}
// --- Generated Stream: ClientInteractionClientStream ---
export class ClientInteractionClientStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ClientInteractionClientStream> = new class implements FastMetaType<ClientInteractionClientStream>  {
        serialize(ctx: FastFutureContext, obj: ClientInteractionClientStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ClientInteractionClientStream  {
            return new ClientInteractionClientStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ClientInteractionClientStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, localApi: ServerApiByUidClient): void  {
        const dataInStatic = new DataInOutStatic(this.data);
        if (!(ServerApiByUidClient as any).META) throw new Error(`META not found for API type ServerApiByUidClient`);
        (ServerApiByUidClient as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, remote: RemoteApiFuture<ServerApiByUidClientRemote>, sendFuture: AFuture): ClientInteractionClientStream  {
        remote.executeAll(context, sendFuture);
        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, remoteConsumer: AConsumer<ServerApiByUidClientRemote>): ClientInteractionClientStream  {
        const api = (ServerApiByUidClient as any).META.makeRemote(context);
        remoteConsumer(api);
        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());
        
    }
    
}
// --- Generated Stream: GlobalApiRegistrationServerRegistrationApi ---
export class GlobalApiRegistrationServerRegistrationApi implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<GlobalApiRegistrationServerRegistrationApi> = new class implements FastMetaType<GlobalApiRegistrationServerRegistrationApi>  {
        serialize(ctx: FastFutureContext, obj: GlobalApiRegistrationServerRegistrationApi, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): GlobalApiRegistrationServerRegistrationApi  {
            return new GlobalApiRegistrationServerRegistrationApi(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('GlobalApiRegistrationServerRegistrationApi(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: GlobalRegServerApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(GlobalRegServerApi as any).META) throw new Error(`META not found for API type GlobalRegServerApi`);
        (GlobalRegServerApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<GlobalRegServerApiRemote>, sendFuture: AFuture): GlobalApiRegistrationServerRegistrationApi  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<GlobalRegServerApiRemote>): GlobalApiRegistrationServerRegistrationApi  {
        const api = (GlobalRegServerApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): GlobalApiRegistrationServerRegistrationApi  {
        const encryptedData = provider(remoteData);
        return new GlobalApiRegistrationServerRegistrationApi(encryptedData);
        
    }
    
}
// --- Generated Stream: GlobalRegClientApiStream ---
export class GlobalRegClientApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<GlobalRegClientApiStream> = new class implements FastMetaType<GlobalRegClientApiStream>  {
        serialize(ctx: FastFutureContext, obj: GlobalRegClientApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): GlobalRegClientApiStream  {
            return new GlobalRegClientApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('GlobalRegClientApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: GlobalRegClientApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(GlobalRegClientApi as any).META) throw new Error(`META not found for API type GlobalRegClientApi`);
        (GlobalRegClientApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<GlobalRegClientApiRemote>, sendFuture: AFuture): GlobalRegClientApiStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<GlobalRegClientApiRemote>): GlobalRegClientApiStream  {
        const api = (GlobalRegClientApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): GlobalRegClientApiStream  {
        const encryptedData = provider(remoteData);
        return new GlobalRegClientApiStream(encryptedData);
        
    }
    
}
// --- Generated Stream: LoginClientStream ---
export class LoginClientStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<LoginClientStream> = new class implements FastMetaType<LoginClientStream>  {
        serialize(ctx: FastFutureContext, obj: LoginClientStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): LoginClientStream  {
            return new LoginClientStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('LoginClientStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ClientApiSafe): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ClientApiSafe as any).META) throw new Error(`META not found for API type ClientApiSafe`);
        (ClientApiSafe as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ClientApiSafeRemote>, sendFuture: AFuture): LoginClientStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginClientStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ClientApiSafeRemote>): LoginClientStream  {
        const api = (ClientApiSafe as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginClientStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): LoginClientStream  {
        const encryptedData = provider(remoteData);
        return new LoginClientStream(encryptedData);
        
    }
    
}
// --- Generated Stream: LoginStream ---
export class LoginStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<LoginStream> = new class implements FastMetaType<LoginStream>  {
        serialize(ctx: FastFutureContext, obj: LoginStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): LoginStream  {
            return new LoginStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('LoginStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: AuthorizedApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(AuthorizedApi as any).META) throw new Error(`META not found for API type AuthorizedApi`);
        (AuthorizedApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<AuthorizedApiRemote>, sendFuture: AFuture): LoginStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<AuthorizedApiRemote>): LoginStream  {
        const api = (AuthorizedApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new LoginStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): LoginStream  {
        const encryptedData = provider(remoteData);
        return new LoginStream(encryptedData);
        
    }
    
}
// --- Generated Stream: ServerRegistrationApiStream ---
export class ServerRegistrationApiStream implements ToString  {
    public readonly data: Uint8Array;
    constructor(data: Uint8Array)  {
        this.data = data;
        
    }
    public static readonly META: FastMetaType<ServerRegistrationApiStream> = new class implements FastMetaType<ServerRegistrationApiStream>  {
        serialize(ctx: FastFutureContext, obj: ServerRegistrationApiStream, out: DataOut): void  {
            FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);
            
        }
        deserialize(ctx: FastFutureContext, in_: DataIn): ServerRegistrationApiStream  {
            return new ServerRegistrationApiStream(FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    public toString(result: AString): AString  {
        result.add('ServerRegistrationApiStream(').add('data:').add(this.data).add(')');
        return result;
        
    }
    public accept(context: FastFutureContext, provider: BytesConverter, localApi: ServerRegistrationApi): void  {
        const decryptedData = provider(this.data);
        const dataInStatic = new DataInOutStatic(decryptedData);
        if (!(ServerRegistrationApi as any).META) throw new Error(`META not found for API type ServerRegistrationApi`);
        (ServerRegistrationApi as any).META.makeLocal_fromDataIn(context, dataInStatic, localApi);
        
    }
    public static fromRemote(context: FastFutureContext, provider: BytesConverter, remote: RemoteApiFuture<ServerRegistrationApiRemote>, sendFuture: AFuture): ServerRegistrationApiStream  {
        remote.executeAll(context, sendFuture);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    public static fromRemoteConsumer(context: FastFutureContext, provider: BytesConverter, remoteConsumer: AConsumer<ServerRegistrationApiRemote>): ServerRegistrationApiStream  {
        const api = (ServerRegistrationApi as any).META.makeRemote(context);
        remoteConsumer(api);
        const encryptedData = provider(context.remoteDataToArrayAsArray());
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    public static fromRemoteBytes(provider: BytesConverter, remoteData: Uint8Array): ServerRegistrationApiStream  {
        const encryptedData = provider(remoteData);
        return new ServerRegistrationApiStream(encryptedData);
        
    }
    
}
// --- Generated API Interface: ClientApiUnsafe ---
export interface ClientApiUnsafe  {
    sendSafeApiDataMulti(backId: number, data: LoginClientStream): AFuture;
    sendSafeApiData(data: LoginClientStream): AFuture;
    
}
export namespace ClientApiUnsafe  {
    export const META: FastMetaApi<ClientApiUnsafe, ClientApiUnsafeRemote> = new class implements FastMetaApi<ClientApiUnsafe, ClientApiUnsafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiUnsafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let backId_599: number;
                        let data_600: LoginClientStream;
                        backId_599 = dataIn.readByte();
                        data_600 = LoginClientStream.META.deserialize(ctx, dataIn);
                        const argsNames_603: string[] = ["backId", "data"];
                        const argsValues_604: any[] = [backId_599, data_600];
                        ctx.invokeLocalMethodBefore("sendSafeApiDataMulti", argsNames_603, argsValues_604);
                        localApi.sendSafeApiDataMulti(backId_599, data_600);
                        ctx.invokeLocalMethodAfter("sendSafeApiDataMulti", null, argsNames_603, argsValues_604);
                        break;
                        
                    }
                    case 4:  {
                        let data_606: LoginClientStream;
                        data_606 = LoginClientStream.META.deserialize(ctx, dataIn);
                        const argsNames_608: string[] = ["data"];
                        const argsValues_609: any[] = [data_606];
                        ctx.invokeLocalMethodBefore("sendSafeApiData", argsNames_608, argsValues_609);
                        localApi.sendSafeApiData(data_606);
                        ctx.invokeLocalMethodAfter("sendSafeApiData", null, argsNames_608, argsValues_609);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiUnsafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiUnsafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_610: FastFutureContext): ClientApiUnsafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_610.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_610, sendSafeApiDataMulti: (backId: number, data: LoginClientStream): AFuture =>  {
                    const dataOut_612 = new DataInOut();
                    dataOut_612.writeByte(3);
                    const argsNames_614: string[] = ["backId", "data"];
                    const argsValues_615: any[] = [backId, data];
                    sCtx_610.invokeRemoteMethodAfter("sendSafeApiDataMulti", null, argsNames_614, argsValues_615);
                    dataOut_612.writeByte(backId);
                    LoginClientStream.META.serialize(sCtx_610, data, dataOut_612);
                    sCtx_610.sendToRemote(dataOut_612.toArray());
                    return AFuture.of();
                    
                }
                , sendSafeApiData: (data: LoginClientStream): AFuture =>  {
                    const dataOut_619 = new DataInOut();
                    dataOut_619.writeByte(4);
                    const argsNames_621: string[] = ["data"];
                    const argsValues_622: any[] = [data];
                    sCtx_610.invokeRemoteMethodAfter("sendSafeApiData", null, argsNames_621, argsValues_622);
                    LoginClientStream.META.serialize(sCtx_610, data, dataOut_619);
                    sCtx_610.sendToRemote(dataOut_619.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiUnsafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiUnsafeRemote ---
export interface ClientApiUnsafeRemote extends ClientApiUnsafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiUnsafeLocal ---
export abstract class ClientApiUnsafeLocal<RT extends ClientApiUnsafeRemote> implements ClientApiUnsafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract sendSafeApiDataMulti(backId: number, data: LoginClientStream): AFuture;
    public abstract sendSafeApiData(data: LoginClientStream): AFuture;
    
}
// --- Generated API Interface: ClientApiSafe ---
export interface ClientApiSafe  {
    changeParent(uid: UUID): AFuture;
    changeAlias(alias: UUID): AFuture;
    newChild(uid: UUID): AFuture;
    sendMessages(msg: Message[]): AFuture;
    sendServerDescriptor(serverDescriptor: ServerDescriptor): AFuture;
    sendServerDescriptors(serverDescriptors: ServerDescriptor[]): AFuture;
    sendCloud(uid: UUID, cloud: Cloud): AFuture;
    sendClouds(clouds: UUIDAndCloud[]): AFuture;
    requestTelemetry(): AFuture;
    sendAccessGroups(groups: AccessGroup[]): AFuture;
    sendAccessGroupForClient(uid: UUID, groups: number[]): AFuture;
    addItemsToAccessGroup(id: number, groups: UUID[]): AFuture;
    removeItemsFromAccessGroup(id: number, groups: UUID[]): AFuture;
    addAccessGroupsToClient(uid: UUID, groups: number[]): AFuture;
    removeAccessGroupsFromClient(uid: UUID, groups: number[]): AFuture;
    sendAllAccessedClients(uid: UUID, accessedClients: UUID[]): AFuture;
    sendAccessCheckResults(results: AccessCheckResult[]): AFuture;
    
}
export namespace ClientApiSafe  {
    export const META: FastMetaApi<ClientApiSafe, ClientApiSafeRemote> = new class implements FastMetaApi<ClientApiSafe, ClientApiSafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiSafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let uid_625: UUID;
                        uid_625 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_627: string[] = ["uid"];
                        const argsValues_628: any[] = [uid_625];
                        ctx.invokeLocalMethodBefore("changeParent", argsNames_627, argsValues_628);
                        localApi.changeParent(uid_625);
                        ctx.invokeLocalMethodAfter("changeParent", null, argsNames_627, argsValues_628);
                        break;
                        
                    }
                    case 4:  {
                        let alias_630: UUID;
                        alias_630 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_632: string[] = ["alias"];
                        const argsValues_633: any[] = [alias_630];
                        ctx.invokeLocalMethodBefore("changeAlias", argsNames_632, argsValues_633);
                        localApi.changeAlias(alias_630);
                        ctx.invokeLocalMethodAfter("changeAlias", null, argsNames_632, argsValues_633);
                        break;
                        
                    }
                    case 5:  {
                        let uid_635: UUID;
                        uid_635 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_637: string[] = ["uid"];
                        const argsValues_638: any[] = [uid_635];
                        ctx.invokeLocalMethodBefore("newChild", argsNames_637, argsValues_638);
                        localApi.newChild(uid_635);
                        ctx.invokeLocalMethodAfter("newChild", null, argsNames_637, argsValues_638);
                        break;
                        
                    }
                    case 6:  {
                        let msg_640: Message[];
                        const len_642 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        msg_640 = new Array<Message>(len_642);
                        for (let idx_641 = 0;
                        idx_641 < len_642;
                        idx_641++)  {
                            msg_640[idx_641] = Message.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_644: string[] = ["msg"];
                        const argsValues_645: any[] = [msg_640];
                        ctx.invokeLocalMethodBefore("sendMessages", argsNames_644, argsValues_645);
                        localApi.sendMessages(msg_640);
                        ctx.invokeLocalMethodAfter("sendMessages", null, argsNames_644, argsValues_645);
                        break;
                        
                    }
                    case 7:  {
                        let serverDescriptor_647: ServerDescriptor;
                        serverDescriptor_647 = ServerDescriptor.META.deserialize(ctx, dataIn);
                        const argsNames_649: string[] = ["serverDescriptor"];
                        const argsValues_650: any[] = [serverDescriptor_647];
                        ctx.invokeLocalMethodBefore("sendServerDescriptor", argsNames_649, argsValues_650);
                        localApi.sendServerDescriptor(serverDescriptor_647);
                        ctx.invokeLocalMethodAfter("sendServerDescriptor", null, argsNames_649, argsValues_650);
                        break;
                        
                    }
                    case 8:  {
                        let serverDescriptors_652: ServerDescriptor[];
                        const len_654 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        serverDescriptors_652 = new Array<ServerDescriptor>(len_654);
                        for (let idx_653 = 0;
                        idx_653 < len_654;
                        idx_653++)  {
                            serverDescriptors_652[idx_653] = ServerDescriptor.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_656: string[] = ["serverDescriptors"];
                        const argsValues_657: any[] = [serverDescriptors_652];
                        ctx.invokeLocalMethodBefore("sendServerDescriptors", argsNames_656, argsValues_657);
                        localApi.sendServerDescriptors(serverDescriptors_652);
                        ctx.invokeLocalMethodAfter("sendServerDescriptors", null, argsNames_656, argsValues_657);
                        break;
                        
                    }
                    case 9:  {
                        let uid_659: UUID;
                        let cloud_660: Cloud;
                        uid_659 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        cloud_660 = Cloud.META.deserialize(ctx, dataIn);
                        const argsNames_663: string[] = ["uid", "cloud"];
                        const argsValues_664: any[] = [uid_659, cloud_660];
                        ctx.invokeLocalMethodBefore("sendCloud", argsNames_663, argsValues_664);
                        localApi.sendCloud(uid_659, cloud_660);
                        ctx.invokeLocalMethodAfter("sendCloud", null, argsNames_663, argsValues_664);
                        break;
                        
                    }
                    case 10:  {
                        let clouds_666: UUIDAndCloud[];
                        const len_668 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        clouds_666 = new Array<UUIDAndCloud>(len_668);
                        for (let idx_667 = 0;
                        idx_667 < len_668;
                        idx_667++)  {
                            clouds_666[idx_667] = UUIDAndCloud.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_670: string[] = ["clouds"];
                        const argsValues_671: any[] = [clouds_666];
                        ctx.invokeLocalMethodBefore("sendClouds", argsNames_670, argsValues_671);
                        localApi.sendClouds(clouds_666);
                        ctx.invokeLocalMethodAfter("sendClouds", null, argsNames_670, argsValues_671);
                        break;
                        
                    }
                    case 11:  {
                        const argsNames_673: string[] = [];
                        const argsValues_674: any[] = [];
                        ctx.invokeLocalMethodBefore("requestTelemetry", argsNames_673, argsValues_674);
                        localApi.requestTelemetry();
                        ctx.invokeLocalMethodAfter("requestTelemetry", null, argsNames_673, argsValues_674);
                        break;
                        
                    }
                    case 12:  {
                        let groups_676: AccessGroup[];
                        const len_678 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_676 = new Array<AccessGroup>(len_678);
                        for (let idx_677 = 0;
                        idx_677 < len_678;
                        idx_677++)  {
                            groups_676[idx_677] = AccessGroup.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_680: string[] = ["groups"];
                        const argsValues_681: any[] = [groups_676];
                        ctx.invokeLocalMethodBefore("sendAccessGroups", argsNames_680, argsValues_681);
                        localApi.sendAccessGroups(groups_676);
                        ctx.invokeLocalMethodAfter("sendAccessGroups", null, argsNames_680, argsValues_681);
                        break;
                        
                    }
                    case 13:  {
                        let uid_683: UUID;
                        let groups_684: number[];
                        uid_683 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_687 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_684 = new Array<number>(len_687);
                        for (let idx_686 = 0;
                        idx_686 < len_687;
                        idx_686++)  {
                            groups_684[idx_686] = dataIn.readLong();
                            
                        }
                        const argsNames_689: string[] = ["uid", "groups"];
                        const argsValues_690: any[] = [uid_683, groups_684];
                        ctx.invokeLocalMethodBefore("sendAccessGroupForClient", argsNames_689, argsValues_690);
                        localApi.sendAccessGroupForClient(uid_683, groups_684);
                        ctx.invokeLocalMethodAfter("sendAccessGroupForClient", null, argsNames_689, argsValues_690);
                        break;
                        
                    }
                    case 14:  {
                        let id_692: number;
                        let groups_693: UUID[];
                        id_692 = dataIn.readLong();
                        const len_696 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_693 = new Array<UUID>(len_696);
                        for (let idx_695 = 0;
                        idx_695 < len_696;
                        idx_695++)  {
                            groups_693[idx_695] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_698: string[] = ["id", "groups"];
                        const argsValues_699: any[] = [id_692, groups_693];
                        ctx.invokeLocalMethodBefore("addItemsToAccessGroup", argsNames_698, argsValues_699);
                        localApi.addItemsToAccessGroup(id_692, groups_693);
                        ctx.invokeLocalMethodAfter("addItemsToAccessGroup", null, argsNames_698, argsValues_699);
                        break;
                        
                    }
                    case 15:  {
                        let id_701: number;
                        let groups_702: UUID[];
                        id_701 = dataIn.readLong();
                        const len_705 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_702 = new Array<UUID>(len_705);
                        for (let idx_704 = 0;
                        idx_704 < len_705;
                        idx_704++)  {
                            groups_702[idx_704] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_707: string[] = ["id", "groups"];
                        const argsValues_708: any[] = [id_701, groups_702];
                        ctx.invokeLocalMethodBefore("removeItemsFromAccessGroup", argsNames_707, argsValues_708);
                        localApi.removeItemsFromAccessGroup(id_701, groups_702);
                        ctx.invokeLocalMethodAfter("removeItemsFromAccessGroup", null, argsNames_707, argsValues_708);
                        break;
                        
                    }
                    case 16:  {
                        let uid_710: UUID;
                        let groups_711: number[];
                        uid_710 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_714 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_711 = new Array<number>(len_714);
                        for (let idx_713 = 0;
                        idx_713 < len_714;
                        idx_713++)  {
                            groups_711[idx_713] = dataIn.readLong();
                            
                        }
                        const argsNames_716: string[] = ["uid", "groups"];
                        const argsValues_717: any[] = [uid_710, groups_711];
                        ctx.invokeLocalMethodBefore("addAccessGroupsToClient", argsNames_716, argsValues_717);
                        localApi.addAccessGroupsToClient(uid_710, groups_711);
                        ctx.invokeLocalMethodAfter("addAccessGroupsToClient", null, argsNames_716, argsValues_717);
                        break;
                        
                    }
                    case 17:  {
                        let uid_719: UUID;
                        let groups_720: number[];
                        uid_719 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_723 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_720 = new Array<number>(len_723);
                        for (let idx_722 = 0;
                        idx_722 < len_723;
                        idx_722++)  {
                            groups_720[idx_722] = dataIn.readLong();
                            
                        }
                        const argsNames_725: string[] = ["uid", "groups"];
                        const argsValues_726: any[] = [uid_719, groups_720];
                        ctx.invokeLocalMethodBefore("removeAccessGroupsFromClient", argsNames_725, argsValues_726);
                        localApi.removeAccessGroupsFromClient(uid_719, groups_720);
                        ctx.invokeLocalMethodAfter("removeAccessGroupsFromClient", null, argsNames_725, argsValues_726);
                        break;
                        
                    }
                    case 18:  {
                        let uid_728: UUID;
                        let accessedClients_729: UUID[];
                        uid_728 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_732 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        accessedClients_729 = new Array<UUID>(len_732);
                        for (let idx_731 = 0;
                        idx_731 < len_732;
                        idx_731++)  {
                            accessedClients_729[idx_731] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_734: string[] = ["uid", "accessedClients"];
                        const argsValues_735: any[] = [uid_728, accessedClients_729];
                        ctx.invokeLocalMethodBefore("sendAllAccessedClients", argsNames_734, argsValues_735);
                        localApi.sendAllAccessedClients(uid_728, accessedClients_729);
                        ctx.invokeLocalMethodAfter("sendAllAccessedClients", null, argsNames_734, argsValues_735);
                        break;
                        
                    }
                    case 19:  {
                        let results_737: AccessCheckResult[];
                        const len_739 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        results_737 = new Array<AccessCheckResult>(len_739);
                        for (let idx_738 = 0;
                        idx_738 < len_739;
                        idx_738++)  {
                            results_737[idx_738] = AccessCheckResult.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_741: string[] = ["results"];
                        const argsValues_742: any[] = [results_737];
                        ctx.invokeLocalMethodBefore("sendAccessCheckResults", argsNames_741, argsValues_742);
                        localApi.sendAccessCheckResults(results_737);
                        ctx.invokeLocalMethodAfter("sendAccessCheckResults", null, argsNames_741, argsValues_742);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiSafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiSafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_743: FastFutureContext): ClientApiSafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_743.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_743, changeParent: (uid: UUID): AFuture =>  {
                    const dataOut_745 = new DataInOut();
                    dataOut_745.writeByte(3);
                    const argsNames_747: string[] = ["uid"];
                    const argsValues_748: any[] = [uid];
                    sCtx_743.invokeRemoteMethodAfter("changeParent", null, argsNames_747, argsValues_748);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_745);
                    sCtx_743.sendToRemote(dataOut_745.toArray());
                    return AFuture.of();
                    
                }
                , changeAlias: (alias: UUID): AFuture =>  {
                    const dataOut_751 = new DataInOut();
                    dataOut_751.writeByte(4);
                    const argsNames_753: string[] = ["alias"];
                    const argsValues_754: any[] = [alias];
                    sCtx_743.invokeRemoteMethodAfter("changeAlias", null, argsNames_753, argsValues_754);
                    FastMeta.META_UUID.serialize(sCtx_743, alias, dataOut_751);
                    sCtx_743.sendToRemote(dataOut_751.toArray());
                    return AFuture.of();
                    
                }
                , newChild: (uid: UUID): AFuture =>  {
                    const dataOut_757 = new DataInOut();
                    dataOut_757.writeByte(5);
                    const argsNames_759: string[] = ["uid"];
                    const argsValues_760: any[] = [uid];
                    sCtx_743.invokeRemoteMethodAfter("newChild", null, argsNames_759, argsValues_760);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_757);
                    sCtx_743.sendToRemote(dataOut_757.toArray());
                    return AFuture.of();
                    
                }
                , sendMessages: (msg: Message[]): AFuture =>  {
                    const dataOut_763 = new DataInOut();
                    dataOut_763.writeByte(6);
                    const argsNames_765: string[] = ["msg"];
                    const argsValues_766: any[] = [msg];
                    sCtx_743.invokeRemoteMethodAfter("sendMessages", null, argsNames_765, argsValues_766);
                    SerializerPackNumber.INSTANCE.put(dataOut_763, msg.length);
                    for (const el_767 of msg)  {
                        Message.META.serialize(sCtx_743, el_767, dataOut_763);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_763.toArray());
                    return AFuture.of();
                    
                }
                , sendServerDescriptor: (serverDescriptor: ServerDescriptor): AFuture =>  {
                    const dataOut_770 = new DataInOut();
                    dataOut_770.writeByte(7);
                    const argsNames_772: string[] = ["serverDescriptor"];
                    const argsValues_773: any[] = [serverDescriptor];
                    sCtx_743.invokeRemoteMethodAfter("sendServerDescriptor", null, argsNames_772, argsValues_773);
                    ServerDescriptor.META.serialize(sCtx_743, serverDescriptor, dataOut_770);
                    sCtx_743.sendToRemote(dataOut_770.toArray());
                    return AFuture.of();
                    
                }
                , sendServerDescriptors: (serverDescriptors: ServerDescriptor[]): AFuture =>  {
                    const dataOut_776 = new DataInOut();
                    dataOut_776.writeByte(8);
                    const argsNames_778: string[] = ["serverDescriptors"];
                    const argsValues_779: any[] = [serverDescriptors];
                    sCtx_743.invokeRemoteMethodAfter("sendServerDescriptors", null, argsNames_778, argsValues_779);
                    SerializerPackNumber.INSTANCE.put(dataOut_776, serverDescriptors.length);
                    for (const el_780 of serverDescriptors)  {
                        ServerDescriptor.META.serialize(sCtx_743, el_780, dataOut_776);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_776.toArray());
                    return AFuture.of();
                    
                }
                , sendCloud: (uid: UUID, cloud: Cloud): AFuture =>  {
                    const dataOut_783 = new DataInOut();
                    dataOut_783.writeByte(9);
                    const argsNames_785: string[] = ["uid", "cloud"];
                    const argsValues_786: any[] = [uid, cloud];
                    sCtx_743.invokeRemoteMethodAfter("sendCloud", null, argsNames_785, argsValues_786);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_783);
                    Cloud.META.serialize(sCtx_743, cloud, dataOut_783);
                    sCtx_743.sendToRemote(dataOut_783.toArray());
                    return AFuture.of();
                    
                }
                , sendClouds: (clouds: UUIDAndCloud[]): AFuture =>  {
                    const dataOut_790 = new DataInOut();
                    dataOut_790.writeByte(10);
                    const argsNames_792: string[] = ["clouds"];
                    const argsValues_793: any[] = [clouds];
                    sCtx_743.invokeRemoteMethodAfter("sendClouds", null, argsNames_792, argsValues_793);
                    SerializerPackNumber.INSTANCE.put(dataOut_790, clouds.length);
                    for (const el_794 of clouds)  {
                        UUIDAndCloud.META.serialize(sCtx_743, el_794, dataOut_790);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_790.toArray());
                    return AFuture.of();
                    
                }
                , requestTelemetry: (): AFuture =>  {
                    const dataOut_797 = new DataInOut();
                    dataOut_797.writeByte(11);
                    const argsNames_799: string[] = [];
                    const argsValues_800: any[] = [];
                    sCtx_743.invokeRemoteMethodAfter("requestTelemetry", null, argsNames_799, argsValues_800);
                    sCtx_743.sendToRemote(dataOut_797.toArray());
                    return AFuture.of();
                    
                }
                , sendAccessGroups: (groups: AccessGroup[]): AFuture =>  {
                    const dataOut_802 = new DataInOut();
                    dataOut_802.writeByte(12);
                    const argsNames_804: string[] = ["groups"];
                    const argsValues_805: any[] = [groups];
                    sCtx_743.invokeRemoteMethodAfter("sendAccessGroups", null, argsNames_804, argsValues_805);
                    SerializerPackNumber.INSTANCE.put(dataOut_802, groups.length);
                    for (const el_806 of groups)  {
                        AccessGroup.META.serialize(sCtx_743, el_806, dataOut_802);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_802.toArray());
                    return AFuture.of();
                    
                }
                , sendAccessGroupForClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_809 = new DataInOut();
                    dataOut_809.writeByte(13);
                    const argsNames_811: string[] = ["uid", "groups"];
                    const argsValues_812: any[] = [uid, groups];
                    sCtx_743.invokeRemoteMethodAfter("sendAccessGroupForClient", null, argsNames_811, argsValues_812);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_809);
                    SerializerPackNumber.INSTANCE.put(dataOut_809, groups.length);
                    for (const el_814 of groups)  {
                        dataOut_809.writeLong(el_814);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_809.toArray());
                    return AFuture.of();
                    
                }
                , addItemsToAccessGroup: (id: number, groups: UUID[]): AFuture =>  {
                    const dataOut_817 = new DataInOut();
                    dataOut_817.writeByte(14);
                    const argsNames_819: string[] = ["id", "groups"];
                    const argsValues_820: any[] = [id, groups];
                    sCtx_743.invokeRemoteMethodAfter("addItemsToAccessGroup", null, argsNames_819, argsValues_820);
                    dataOut_817.writeLong(id);
                    SerializerPackNumber.INSTANCE.put(dataOut_817, groups.length);
                    for (const el_822 of groups)  {
                        FastMeta.META_UUID.serialize(sCtx_743, el_822, dataOut_817);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_817.toArray());
                    return AFuture.of();
                    
                }
                , removeItemsFromAccessGroup: (id: number, groups: UUID[]): AFuture =>  {
                    const dataOut_825 = new DataInOut();
                    dataOut_825.writeByte(15);
                    const argsNames_827: string[] = ["id", "groups"];
                    const argsValues_828: any[] = [id, groups];
                    sCtx_743.invokeRemoteMethodAfter("removeItemsFromAccessGroup", null, argsNames_827, argsValues_828);
                    dataOut_825.writeLong(id);
                    SerializerPackNumber.INSTANCE.put(dataOut_825, groups.length);
                    for (const el_830 of groups)  {
                        FastMeta.META_UUID.serialize(sCtx_743, el_830, dataOut_825);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_825.toArray());
                    return AFuture.of();
                    
                }
                , addAccessGroupsToClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_833 = new DataInOut();
                    dataOut_833.writeByte(16);
                    const argsNames_835: string[] = ["uid", "groups"];
                    const argsValues_836: any[] = [uid, groups];
                    sCtx_743.invokeRemoteMethodAfter("addAccessGroupsToClient", null, argsNames_835, argsValues_836);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_833);
                    SerializerPackNumber.INSTANCE.put(dataOut_833, groups.length);
                    for (const el_838 of groups)  {
                        dataOut_833.writeLong(el_838);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_833.toArray());
                    return AFuture.of();
                    
                }
                , removeAccessGroupsFromClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_841 = new DataInOut();
                    dataOut_841.writeByte(17);
                    const argsNames_843: string[] = ["uid", "groups"];
                    const argsValues_844: any[] = [uid, groups];
                    sCtx_743.invokeRemoteMethodAfter("removeAccessGroupsFromClient", null, argsNames_843, argsValues_844);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_841);
                    SerializerPackNumber.INSTANCE.put(dataOut_841, groups.length);
                    for (const el_846 of groups)  {
                        dataOut_841.writeLong(el_846);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_841.toArray());
                    return AFuture.of();
                    
                }
                , sendAllAccessedClients: (uid: UUID, accessedClients: UUID[]): AFuture =>  {
                    const dataOut_849 = new DataInOut();
                    dataOut_849.writeByte(18);
                    const argsNames_851: string[] = ["uid", "accessedClients"];
                    const argsValues_852: any[] = [uid, accessedClients];
                    sCtx_743.invokeRemoteMethodAfter("sendAllAccessedClients", null, argsNames_851, argsValues_852);
                    FastMeta.META_UUID.serialize(sCtx_743, uid, dataOut_849);
                    SerializerPackNumber.INSTANCE.put(dataOut_849, accessedClients.length);
                    for (const el_854 of accessedClients)  {
                        FastMeta.META_UUID.serialize(sCtx_743, el_854, dataOut_849);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_849.toArray());
                    return AFuture.of();
                    
                }
                , sendAccessCheckResults: (results: AccessCheckResult[]): AFuture =>  {
                    const dataOut_857 = new DataInOut();
                    dataOut_857.writeByte(19);
                    const argsNames_859: string[] = ["results"];
                    const argsValues_860: any[] = [results];
                    sCtx_743.invokeRemoteMethodAfter("sendAccessCheckResults", null, argsNames_859, argsValues_860);
                    SerializerPackNumber.INSTANCE.put(dataOut_857, results.length);
                    for (const el_861 of results)  {
                        AccessCheckResult.META.serialize(sCtx_743, el_861, dataOut_857);
                        
                    }
                    sCtx_743.sendToRemote(dataOut_857.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiSafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiSafeRemote ---
export interface ClientApiSafeRemote extends ClientApiSafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiSafeLocal ---
export abstract class ClientApiSafeLocal<RT extends ClientApiSafeRemote> implements ClientApiSafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract changeParent(uid: UUID): AFuture;
    public abstract changeAlias(alias: UUID): AFuture;
    public abstract newChild(uid: UUID): AFuture;
    public abstract sendMessages(msg: Message[]): AFuture;
    public abstract sendServerDescriptor(serverDescriptor: ServerDescriptor): AFuture;
    public abstract sendServerDescriptors(serverDescriptors: ServerDescriptor[]): AFuture;
    public abstract sendCloud(uid: UUID, cloud: Cloud): AFuture;
    public abstract sendClouds(clouds: UUIDAndCloud[]): AFuture;
    public abstract requestTelemetry(): AFuture;
    public abstract sendAccessGroups(groups: AccessGroup[]): AFuture;
    public abstract sendAccessGroupForClient(uid: UUID, groups: number[]): AFuture;
    public abstract addItemsToAccessGroup(id: number, groups: UUID[]): AFuture;
    public abstract removeItemsFromAccessGroup(id: number, groups: UUID[]): AFuture;
    public abstract addAccessGroupsToClient(uid: UUID, groups: number[]): AFuture;
    public abstract removeAccessGroupsFromClient(uid: UUID, groups: number[]): AFuture;
    public abstract sendAllAccessedClients(uid: UUID, accessedClients: UUID[]): AFuture;
    public abstract sendAccessCheckResults(results: AccessCheckResult[]): AFuture;
    
}
// --- Generated API Interface: AuthorizedApi ---
export interface AuthorizedApi  {
    backId(id: number): AFuture;
    ping(nextConnectMsDuration: number): AFuture;
    client(uid: UUID, stream: ClientApiStream): AFuture;
    sendMessage(msg: Message): AFuture;
    sendMessages(msg: Message[]): AFuture;
    createAccessGroup(owner: UUID, uids: UUID[]): ARFuture<number>;
    addToAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    removeFromAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    checkAccessForSendMessage(uid: UUID): AFuture;
    resolverServers(sid: number[]): AFuture;
    resolverClouds(uids: UUID[]): AFuture;
    getAccessGroups(uid: UUID): ARFuture<number[]>;
    getAccessGroup(groupId: number): ARFuture<AccessGroup>;
    getAllAccessedClients(uid: UUID): ARFuture<UUID[]>;
    checkAccessForSendMessage2(uid1: UUID, uid2: UUID): ARFuture<boolean>;
    sendTelemetry(telemetry: Telemetry): AFuture;
    requestAccessGroupsForClients(uids: UUID[]): AFuture;
    requestAccessGroupsItems(ids: number[]): AFuture;
    sendAccessGroupForClient(uid: UUID, groups: number[]): AFuture;
    addItemsToAccessGroup(id: number, groups: UUID[]): AFuture;
    removeItemsFromAccessGroup(id: number, groups: UUID[]): AFuture;
    addAccessGroupsToClient(uid: UUID, groups: number[]): AFuture;
    removeAccessGroupsFromClient(uid: UUID, groups: number[]): AFuture;
    requestAllAccessedClients(uids: UUID[]): AFuture;
    requestAccessCheck(requests: AccessCheckPair[]): AFuture;
    
}
export namespace AuthorizedApi  {
    export const META: FastMetaApi<AuthorizedApi, AuthorizedApiRemote> = new class implements FastMetaApi<AuthorizedApi, AuthorizedApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: AuthorizedApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let id_864: number;
                        id_864 = dataIn.readByte();
                        const argsNames_866: string[] = ["id"];
                        const argsValues_867: any[] = [id_864];
                        ctx.invokeLocalMethodBefore("backId", argsNames_866, argsValues_867);
                        localApi.backId(id_864);
                        ctx.invokeLocalMethodAfter("backId", null, argsNames_866, argsValues_867);
                        break;
                        
                    }
                    case 4:  {
                        let nextConnectMsDuration_869: number;
                        nextConnectMsDuration_869 = dataIn.readLong();
                        const argsNames_871: string[] = ["nextConnectMsDuration"];
                        const argsValues_872: any[] = [nextConnectMsDuration_869];
                        ctx.invokeLocalMethodBefore("ping", argsNames_871, argsValues_872);
                        localApi.ping(nextConnectMsDuration_869);
                        ctx.invokeLocalMethodAfter("ping", null, argsNames_871, argsValues_872);
                        break;
                        
                    }
                    case 5:  {
                        let uid_874: UUID;
                        let stream_875: ClientApiStream;
                        uid_874 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        stream_875 = ClientApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_878: string[] = ["uid", "stream"];
                        const argsValues_879: any[] = [uid_874, stream_875];
                        ctx.invokeLocalMethodBefore("client", argsNames_878, argsValues_879);
                        localApi.client(uid_874, stream_875);
                        ctx.invokeLocalMethodAfter("client", null, argsNames_878, argsValues_879);
                        break;
                        
                    }
                    case 6:  {
                        let msg_881: Message;
                        msg_881 = Message.META.deserialize(ctx, dataIn);
                        const argsNames_883: string[] = ["msg"];
                        const argsValues_884: any[] = [msg_881];
                        ctx.invokeLocalMethodBefore("sendMessage", argsNames_883, argsValues_884);
                        localApi.sendMessage(msg_881);
                        ctx.invokeLocalMethodAfter("sendMessage", null, argsNames_883, argsValues_884);
                        break;
                        
                    }
                    case 7:  {
                        let msg_886: Message[];
                        const len_888 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        msg_886 = new Array<Message>(len_888);
                        for (let idx_887 = 0;
                        idx_887 < len_888;
                        idx_887++)  {
                            msg_886[idx_887] = Message.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_890: string[] = ["msg"];
                        const argsValues_891: any[] = [msg_886];
                        ctx.invokeLocalMethodBefore("sendMessages", argsNames_890, argsValues_891);
                        localApi.sendMessages(msg_886);
                        ctx.invokeLocalMethodAfter("sendMessages", null, argsNames_890, argsValues_891);
                        break;
                        
                    }
                    case 8:  {
                        const reqId_892 = dataIn.readInt();
                        let owner_893: UUID;
                        let uids_894: UUID[];
                        owner_893 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_897 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_894 = new Array<UUID>(len_897);
                        for (let idx_896 = 0;
                        idx_896 < len_897;
                        idx_896++)  {
                            uids_894[idx_896] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_899: string[] = ["owner", "uids"];
                        const argsValues_900: any[] = [owner_893, uids_894];
                        ctx.invokeLocalMethodBefore("createAccessGroup", argsNames_899, argsValues_900);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.createAccessGroup(owner_893, uids_894);
                        ctx.invokeLocalMethodAfter("createAccessGroup", resultFuture, argsNames_899, argsValues_900);
                        resultFuture.to((v_902: number) =>  {
                            const data_901 = new DataInOut();
                            data_901.writeLong(v_902);
                            ctx.sendResultToRemote(reqId_892, data_901.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 9:  {
                        const reqId_904 = dataIn.readInt();
                        let groupId_905: number;
                        let uid_906: UUID;
                        groupId_905 = dataIn.readLong();
                        uid_906 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_909: string[] = ["groupId", "uid"];
                        const argsValues_910: any[] = [groupId_905, uid_906];
                        ctx.invokeLocalMethodBefore("addToAccessGroup", argsNames_909, argsValues_910);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.addToAccessGroup(groupId_905, uid_906);
                        ctx.invokeLocalMethodAfter("addToAccessGroup", resultFuture, argsNames_909, argsValues_910);
                        resultFuture.to((v_912: boolean) =>  {
                            const data_911 = new DataInOut();
                            data_911.writeBoolean(v_912);
                            ctx.sendResultToRemote(reqId_904, data_911.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 10:  {
                        const reqId_914 = dataIn.readInt();
                        let groupId_915: number;
                        let uid_916: UUID;
                        groupId_915 = dataIn.readLong();
                        uid_916 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_919: string[] = ["groupId", "uid"];
                        const argsValues_920: any[] = [groupId_915, uid_916];
                        ctx.invokeLocalMethodBefore("removeFromAccessGroup", argsNames_919, argsValues_920);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.removeFromAccessGroup(groupId_915, uid_916);
                        ctx.invokeLocalMethodAfter("removeFromAccessGroup", resultFuture, argsNames_919, argsValues_920);
                        resultFuture.to((v_922: boolean) =>  {
                            const data_921 = new DataInOut();
                            data_921.writeBoolean(v_922);
                            ctx.sendResultToRemote(reqId_914, data_921.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 11:  {
                        let uid_925: UUID;
                        uid_925 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_927: string[] = ["uid"];
                        const argsValues_928: any[] = [uid_925];
                        ctx.invokeLocalMethodBefore("checkAccessForSendMessage", argsNames_927, argsValues_928);
                        localApi.checkAccessForSendMessage(uid_925);
                        ctx.invokeLocalMethodAfter("checkAccessForSendMessage", null, argsNames_927, argsValues_928);
                        break;
                        
                    }
                    case 12:  {
                        let sid_930: number[];
                        const len_932 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        sid_930 = new Array<number>(len_932);
                        for (let idx_931 = 0;
                        idx_931 < len_932;
                        idx_931++)  {
                            sid_930[idx_931] = dataIn.readShort();
                            
                        }
                        const argsNames_934: string[] = ["sid"];
                        const argsValues_935: any[] = [sid_930];
                        ctx.invokeLocalMethodBefore("resolverServers", argsNames_934, argsValues_935);
                        localApi.resolverServers(sid_930);
                        ctx.invokeLocalMethodAfter("resolverServers", null, argsNames_934, argsValues_935);
                        break;
                        
                    }
                    case 13:  {
                        let uids_937: UUID[];
                        const len_939 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_937 = new Array<UUID>(len_939);
                        for (let idx_938 = 0;
                        idx_938 < len_939;
                        idx_938++)  {
                            uids_937[idx_938] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_941: string[] = ["uids"];
                        const argsValues_942: any[] = [uids_937];
                        ctx.invokeLocalMethodBefore("resolverClouds", argsNames_941, argsValues_942);
                        localApi.resolverClouds(uids_937);
                        ctx.invokeLocalMethodAfter("resolverClouds", null, argsNames_941, argsValues_942);
                        break;
                        
                    }
                    case 14:  {
                        const reqId_943 = dataIn.readInt();
                        let uid_944: UUID;
                        uid_944 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_946: string[] = ["uid"];
                        const argsValues_947: any[] = [uid_944];
                        ctx.invokeLocalMethodBefore("getAccessGroups", argsNames_946, argsValues_947);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAccessGroups(uid_944);
                        ctx.invokeLocalMethodAfter("getAccessGroups", resultFuture, argsNames_946, argsValues_947);
                        resultFuture.to((v_949: number[]) =>  {
                            const data_948 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_948, v_949.length);
                            for (const el_950 of v_949)  {
                                data_948.writeLong(el_950);
                                
                            }
                            ctx.sendResultToRemote(reqId_943, data_948.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 15:  {
                        const reqId_952 = dataIn.readInt();
                        let groupId_953: number;
                        groupId_953 = dataIn.readLong();
                        const argsNames_955: string[] = ["groupId"];
                        const argsValues_956: any[] = [groupId_953];
                        ctx.invokeLocalMethodBefore("getAccessGroup", argsNames_955, argsValues_956);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAccessGroup(groupId_953);
                        ctx.invokeLocalMethodAfter("getAccessGroup", resultFuture, argsNames_955, argsValues_956);
                        resultFuture.to((v_958: AccessGroup) =>  {
                            const data_957 = new DataInOut();
                            AccessGroup.META.serialize(ctx, v_958, data_957);
                            ctx.sendResultToRemote(reqId_952, data_957.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 16:  {
                        const reqId_960 = dataIn.readInt();
                        let uid_961: UUID;
                        uid_961 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_963: string[] = ["uid"];
                        const argsValues_964: any[] = [uid_961];
                        ctx.invokeLocalMethodBefore("getAllAccessedClients", argsNames_963, argsValues_964);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAllAccessedClients(uid_961);
                        ctx.invokeLocalMethodAfter("getAllAccessedClients", resultFuture, argsNames_963, argsValues_964);
                        resultFuture.to((v_966: UUID[]) =>  {
                            const data_965 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_965, v_966.length);
                            for (const el_967 of v_966)  {
                                FastMeta.META_UUID.serialize(ctx, el_967, data_965);
                                
                            }
                            ctx.sendResultToRemote(reqId_960, data_965.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 17:  {
                        const reqId_969 = dataIn.readInt();
                        let uid1_970: UUID;
                        let uid2_971: UUID;
                        uid1_970 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        uid2_971 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_974: string[] = ["uid1", "uid2"];
                        const argsValues_975: any[] = [uid1_970, uid2_971];
                        ctx.invokeLocalMethodBefore("checkAccessForSendMessage2", argsNames_974, argsValues_975);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.checkAccessForSendMessage2(uid1_970, uid2_971);
                        ctx.invokeLocalMethodAfter("checkAccessForSendMessage2", resultFuture, argsNames_974, argsValues_975);
                        resultFuture.to((v_977: boolean) =>  {
                            const data_976 = new DataInOut();
                            data_976.writeBoolean(v_977);
                            ctx.sendResultToRemote(reqId_969, data_976.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 18:  {
                        let telemetry_980: Telemetry;
                        telemetry_980 = Telemetry.META.deserialize(ctx, dataIn);
                        const argsNames_982: string[] = ["telemetry"];
                        const argsValues_983: any[] = [telemetry_980];
                        ctx.invokeLocalMethodBefore("sendTelemetry", argsNames_982, argsValues_983);
                        localApi.sendTelemetry(telemetry_980);
                        ctx.invokeLocalMethodAfter("sendTelemetry", null, argsNames_982, argsValues_983);
                        break;
                        
                    }
                    case 19:  {
                        let uids_985: UUID[];
                        const len_987 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_985 = new Array<UUID>(len_987);
                        for (let idx_986 = 0;
                        idx_986 < len_987;
                        idx_986++)  {
                            uids_985[idx_986] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_989: string[] = ["uids"];
                        const argsValues_990: any[] = [uids_985];
                        ctx.invokeLocalMethodBefore("requestAccessGroupsForClients", argsNames_989, argsValues_990);
                        localApi.requestAccessGroupsForClients(uids_985);
                        ctx.invokeLocalMethodAfter("requestAccessGroupsForClients", null, argsNames_989, argsValues_990);
                        break;
                        
                    }
                    case 20:  {
                        let ids_992: number[];
                        const len_994 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        ids_992 = new Array<number>(len_994);
                        for (let idx_993 = 0;
                        idx_993 < len_994;
                        idx_993++)  {
                            ids_992[idx_993] = dataIn.readLong();
                            
                        }
                        const argsNames_996: string[] = ["ids"];
                        const argsValues_997: any[] = [ids_992];
                        ctx.invokeLocalMethodBefore("requestAccessGroupsItems", argsNames_996, argsValues_997);
                        localApi.requestAccessGroupsItems(ids_992);
                        ctx.invokeLocalMethodAfter("requestAccessGroupsItems", null, argsNames_996, argsValues_997);
                        break;
                        
                    }
                    case 22:  {
                        let uid_999: UUID;
                        let groups_1000: number[];
                        uid_999 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_1003 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_1000 = new Array<number>(len_1003);
                        for (let idx_1002 = 0;
                        idx_1002 < len_1003;
                        idx_1002++)  {
                            groups_1000[idx_1002] = dataIn.readLong();
                            
                        }
                        const argsNames_1005: string[] = ["uid", "groups"];
                        const argsValues_1006: any[] = [uid_999, groups_1000];
                        ctx.invokeLocalMethodBefore("sendAccessGroupForClient", argsNames_1005, argsValues_1006);
                        localApi.sendAccessGroupForClient(uid_999, groups_1000);
                        ctx.invokeLocalMethodAfter("sendAccessGroupForClient", null, argsNames_1005, argsValues_1006);
                        break;
                        
                    }
                    case 23:  {
                        let id_1008: number;
                        let groups_1009: UUID[];
                        id_1008 = dataIn.readLong();
                        const len_1012 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_1009 = new Array<UUID>(len_1012);
                        for (let idx_1011 = 0;
                        idx_1011 < len_1012;
                        idx_1011++)  {
                            groups_1009[idx_1011] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_1014: string[] = ["id", "groups"];
                        const argsValues_1015: any[] = [id_1008, groups_1009];
                        ctx.invokeLocalMethodBefore("addItemsToAccessGroup", argsNames_1014, argsValues_1015);
                        localApi.addItemsToAccessGroup(id_1008, groups_1009);
                        ctx.invokeLocalMethodAfter("addItemsToAccessGroup", null, argsNames_1014, argsValues_1015);
                        break;
                        
                    }
                    case 24:  {
                        let id_1017: number;
                        let groups_1018: UUID[];
                        id_1017 = dataIn.readLong();
                        const len_1021 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_1018 = new Array<UUID>(len_1021);
                        for (let idx_1020 = 0;
                        idx_1020 < len_1021;
                        idx_1020++)  {
                            groups_1018[idx_1020] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_1023: string[] = ["id", "groups"];
                        const argsValues_1024: any[] = [id_1017, groups_1018];
                        ctx.invokeLocalMethodBefore("removeItemsFromAccessGroup", argsNames_1023, argsValues_1024);
                        localApi.removeItemsFromAccessGroup(id_1017, groups_1018);
                        ctx.invokeLocalMethodAfter("removeItemsFromAccessGroup", null, argsNames_1023, argsValues_1024);
                        break;
                        
                    }
                    case 25:  {
                        let uid_1026: UUID;
                        let groups_1027: number[];
                        uid_1026 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_1030 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_1027 = new Array<number>(len_1030);
                        for (let idx_1029 = 0;
                        idx_1029 < len_1030;
                        idx_1029++)  {
                            groups_1027[idx_1029] = dataIn.readLong();
                            
                        }
                        const argsNames_1032: string[] = ["uid", "groups"];
                        const argsValues_1033: any[] = [uid_1026, groups_1027];
                        ctx.invokeLocalMethodBefore("addAccessGroupsToClient", argsNames_1032, argsValues_1033);
                        localApi.addAccessGroupsToClient(uid_1026, groups_1027);
                        ctx.invokeLocalMethodAfter("addAccessGroupsToClient", null, argsNames_1032, argsValues_1033);
                        break;
                        
                    }
                    case 26:  {
                        let uid_1035: UUID;
                        let groups_1036: number[];
                        uid_1035 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const len_1039 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        groups_1036 = new Array<number>(len_1039);
                        for (let idx_1038 = 0;
                        idx_1038 < len_1039;
                        idx_1038++)  {
                            groups_1036[idx_1038] = dataIn.readLong();
                            
                        }
                        const argsNames_1041: string[] = ["uid", "groups"];
                        const argsValues_1042: any[] = [uid_1035, groups_1036];
                        ctx.invokeLocalMethodBefore("removeAccessGroupsFromClient", argsNames_1041, argsValues_1042);
                        localApi.removeAccessGroupsFromClient(uid_1035, groups_1036);
                        ctx.invokeLocalMethodAfter("removeAccessGroupsFromClient", null, argsNames_1041, argsValues_1042);
                        break;
                        
                    }
                    case 27:  {
                        let uids_1044: UUID[];
                        const len_1046 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        uids_1044 = new Array<UUID>(len_1046);
                        for (let idx_1045 = 0;
                        idx_1045 < len_1046;
                        idx_1045++)  {
                            uids_1044[idx_1045] = FastMeta.META_UUID.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_1048: string[] = ["uids"];
                        const argsValues_1049: any[] = [uids_1044];
                        ctx.invokeLocalMethodBefore("requestAllAccessedClients", argsNames_1048, argsValues_1049);
                        localApi.requestAllAccessedClients(uids_1044);
                        ctx.invokeLocalMethodAfter("requestAllAccessedClients", null, argsNames_1048, argsValues_1049);
                        break;
                        
                    }
                    case 28:  {
                        let requests_1051: AccessCheckPair[];
                        const len_1053 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        requests_1051 = new Array<AccessCheckPair>(len_1053);
                        for (let idx_1052 = 0;
                        idx_1052 < len_1053;
                        idx_1052++)  {
                            requests_1051[idx_1052] = AccessCheckPair.META.deserialize(ctx, dataIn);
                            
                        }
                        const argsNames_1055: string[] = ["requests"];
                        const argsValues_1056: any[] = [requests_1051];
                        ctx.invokeLocalMethodBefore("requestAccessCheck", argsNames_1055, argsValues_1056);
                        localApi.requestAccessCheck(requests_1051);
                        ctx.invokeLocalMethodAfter("requestAccessCheck", null, argsNames_1055, argsValues_1056);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<AuthorizedApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: AuthorizedApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1057: FastFutureContext): AuthorizedApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1057.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1057, backId: (id: number): AFuture =>  {
                    const dataOut_1059 = new DataInOut();
                    dataOut_1059.writeByte(3);
                    const argsNames_1061: string[] = ["id"];
                    const argsValues_1062: any[] = [id];
                    sCtx_1057.invokeRemoteMethodAfter("backId", null, argsNames_1061, argsValues_1062);
                    dataOut_1059.writeByte(id);
                    sCtx_1057.sendToRemote(dataOut_1059.toArray());
                    return AFuture.of();
                    
                }
                , ping: (nextConnectMsDuration: number): AFuture =>  {
                    const dataOut_1065 = new DataInOut();
                    dataOut_1065.writeByte(4);
                    const argsNames_1067: string[] = ["nextConnectMsDuration"];
                    const argsValues_1068: any[] = [nextConnectMsDuration];
                    sCtx_1057.invokeRemoteMethodAfter("ping", null, argsNames_1067, argsValues_1068);
                    dataOut_1065.writeLong(nextConnectMsDuration);
                    sCtx_1057.sendToRemote(dataOut_1065.toArray());
                    return AFuture.of();
                    
                }
                , client: (uid: UUID, stream: ClientApiStream): AFuture =>  {
                    const dataOut_1071 = new DataInOut();
                    dataOut_1071.writeByte(5);
                    const argsNames_1073: string[] = ["uid", "stream"];
                    const argsValues_1074: any[] = [uid, stream];
                    sCtx_1057.invokeRemoteMethodAfter("client", null, argsNames_1073, argsValues_1074);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1071);
                    ClientApiStream.META.serialize(sCtx_1057, stream, dataOut_1071);
                    sCtx_1057.sendToRemote(dataOut_1071.toArray());
                    return AFuture.of();
                    
                }
                , sendMessage: (msg: Message): AFuture =>  {
                    const dataOut_1078 = new DataInOut();
                    dataOut_1078.writeByte(6);
                    const argsNames_1080: string[] = ["msg"];
                    const argsValues_1081: any[] = [msg];
                    sCtx_1057.invokeRemoteMethodAfter("sendMessage", null, argsNames_1080, argsValues_1081);
                    Message.META.serialize(sCtx_1057, msg, dataOut_1078);
                    sCtx_1057.sendToRemote(dataOut_1078.toArray());
                    return AFuture.of();
                    
                }
                , sendMessages: (msg: Message[]): AFuture =>  {
                    const dataOut_1084 = new DataInOut();
                    dataOut_1084.writeByte(7);
                    const argsNames_1086: string[] = ["msg"];
                    const argsValues_1087: any[] = [msg];
                    sCtx_1057.invokeRemoteMethodAfter("sendMessages", null, argsNames_1086, argsValues_1087);
                    SerializerPackNumber.INSTANCE.put(dataOut_1084, msg.length);
                    for (const el_1088 of msg)  {
                        Message.META.serialize(sCtx_1057, el_1088, dataOut_1084);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1084.toArray());
                    return AFuture.of();
                    
                }
                , createAccessGroup: (owner: UUID, uids: UUID[]): ARFuture<number> =>  {
                    const dataOut_1091 = new DataInOut();
                    dataOut_1091.writeByte(8);
                    const argsNames_1093: string[] = ["owner", "uids"];
                    const argsValues_1094: any[] = [owner, uids];
                    const result_1092 = ARFuture.of<number>();
                    sCtx_1057.invokeRemoteMethodAfter("createAccessGroup", result_1092, argsNames_1093, argsValues_1094);
                    const reqId_1090 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1092 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1092.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1091.writeInt(reqId_1090);
                    FastMeta.META_UUID.serialize(sCtx_1057, owner, dataOut_1091);
                    SerializerPackNumber.INSTANCE.put(dataOut_1091, uids.length);
                    for (const el_1096 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1096, dataOut_1091);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1091.toArray());
                    return result_1092;
                    
                }
                , addToAccessGroup: (groupId: number, uid: UUID): ARFuture<boolean> =>  {
                    const dataOut_1099 = new DataInOut();
                    dataOut_1099.writeByte(9);
                    const argsNames_1101: string[] = ["groupId", "uid"];
                    const argsValues_1102: any[] = [groupId, uid];
                    const result_1100 = ARFuture.of<boolean>();
                    sCtx_1057.invokeRemoteMethodAfter("addToAccessGroup", result_1100, argsNames_1101, argsValues_1102);
                    const reqId_1098 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1100 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1100.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1099.writeInt(reqId_1098);
                    dataOut_1099.writeLong(groupId);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1099);
                    sCtx_1057.sendToRemote(dataOut_1099.toArray());
                    return result_1100;
                    
                }
                , removeFromAccessGroup: (groupId: number, uid: UUID): ARFuture<boolean> =>  {
                    const dataOut_1106 = new DataInOut();
                    dataOut_1106.writeByte(10);
                    const argsNames_1108: string[] = ["groupId", "uid"];
                    const argsValues_1109: any[] = [groupId, uid];
                    const result_1107 = ARFuture.of<boolean>();
                    sCtx_1057.invokeRemoteMethodAfter("removeFromAccessGroup", result_1107, argsNames_1108, argsValues_1109);
                    const reqId_1105 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1107 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1107.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1106.writeInt(reqId_1105);
                    dataOut_1106.writeLong(groupId);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1106);
                    sCtx_1057.sendToRemote(dataOut_1106.toArray());
                    return result_1107;
                    
                }
                , checkAccessForSendMessage: (uid: UUID): AFuture =>  {
                    const dataOut_1113 = new DataInOut();
                    dataOut_1113.writeByte(11);
                    const argsNames_1115: string[] = ["uid"];
                    const argsValues_1116: any[] = [uid];
                    sCtx_1057.invokeRemoteMethodAfter("checkAccessForSendMessage", null, argsNames_1115, argsValues_1116);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1113);
                    sCtx_1057.sendToRemote(dataOut_1113.toArray());
                    return AFuture.of();
                    
                }
                , resolverServers: (sid: number[]): AFuture =>  {
                    const dataOut_1119 = new DataInOut();
                    dataOut_1119.writeByte(12);
                    const argsNames_1121: string[] = ["sid"];
                    const argsValues_1122: any[] = [sid];
                    sCtx_1057.invokeRemoteMethodAfter("resolverServers", null, argsNames_1121, argsValues_1122);
                    SerializerPackNumber.INSTANCE.put(dataOut_1119, sid.length);
                    for (const el_1123 of sid)  {
                        dataOut_1119.writeShort(el_1123);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1119.toArray());
                    return AFuture.of();
                    
                }
                , resolverClouds: (uids: UUID[]): AFuture =>  {
                    const dataOut_1126 = new DataInOut();
                    dataOut_1126.writeByte(13);
                    const argsNames_1128: string[] = ["uids"];
                    const argsValues_1129: any[] = [uids];
                    sCtx_1057.invokeRemoteMethodAfter("resolverClouds", null, argsNames_1128, argsValues_1129);
                    SerializerPackNumber.INSTANCE.put(dataOut_1126, uids.length);
                    for (const el_1130 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1130, dataOut_1126);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1126.toArray());
                    return AFuture.of();
                    
                }
                , getAccessGroups: (uid: UUID): ARFuture<number[]> =>  {
                    const dataOut_1133 = new DataInOut();
                    dataOut_1133.writeByte(14);
                    const argsNames_1135: string[] = ["uid"];
                    const argsValues_1136: any[] = [uid];
                    const result_1134 = ARFuture.of<number[]>();
                    sCtx_1057.invokeRemoteMethodAfter("getAccessGroups", result_1134, argsNames_1135, argsValues_1136);
                    const reqId_1132 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1134 as ARFuture<number[]>).tryDone(AllCustomMeta.META_ARRAY_long.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1134.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1133.writeInt(reqId_1132);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1133);
                    sCtx_1057.sendToRemote(dataOut_1133.toArray());
                    return result_1134;
                    
                }
                , getAccessGroup: (groupId: number): ARFuture<AccessGroup> =>  {
                    const dataOut_1139 = new DataInOut();
                    dataOut_1139.writeByte(15);
                    const argsNames_1141: string[] = ["groupId"];
                    const argsValues_1142: any[] = [groupId];
                    const result_1140 = ARFuture.of<AccessGroup>();
                    sCtx_1057.invokeRemoteMethodAfter("getAccessGroup", result_1140, argsNames_1141, argsValues_1142);
                    const reqId_1138 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1140 as ARFuture<AccessGroup>).tryDone(AccessGroup.META.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1140.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1139.writeInt(reqId_1138);
                    dataOut_1139.writeLong(groupId);
                    sCtx_1057.sendToRemote(dataOut_1139.toArray());
                    return result_1140;
                    
                }
                , getAllAccessedClients: (uid: UUID): ARFuture<UUID[]> =>  {
                    const dataOut_1145 = new DataInOut();
                    dataOut_1145.writeByte(16);
                    const argsNames_1147: string[] = ["uid"];
                    const argsValues_1148: any[] = [uid];
                    const result_1146 = ARFuture.of<UUID[]>();
                    sCtx_1057.invokeRemoteMethodAfter("getAllAccessedClients", result_1146, argsNames_1147, argsValues_1148);
                    const reqId_1144 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1146 as ARFuture<UUID[]>).tryDone(AllCustomMeta.META_ARRAY_UUID.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1146.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1145.writeInt(reqId_1144);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1145);
                    sCtx_1057.sendToRemote(dataOut_1145.toArray());
                    return result_1146;
                    
                }
                , checkAccessForSendMessage2: (uid1: UUID, uid2: UUID): ARFuture<boolean> =>  {
                    const dataOut_1151 = new DataInOut();
                    dataOut_1151.writeByte(17);
                    const argsNames_1153: string[] = ["uid1", "uid2"];
                    const argsValues_1154: any[] = [uid1, uid2];
                    const result_1152 = ARFuture.of<boolean>();
                    sCtx_1057.invokeRemoteMethodAfter("checkAccessForSendMessage2", result_1152, argsNames_1153, argsValues_1154);
                    const reqId_1150 = sCtx_1057.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1152 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1057, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1152.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1151.writeInt(reqId_1150);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid1, dataOut_1151);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid2, dataOut_1151);
                    sCtx_1057.sendToRemote(dataOut_1151.toArray());
                    return result_1152;
                    
                }
                , sendTelemetry: (telemetry: Telemetry): AFuture =>  {
                    const dataOut_1158 = new DataInOut();
                    dataOut_1158.writeByte(18);
                    const argsNames_1160: string[] = ["telemetry"];
                    const argsValues_1161: any[] = [telemetry];
                    sCtx_1057.invokeRemoteMethodAfter("sendTelemetry", null, argsNames_1160, argsValues_1161);
                    Telemetry.META.serialize(sCtx_1057, telemetry, dataOut_1158);
                    sCtx_1057.sendToRemote(dataOut_1158.toArray());
                    return AFuture.of();
                    
                }
                , requestAccessGroupsForClients: (uids: UUID[]): AFuture =>  {
                    const dataOut_1164 = new DataInOut();
                    dataOut_1164.writeByte(19);
                    const argsNames_1166: string[] = ["uids"];
                    const argsValues_1167: any[] = [uids];
                    sCtx_1057.invokeRemoteMethodAfter("requestAccessGroupsForClients", null, argsNames_1166, argsValues_1167);
                    SerializerPackNumber.INSTANCE.put(dataOut_1164, uids.length);
                    for (const el_1168 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1168, dataOut_1164);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1164.toArray());
                    return AFuture.of();
                    
                }
                , requestAccessGroupsItems: (ids: number[]): AFuture =>  {
                    const dataOut_1171 = new DataInOut();
                    dataOut_1171.writeByte(20);
                    const argsNames_1173: string[] = ["ids"];
                    const argsValues_1174: any[] = [ids];
                    sCtx_1057.invokeRemoteMethodAfter("requestAccessGroupsItems", null, argsNames_1173, argsValues_1174);
                    SerializerPackNumber.INSTANCE.put(dataOut_1171, ids.length);
                    for (const el_1175 of ids)  {
                        dataOut_1171.writeLong(el_1175);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1171.toArray());
                    return AFuture.of();
                    
                }
                , sendAccessGroupForClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_1178 = new DataInOut();
                    dataOut_1178.writeByte(22);
                    const argsNames_1180: string[] = ["uid", "groups"];
                    const argsValues_1181: any[] = [uid, groups];
                    sCtx_1057.invokeRemoteMethodAfter("sendAccessGroupForClient", null, argsNames_1180, argsValues_1181);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1178);
                    SerializerPackNumber.INSTANCE.put(dataOut_1178, groups.length);
                    for (const el_1183 of groups)  {
                        dataOut_1178.writeLong(el_1183);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1178.toArray());
                    return AFuture.of();
                    
                }
                , addItemsToAccessGroup: (id: number, groups: UUID[]): AFuture =>  {
                    const dataOut_1186 = new DataInOut();
                    dataOut_1186.writeByte(23);
                    const argsNames_1188: string[] = ["id", "groups"];
                    const argsValues_1189: any[] = [id, groups];
                    sCtx_1057.invokeRemoteMethodAfter("addItemsToAccessGroup", null, argsNames_1188, argsValues_1189);
                    dataOut_1186.writeLong(id);
                    SerializerPackNumber.INSTANCE.put(dataOut_1186, groups.length);
                    for (const el_1191 of groups)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1191, dataOut_1186);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1186.toArray());
                    return AFuture.of();
                    
                }
                , removeItemsFromAccessGroup: (id: number, groups: UUID[]): AFuture =>  {
                    const dataOut_1194 = new DataInOut();
                    dataOut_1194.writeByte(24);
                    const argsNames_1196: string[] = ["id", "groups"];
                    const argsValues_1197: any[] = [id, groups];
                    sCtx_1057.invokeRemoteMethodAfter("removeItemsFromAccessGroup", null, argsNames_1196, argsValues_1197);
                    dataOut_1194.writeLong(id);
                    SerializerPackNumber.INSTANCE.put(dataOut_1194, groups.length);
                    for (const el_1199 of groups)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1199, dataOut_1194);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1194.toArray());
                    return AFuture.of();
                    
                }
                , addAccessGroupsToClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_1202 = new DataInOut();
                    dataOut_1202.writeByte(25);
                    const argsNames_1204: string[] = ["uid", "groups"];
                    const argsValues_1205: any[] = [uid, groups];
                    sCtx_1057.invokeRemoteMethodAfter("addAccessGroupsToClient", null, argsNames_1204, argsValues_1205);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1202);
                    SerializerPackNumber.INSTANCE.put(dataOut_1202, groups.length);
                    for (const el_1207 of groups)  {
                        dataOut_1202.writeLong(el_1207);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1202.toArray());
                    return AFuture.of();
                    
                }
                , removeAccessGroupsFromClient: (uid: UUID, groups: number[]): AFuture =>  {
                    const dataOut_1210 = new DataInOut();
                    dataOut_1210.writeByte(26);
                    const argsNames_1212: string[] = ["uid", "groups"];
                    const argsValues_1213: any[] = [uid, groups];
                    sCtx_1057.invokeRemoteMethodAfter("removeAccessGroupsFromClient", null, argsNames_1212, argsValues_1213);
                    FastMeta.META_UUID.serialize(sCtx_1057, uid, dataOut_1210);
                    SerializerPackNumber.INSTANCE.put(dataOut_1210, groups.length);
                    for (const el_1215 of groups)  {
                        dataOut_1210.writeLong(el_1215);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1210.toArray());
                    return AFuture.of();
                    
                }
                , requestAllAccessedClients: (uids: UUID[]): AFuture =>  {
                    const dataOut_1218 = new DataInOut();
                    dataOut_1218.writeByte(27);
                    const argsNames_1220: string[] = ["uids"];
                    const argsValues_1221: any[] = [uids];
                    sCtx_1057.invokeRemoteMethodAfter("requestAllAccessedClients", null, argsNames_1220, argsValues_1221);
                    SerializerPackNumber.INSTANCE.put(dataOut_1218, uids.length);
                    for (const el_1222 of uids)  {
                        FastMeta.META_UUID.serialize(sCtx_1057, el_1222, dataOut_1218);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1218.toArray());
                    return AFuture.of();
                    
                }
                , requestAccessCheck: (requests: AccessCheckPair[]): AFuture =>  {
                    const dataOut_1225 = new DataInOut();
                    dataOut_1225.writeByte(28);
                    const argsNames_1227: string[] = ["requests"];
                    const argsValues_1228: any[] = [requests];
                    sCtx_1057.invokeRemoteMethodAfter("requestAccessCheck", null, argsNames_1227, argsValues_1228);
                    SerializerPackNumber.INSTANCE.put(dataOut_1225, requests.length);
                    for (const el_1229 of requests)  {
                        AccessCheckPair.META.serialize(sCtx_1057, el_1229, dataOut_1225);
                        
                    }
                    sCtx_1057.sendToRemote(dataOut_1225.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as AuthorizedApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: AuthorizedApiRemote ---
export interface AuthorizedApiRemote extends AuthorizedApi, RemoteApi  {
    
}
// --- Generated API Local Class: AuthorizedApiLocal ---
export abstract class AuthorizedApiLocal<RT extends AuthorizedApiRemote> implements AuthorizedApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract backId(id: number): AFuture;
    public abstract ping(nextConnectMsDuration: number): AFuture;
    public abstract client(uid: UUID, stream: ClientApiStream): AFuture;
    public abstract sendMessage(msg: Message): AFuture;
    public abstract sendMessages(msg: Message[]): AFuture;
    public abstract createAccessGroup(owner: UUID, uids: UUID[]): ARFuture<number>;
    public abstract addToAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    public abstract removeFromAccessGroup(groupId: number, uid: UUID): ARFuture<boolean>;
    public abstract checkAccessForSendMessage(uid: UUID): AFuture;
    public abstract resolverServers(sid: number[]): AFuture;
    public abstract resolverClouds(uids: UUID[]): AFuture;
    public abstract getAccessGroups(uid: UUID): ARFuture<number[]>;
    public abstract getAccessGroup(groupId: number): ARFuture<AccessGroup>;
    public abstract getAllAccessedClients(uid: UUID): ARFuture<UUID[]>;
    public abstract checkAccessForSendMessage2(uid1: UUID, uid2: UUID): ARFuture<boolean>;
    public abstract sendTelemetry(telemetry: Telemetry): AFuture;
    public abstract requestAccessGroupsForClients(uids: UUID[]): AFuture;
    public abstract requestAccessGroupsItems(ids: number[]): AFuture;
    public abstract sendAccessGroupForClient(uid: UUID, groups: number[]): AFuture;
    public abstract addItemsToAccessGroup(id: number, groups: UUID[]): AFuture;
    public abstract removeItemsFromAccessGroup(id: number, groups: UUID[]): AFuture;
    public abstract addAccessGroupsToClient(uid: UUID, groups: number[]): AFuture;
    public abstract removeAccessGroupsFromClient(uid: UUID, groups: number[]): AFuture;
    public abstract requestAllAccessedClients(uids: UUID[]): AFuture;
    public abstract requestAccessCheck(requests: AccessCheckPair[]): AFuture;
    
}
// --- Generated API Interface: LoginApi ---
export interface LoginApi  {
    getTimeUTC(): ARFuture<number>;
    loginByUID(uid: UUID, data: LoginStream): AFuture;
    loginByAlias(alias: UUID, data: LoginStream): AFuture;
    
}
export namespace LoginApi  {
    export const META: FastMetaApi<LoginApi, LoginApiRemote> = new class implements FastMetaApi<LoginApi, LoginApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: LoginApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_1231 = dataIn.readInt();
                        const argsNames_1232: string[] = [];
                        const argsValues_1233: any[] = [];
                        ctx.invokeLocalMethodBefore("getTimeUTC", argsNames_1232, argsValues_1233);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getTimeUTC();
                        ctx.invokeLocalMethodAfter("getTimeUTC", resultFuture, argsNames_1232, argsValues_1233);
                        resultFuture.to((v_1235: number) =>  {
                            const data_1234 = new DataInOut();
                            data_1234.writeLong(v_1235);
                            ctx.sendResultToRemote(reqId_1231, data_1234.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let uid_1238: UUID;
                        let data_1239: LoginStream;
                        uid_1238 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        data_1239 = LoginStream.META.deserialize(ctx, dataIn);
                        const argsNames_1242: string[] = ["uid", "data"];
                        const argsValues_1243: any[] = [uid_1238, data_1239];
                        ctx.invokeLocalMethodBefore("loginByUID", argsNames_1242, argsValues_1243);
                        localApi.loginByUID(uid_1238, data_1239);
                        ctx.invokeLocalMethodAfter("loginByUID", null, argsNames_1242, argsValues_1243);
                        break;
                        
                    }
                    case 5:  {
                        let alias_1245: UUID;
                        let data_1246: LoginStream;
                        alias_1245 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        data_1246 = LoginStream.META.deserialize(ctx, dataIn);
                        const argsNames_1249: string[] = ["alias", "data"];
                        const argsValues_1250: any[] = [alias_1245, data_1246];
                        ctx.invokeLocalMethodBefore("loginByAlias", argsNames_1249, argsValues_1250);
                        localApi.loginByAlias(alias_1245, data_1246);
                        ctx.invokeLocalMethodAfter("loginByAlias", null, argsNames_1249, argsValues_1250);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<LoginApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: LoginApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1251: FastFutureContext): LoginApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1251.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1251, getTimeUTC: (): ARFuture<number> =>  {
                    const dataOut_1253 = new DataInOut();
                    dataOut_1253.writeByte(3);
                    const argsNames_1255: string[] = [];
                    const argsValues_1256: any[] = [];
                    const result_1254 = ARFuture.of<number>();
                    sCtx_1251.invokeRemoteMethodAfter("getTimeUTC", result_1254, argsNames_1255, argsValues_1256);
                    const reqId_1252 = sCtx_1251.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1254 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_1251, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1254.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1253.writeInt(reqId_1252);
                    sCtx_1251.sendToRemote(dataOut_1253.toArray());
                    return result_1254;
                    
                }
                , loginByUID: (uid: UUID, data: LoginStream): AFuture =>  {
                    const dataOut_1258 = new DataInOut();
                    dataOut_1258.writeByte(4);
                    const argsNames_1260: string[] = ["uid", "data"];
                    const argsValues_1261: any[] = [uid, data];
                    sCtx_1251.invokeRemoteMethodAfter("loginByUID", null, argsNames_1260, argsValues_1261);
                    FastMeta.META_UUID.serialize(sCtx_1251, uid, dataOut_1258);
                    LoginStream.META.serialize(sCtx_1251, data, dataOut_1258);
                    sCtx_1251.sendToRemote(dataOut_1258.toArray());
                    return AFuture.of();
                    
                }
                , loginByAlias: (alias: UUID, data: LoginStream): AFuture =>  {
                    const dataOut_1265 = new DataInOut();
                    dataOut_1265.writeByte(5);
                    const argsNames_1267: string[] = ["alias", "data"];
                    const argsValues_1268: any[] = [alias, data];
                    sCtx_1251.invokeRemoteMethodAfter("loginByAlias", null, argsNames_1267, argsValues_1268);
                    FastMeta.META_UUID.serialize(sCtx_1251, alias, dataOut_1265);
                    LoginStream.META.serialize(sCtx_1251, data, dataOut_1265);
                    sCtx_1251.sendToRemote(dataOut_1265.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as LoginApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: LoginApiRemote ---
export interface LoginApiRemote extends LoginApi, RemoteApi  {
    
}
// --- Generated API Local Class: LoginApiLocal ---
export abstract class LoginApiLocal<RT extends LoginApiRemote> implements LoginApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getTimeUTC(): ARFuture<number>;
    public abstract loginByUID(uid: UUID, data: LoginStream): AFuture;
    public abstract loginByAlias(alias: UUID, data: LoginStream): AFuture;
    
}
// --- Generated API Interface: ServerApiByUidClient ---
export interface ServerApiByUidClient  {
    
}
export namespace ServerApiByUidClient  {
    export const META: FastMetaApi<ServerApiByUidClient, ServerApiByUidClientRemote> = new class implements FastMetaApi<ServerApiByUidClient, ServerApiByUidClientRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: ServerApiByUidClient): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerApiByUidClient>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerApiByUidClient): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1271: FastFutureContext): ServerApiByUidClientRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1271.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1271, 
            };
            return remoteApiImpl as ServerApiByUidClientRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerApiByUidClientRemote ---
export interface ServerApiByUidClientRemote extends ServerApiByUidClient, RemoteApi  {
    
}
// --- Generated API Local Class: ServerApiByUidClientLocal ---
export abstract class ServerApiByUidClientLocal<RT extends ServerApiByUidClientRemote> implements ServerApiByUidClient  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: ServerApiByUid ---
export interface ServerApiByUid  {
    getBalance(): ARFuture<number>;
    setParent(uid: UUID): AFuture;
    block(): AFuture;
    getPosition(): ARFuture<Cloud>;
    getParent(): ARFuture<UUID>;
    getBeneficiary(): ARFuture<UUID>;
    setBeneficiary(uid: UUID): AFuture;
    getBlockTime(): ARFuture<Date>;
    unblock(): AFuture;
    createTime(): ARFuture<Date>;
    onlineTime(): ARFuture<Date>;
    addAccessGroup(groupId: number): ARFuture<boolean>;
    removeAccessGroup(groupId: number): ARFuture<boolean>;
    
}
export namespace ServerApiByUid  {
    export const META: FastMetaApi<ServerApiByUid, ServerApiByUidRemote> = new class implements FastMetaApi<ServerApiByUid, ServerApiByUidRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ServerApiByUid): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_1272 = dataIn.readInt();
                        const argsNames_1273: string[] = [];
                        const argsValues_1274: any[] = [];
                        ctx.invokeLocalMethodBefore("getBalance", argsNames_1273, argsValues_1274);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBalance();
                        ctx.invokeLocalMethodAfter("getBalance", resultFuture, argsNames_1273, argsValues_1274);
                        resultFuture.to((v_1276: number) =>  {
                            const data_1275 = new DataInOut();
                            data_1275.writeLong(v_1276);
                            ctx.sendResultToRemote(reqId_1272, data_1275.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let uid_1279: UUID;
                        uid_1279 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_1281: string[] = ["uid"];
                        const argsValues_1282: any[] = [uid_1279];
                        ctx.invokeLocalMethodBefore("setParent", argsNames_1281, argsValues_1282);
                        localApi.setParent(uid_1279);
                        ctx.invokeLocalMethodAfter("setParent", null, argsNames_1281, argsValues_1282);
                        break;
                        
                    }
                    case 5:  {
                        const argsNames_1284: string[] = [];
                        const argsValues_1285: any[] = [];
                        ctx.invokeLocalMethodBefore("block", argsNames_1284, argsValues_1285);
                        localApi.block();
                        ctx.invokeLocalMethodAfter("block", null, argsNames_1284, argsValues_1285);
                        break;
                        
                    }
                    case 6:  {
                        const reqId_1286 = dataIn.readInt();
                        const argsNames_1287: string[] = [];
                        const argsValues_1288: any[] = [];
                        ctx.invokeLocalMethodBefore("getPosition", argsNames_1287, argsValues_1288);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getPosition();
                        ctx.invokeLocalMethodAfter("getPosition", resultFuture, argsNames_1287, argsValues_1288);
                        resultFuture.to((v_1290: Cloud) =>  {
                            const data_1289 = new DataInOut();
                            Cloud.META.serialize(ctx, v_1290, data_1289);
                            ctx.sendResultToRemote(reqId_1286, data_1289.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 7:  {
                        const reqId_1292 = dataIn.readInt();
                        const argsNames_1293: string[] = [];
                        const argsValues_1294: any[] = [];
                        ctx.invokeLocalMethodBefore("getParent", argsNames_1293, argsValues_1294);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getParent();
                        ctx.invokeLocalMethodAfter("getParent", resultFuture, argsNames_1293, argsValues_1294);
                        resultFuture.to((v_1296: UUID) =>  {
                            const data_1295 = new DataInOut();
                            FastMeta.META_UUID.serialize(ctx, v_1296, data_1295);
                            ctx.sendResultToRemote(reqId_1292, data_1295.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 8:  {
                        const reqId_1298 = dataIn.readInt();
                        const argsNames_1299: string[] = [];
                        const argsValues_1300: any[] = [];
                        ctx.invokeLocalMethodBefore("getBeneficiary", argsNames_1299, argsValues_1300);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBeneficiary();
                        ctx.invokeLocalMethodAfter("getBeneficiary", resultFuture, argsNames_1299, argsValues_1300);
                        resultFuture.to((v_1302: UUID) =>  {
                            const data_1301 = new DataInOut();
                            FastMeta.META_UUID.serialize(ctx, v_1302, data_1301);
                            ctx.sendResultToRemote(reqId_1298, data_1301.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 9:  {
                        let uid_1305: UUID;
                        uid_1305 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        const argsNames_1307: string[] = ["uid"];
                        const argsValues_1308: any[] = [uid_1305];
                        ctx.invokeLocalMethodBefore("setBeneficiary", argsNames_1307, argsValues_1308);
                        localApi.setBeneficiary(uid_1305);
                        ctx.invokeLocalMethodAfter("setBeneficiary", null, argsNames_1307, argsValues_1308);
                        break;
                        
                    }
                    case 10:  {
                        const reqId_1309 = dataIn.readInt();
                        const argsNames_1310: string[] = [];
                        const argsValues_1311: any[] = [];
                        ctx.invokeLocalMethodBefore("getBlockTime", argsNames_1310, argsValues_1311);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getBlockTime();
                        ctx.invokeLocalMethodAfter("getBlockTime", resultFuture, argsNames_1310, argsValues_1311);
                        resultFuture.to((v_1313: Date) =>  {
                            const data_1312 = new DataInOut();
                            data_1312.writeLong(v_1313.getTime());
                            ctx.sendResultToRemote(reqId_1309, data_1312.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 11:  {
                        const argsNames_1316: string[] = [];
                        const argsValues_1317: any[] = [];
                        ctx.invokeLocalMethodBefore("unblock", argsNames_1316, argsValues_1317);
                        localApi.unblock();
                        ctx.invokeLocalMethodAfter("unblock", null, argsNames_1316, argsValues_1317);
                        break;
                        
                    }
                    case 12:  {
                        const reqId_1318 = dataIn.readInt();
                        const argsNames_1319: string[] = [];
                        const argsValues_1320: any[] = [];
                        ctx.invokeLocalMethodBefore("createTime", argsNames_1319, argsValues_1320);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.createTime();
                        ctx.invokeLocalMethodAfter("createTime", resultFuture, argsNames_1319, argsValues_1320);
                        resultFuture.to((v_1322: Date) =>  {
                            const data_1321 = new DataInOut();
                            data_1321.writeLong(v_1322.getTime());
                            ctx.sendResultToRemote(reqId_1318, data_1321.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 13:  {
                        const reqId_1324 = dataIn.readInt();
                        const argsNames_1325: string[] = [];
                        const argsValues_1326: any[] = [];
                        ctx.invokeLocalMethodBefore("onlineTime", argsNames_1325, argsValues_1326);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.onlineTime();
                        ctx.invokeLocalMethodAfter("onlineTime", resultFuture, argsNames_1325, argsValues_1326);
                        resultFuture.to((v_1328: Date) =>  {
                            const data_1327 = new DataInOut();
                            data_1327.writeLong(v_1328.getTime());
                            ctx.sendResultToRemote(reqId_1324, data_1327.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 14:  {
                        const reqId_1330 = dataIn.readInt();
                        let groupId_1331: number;
                        groupId_1331 = dataIn.readLong();
                        const argsNames_1333: string[] = ["groupId"];
                        const argsValues_1334: any[] = [groupId_1331];
                        ctx.invokeLocalMethodBefore("addAccessGroup", argsNames_1333, argsValues_1334);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.addAccessGroup(groupId_1331);
                        ctx.invokeLocalMethodAfter("addAccessGroup", resultFuture, argsNames_1333, argsValues_1334);
                        resultFuture.to((v_1336: boolean) =>  {
                            const data_1335 = new DataInOut();
                            data_1335.writeBoolean(v_1336);
                            ctx.sendResultToRemote(reqId_1330, data_1335.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 15:  {
                        const reqId_1338 = dataIn.readInt();
                        let groupId_1339: number;
                        groupId_1339 = dataIn.readLong();
                        const argsNames_1341: string[] = ["groupId"];
                        const argsValues_1342: any[] = [groupId_1339];
                        ctx.invokeLocalMethodBefore("removeAccessGroup", argsNames_1341, argsValues_1342);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.removeAccessGroup(groupId_1339);
                        ctx.invokeLocalMethodAfter("removeAccessGroup", resultFuture, argsNames_1341, argsValues_1342);
                        resultFuture.to((v_1344: boolean) =>  {
                            const data_1343 = new DataInOut();
                            data_1343.writeBoolean(v_1344);
                            ctx.sendResultToRemote(reqId_1338, data_1343.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerApiByUid>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerApiByUid): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1346: FastFutureContext): ServerApiByUidRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1346.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1346, getBalance: (): ARFuture<number> =>  {
                    const dataOut_1348 = new DataInOut();
                    dataOut_1348.writeByte(3);
                    const argsNames_1350: string[] = [];
                    const argsValues_1351: any[] = [];
                    const result_1349 = ARFuture.of<number>();
                    sCtx_1346.invokeRemoteMethodAfter("getBalance", result_1349, argsNames_1350, argsValues_1351);
                    const reqId_1347 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1349 as ARFuture<number>).tryDone(FastMeta.META_LONG.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1349.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1348.writeInt(reqId_1347);
                    sCtx_1346.sendToRemote(dataOut_1348.toArray());
                    return result_1349;
                    
                }
                , setParent: (uid: UUID): AFuture =>  {
                    const dataOut_1353 = new DataInOut();
                    dataOut_1353.writeByte(4);
                    const argsNames_1355: string[] = ["uid"];
                    const argsValues_1356: any[] = [uid];
                    sCtx_1346.invokeRemoteMethodAfter("setParent", null, argsNames_1355, argsValues_1356);
                    FastMeta.META_UUID.serialize(sCtx_1346, uid, dataOut_1353);
                    sCtx_1346.sendToRemote(dataOut_1353.toArray());
                    return AFuture.of();
                    
                }
                , block: (): AFuture =>  {
                    const dataOut_1359 = new DataInOut();
                    dataOut_1359.writeByte(5);
                    const argsNames_1361: string[] = [];
                    const argsValues_1362: any[] = [];
                    sCtx_1346.invokeRemoteMethodAfter("block", null, argsNames_1361, argsValues_1362);
                    sCtx_1346.sendToRemote(dataOut_1359.toArray());
                    return AFuture.of();
                    
                }
                , getPosition: (): ARFuture<Cloud> =>  {
                    const dataOut_1364 = new DataInOut();
                    dataOut_1364.writeByte(6);
                    const argsNames_1366: string[] = [];
                    const argsValues_1367: any[] = [];
                    const result_1365 = ARFuture.of<Cloud>();
                    sCtx_1346.invokeRemoteMethodAfter("getPosition", result_1365, argsNames_1366, argsValues_1367);
                    const reqId_1363 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1365 as ARFuture<Cloud>).tryDone(Cloud.META.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1365.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1364.writeInt(reqId_1363);
                    sCtx_1346.sendToRemote(dataOut_1364.toArray());
                    return result_1365;
                    
                }
                , getParent: (): ARFuture<UUID> =>  {
                    const dataOut_1369 = new DataInOut();
                    dataOut_1369.writeByte(7);
                    const argsNames_1371: string[] = [];
                    const argsValues_1372: any[] = [];
                    const result_1370 = ARFuture.of<UUID>();
                    sCtx_1346.invokeRemoteMethodAfter("getParent", result_1370, argsNames_1371, argsValues_1372);
                    const reqId_1368 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1370 as ARFuture<UUID>).tryDone(FastMeta.META_UUID.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1370.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1369.writeInt(reqId_1368);
                    sCtx_1346.sendToRemote(dataOut_1369.toArray());
                    return result_1370;
                    
                }
                , getBeneficiary: (): ARFuture<UUID> =>  {
                    const dataOut_1374 = new DataInOut();
                    dataOut_1374.writeByte(8);
                    const argsNames_1376: string[] = [];
                    const argsValues_1377: any[] = [];
                    const result_1375 = ARFuture.of<UUID>();
                    sCtx_1346.invokeRemoteMethodAfter("getBeneficiary", result_1375, argsNames_1376, argsValues_1377);
                    const reqId_1373 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1375 as ARFuture<UUID>).tryDone(FastMeta.META_UUID.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1375.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1374.writeInt(reqId_1373);
                    sCtx_1346.sendToRemote(dataOut_1374.toArray());
                    return result_1375;
                    
                }
                , setBeneficiary: (uid: UUID): AFuture =>  {
                    const dataOut_1379 = new DataInOut();
                    dataOut_1379.writeByte(9);
                    const argsNames_1381: string[] = ["uid"];
                    const argsValues_1382: any[] = [uid];
                    sCtx_1346.invokeRemoteMethodAfter("setBeneficiary", null, argsNames_1381, argsValues_1382);
                    FastMeta.META_UUID.serialize(sCtx_1346, uid, dataOut_1379);
                    sCtx_1346.sendToRemote(dataOut_1379.toArray());
                    return AFuture.of();
                    
                }
                , getBlockTime: (): ARFuture<Date> =>  {
                    const dataOut_1385 = new DataInOut();
                    dataOut_1385.writeByte(10);
                    const argsNames_1387: string[] = [];
                    const argsValues_1388: any[] = [];
                    const result_1386 = ARFuture.of<Date>();
                    sCtx_1346.invokeRemoteMethodAfter("getBlockTime", result_1386, argsNames_1387, argsValues_1388);
                    const reqId_1384 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1386 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1386.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1385.writeInt(reqId_1384);
                    sCtx_1346.sendToRemote(dataOut_1385.toArray());
                    return result_1386;
                    
                }
                , unblock: (): AFuture =>  {
                    const dataOut_1390 = new DataInOut();
                    dataOut_1390.writeByte(11);
                    const argsNames_1392: string[] = [];
                    const argsValues_1393: any[] = [];
                    sCtx_1346.invokeRemoteMethodAfter("unblock", null, argsNames_1392, argsValues_1393);
                    sCtx_1346.sendToRemote(dataOut_1390.toArray());
                    return AFuture.of();
                    
                }
                , createTime: (): ARFuture<Date> =>  {
                    const dataOut_1395 = new DataInOut();
                    dataOut_1395.writeByte(12);
                    const argsNames_1397: string[] = [];
                    const argsValues_1398: any[] = [];
                    const result_1396 = ARFuture.of<Date>();
                    sCtx_1346.invokeRemoteMethodAfter("createTime", result_1396, argsNames_1397, argsValues_1398);
                    const reqId_1394 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1396 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1396.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1395.writeInt(reqId_1394);
                    sCtx_1346.sendToRemote(dataOut_1395.toArray());
                    return result_1396;
                    
                }
                , onlineTime: (): ARFuture<Date> =>  {
                    const dataOut_1400 = new DataInOut();
                    dataOut_1400.writeByte(13);
                    const argsNames_1402: string[] = [];
                    const argsValues_1403: any[] = [];
                    const result_1401 = ARFuture.of<Date>();
                    sCtx_1346.invokeRemoteMethodAfter("onlineTime", result_1401, argsNames_1402, argsValues_1403);
                    const reqId_1399 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1401 as ARFuture<Date>).tryDone(FastMeta.META_DATE.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1401.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1400.writeInt(reqId_1399);
                    sCtx_1346.sendToRemote(dataOut_1400.toArray());
                    return result_1401;
                    
                }
                , addAccessGroup: (groupId: number): ARFuture<boolean> =>  {
                    const dataOut_1405 = new DataInOut();
                    dataOut_1405.writeByte(14);
                    const argsNames_1407: string[] = ["groupId"];
                    const argsValues_1408: any[] = [groupId];
                    const result_1406 = ARFuture.of<boolean>();
                    sCtx_1346.invokeRemoteMethodAfter("addAccessGroup", result_1406, argsNames_1407, argsValues_1408);
                    const reqId_1404 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1406 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1406.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1405.writeInt(reqId_1404);
                    dataOut_1405.writeLong(groupId);
                    sCtx_1346.sendToRemote(dataOut_1405.toArray());
                    return result_1406;
                    
                }
                , removeAccessGroup: (groupId: number): ARFuture<boolean> =>  {
                    const dataOut_1411 = new DataInOut();
                    dataOut_1411.writeByte(15);
                    const argsNames_1413: string[] = ["groupId"];
                    const argsValues_1414: any[] = [groupId];
                    const result_1412 = ARFuture.of<boolean>();
                    sCtx_1346.invokeRemoteMethodAfter("removeAccessGroup", result_1412, argsNames_1413, argsValues_1414);
                    const reqId_1410 = sCtx_1346.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1412 as ARFuture<boolean>).tryDone(FastMeta.META_BOOLEAN.deserialize(sCtx_1346, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1412.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1411.writeInt(reqId_1410);
                    dataOut_1411.writeLong(groupId);
                    sCtx_1346.sendToRemote(dataOut_1411.toArray());
                    return result_1412;
                    
                }
                , 
            };
            return remoteApiImpl as ServerApiByUidRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerApiByUidRemote ---
export interface ServerApiByUidRemote extends ServerApiByUid, RemoteApi  {
    
}
// --- Generated API Local Class: ServerApiByUidLocal ---
export abstract class ServerApiByUidLocal<RT extends ServerApiByUidRemote> implements ServerApiByUid  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getBalance(): ARFuture<number>;
    public abstract setParent(uid: UUID): AFuture;
    public abstract block(): AFuture;
    public abstract getPosition(): ARFuture<Cloud>;
    public abstract getParent(): ARFuture<UUID>;
    public abstract getBeneficiary(): ARFuture<UUID>;
    public abstract setBeneficiary(uid: UUID): AFuture;
    public abstract getBlockTime(): ARFuture<Date>;
    public abstract unblock(): AFuture;
    public abstract createTime(): ARFuture<Date>;
    public abstract onlineTime(): ARFuture<Date>;
    public abstract addAccessGroup(groupId: number): ARFuture<boolean>;
    public abstract removeAccessGroup(groupId: number): ARFuture<boolean>;
    
}
// --- Generated API Interface: ClientApiRegSafe ---
export interface ClientApiRegSafe  {
    
}
export namespace ClientApiRegSafe  {
    export const META: FastMetaApi<ClientApiRegSafe, ClientApiRegSafeRemote> = new class implements FastMetaApi<ClientApiRegSafe, ClientApiRegSafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: ClientApiRegSafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiRegSafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiRegSafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1416: FastFutureContext): ClientApiRegSafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1416.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1416, 
            };
            return remoteApiImpl as ClientApiRegSafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiRegSafeRemote ---
export interface ClientApiRegSafeRemote extends ClientApiRegSafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiRegSafeLocal ---
export abstract class ClientApiRegSafeLocal<RT extends ClientApiRegSafeRemote> implements ClientApiRegSafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: GlobalRegClientApi ---
export interface GlobalRegClientApi  {
    
}
export namespace GlobalRegClientApi  {
    export const META: FastMetaApi<GlobalRegClientApi, GlobalRegClientApiRemote> = new class implements FastMetaApi<GlobalRegClientApi, GlobalRegClientApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, _localApi: GlobalRegClientApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<GlobalRegClientApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: GlobalRegClientApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1417: FastFutureContext): GlobalRegClientApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1417.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1417, 
            };
            return remoteApiImpl as GlobalRegClientApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: GlobalRegClientApiRemote ---
export interface GlobalRegClientApiRemote extends GlobalRegClientApi, RemoteApi  {
    
}
// --- Generated API Local Class: GlobalRegClientApiLocal ---
export abstract class GlobalRegClientApiLocal<RT extends GlobalRegClientApiRemote> implements GlobalRegClientApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    
}
// --- Generated API Interface: ClientApiRegUnsafe ---
export interface ClientApiRegUnsafe  {
    enter(stream: ClientApiRegSafeStream): AFuture;
    enterGlobal(stream: GlobalRegClientApiStream): AFuture;
    
}
export namespace ClientApiRegUnsafe  {
    export const META: FastMetaApi<ClientApiRegUnsafe, ClientApiRegUnsafeRemote> = new class implements FastMetaApi<ClientApiRegUnsafe, ClientApiRegUnsafeRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ClientApiRegUnsafe): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let stream_1419: ClientApiRegSafeStream;
                        stream_1419 = ClientApiRegSafeStream.META.deserialize(ctx, dataIn);
                        const argsNames_1421: string[] = ["stream"];
                        const argsValues_1422: any[] = [stream_1419];
                        ctx.invokeLocalMethodBefore("enter", argsNames_1421, argsValues_1422);
                        localApi.enter(stream_1419);
                        ctx.invokeLocalMethodAfter("enter", null, argsNames_1421, argsValues_1422);
                        break;
                        
                    }
                    case 4:  {
                        let stream_1424: GlobalRegClientApiStream;
                        stream_1424 = GlobalRegClientApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_1426: string[] = ["stream"];
                        const argsValues_1427: any[] = [stream_1424];
                        ctx.invokeLocalMethodBefore("enterGlobal", argsNames_1426, argsValues_1427);
                        localApi.enterGlobal(stream_1424);
                        ctx.invokeLocalMethodAfter("enterGlobal", null, argsNames_1426, argsValues_1427);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ClientApiRegUnsafe>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ClientApiRegUnsafe): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1428: FastFutureContext): ClientApiRegUnsafeRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1428.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1428, enter: (stream: ClientApiRegSafeStream): AFuture =>  {
                    const dataOut_1430 = new DataInOut();
                    dataOut_1430.writeByte(3);
                    const argsNames_1432: string[] = ["stream"];
                    const argsValues_1433: any[] = [stream];
                    sCtx_1428.invokeRemoteMethodAfter("enter", null, argsNames_1432, argsValues_1433);
                    ClientApiRegSafeStream.META.serialize(sCtx_1428, stream, dataOut_1430);
                    sCtx_1428.sendToRemote(dataOut_1430.toArray());
                    return AFuture.of();
                    
                }
                , enterGlobal: (stream: GlobalRegClientApiStream): AFuture =>  {
                    const dataOut_1436 = new DataInOut();
                    dataOut_1436.writeByte(4);
                    const argsNames_1438: string[] = ["stream"];
                    const argsValues_1439: any[] = [stream];
                    sCtx_1428.invokeRemoteMethodAfter("enterGlobal", null, argsNames_1438, argsValues_1439);
                    GlobalRegClientApiStream.META.serialize(sCtx_1428, stream, dataOut_1436);
                    sCtx_1428.sendToRemote(dataOut_1436.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as ClientApiRegUnsafeRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ClientApiRegUnsafeRemote ---
export interface ClientApiRegUnsafeRemote extends ClientApiRegUnsafe, RemoteApi  {
    
}
// --- Generated API Local Class: ClientApiRegUnsafeLocal ---
export abstract class ClientApiRegUnsafeLocal<RT extends ClientApiRegUnsafeRemote> implements ClientApiRegUnsafe  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract enter(stream: ClientApiRegSafeStream): AFuture;
    public abstract enterGlobal(stream: GlobalRegClientApiStream): AFuture;
    
}
// --- Generated API Interface: GlobalRegServerApi ---
export interface GlobalRegServerApi  {
    setMasterKey(key: Key): AFuture;
    finish(): ARFuture<FinishResultGlobalRegServerApi>;
    
}
export namespace GlobalRegServerApi  {
    export const META: FastMetaApi<GlobalRegServerApi, GlobalRegServerApiRemote> = new class implements FastMetaApi<GlobalRegServerApi, GlobalRegServerApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: GlobalRegServerApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let _key_1442: Key;
                        _key_1442 = Key.META.deserialize(ctx, dataIn);
                        const argsNames_1444: string[] = ["key"];
                        const argsValues_1445: any[] = [_key_1442];
                        ctx.invokeLocalMethodBefore("setMasterKey", argsNames_1444, argsValues_1445);
                        localApi.setMasterKey(_key_1442);
                        ctx.invokeLocalMethodAfter("setMasterKey", null, argsNames_1444, argsValues_1445);
                        break;
                        
                    }
                    case 4:  {
                        const reqId_1446 = dataIn.readInt();
                        const argsNames_1447: string[] = [];
                        const argsValues_1448: any[] = [];
                        ctx.invokeLocalMethodBefore("finish", argsNames_1447, argsValues_1448);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.finish();
                        ctx.invokeLocalMethodAfter("finish", resultFuture, argsNames_1447, argsValues_1448);
                        resultFuture.to((v_1450: FinishResultGlobalRegServerApi) =>  {
                            const data_1449 = new DataInOut();
                            FinishResultGlobalRegServerApi.META.serialize(ctx, v_1450, data_1449);
                            ctx.sendResultToRemote(reqId_1446, data_1449.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<GlobalRegServerApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: GlobalRegServerApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1452: FastFutureContext): GlobalRegServerApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1452.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1452, setMasterKey: (key: Key): AFuture =>  {
                    const dataOut_1454 = new DataInOut();
                    dataOut_1454.writeByte(3);
                    const argsNames_1456: string[] = ["key"];
                    const argsValues_1457: any[] = [key];
                    sCtx_1452.invokeRemoteMethodAfter("setMasterKey", null, argsNames_1456, argsValues_1457);
                    Key.META.serialize(sCtx_1452, key, dataOut_1454);
                    sCtx_1452.sendToRemote(dataOut_1454.toArray());
                    return AFuture.of();
                    
                }
                , finish: (): ARFuture<FinishResultGlobalRegServerApi> =>  {
                    const dataOut_1460 = new DataInOut();
                    dataOut_1460.writeByte(4);
                    const argsNames_1462: string[] = [];
                    const argsValues_1463: any[] = [];
                    const result_1461 = ARFuture.of<FinishResultGlobalRegServerApi>();
                    sCtx_1452.invokeRemoteMethodAfter("finish", result_1461, argsNames_1462, argsValues_1463);
                    const reqId_1459 = sCtx_1452.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1461 as ARFuture<FinishResultGlobalRegServerApi>).tryDone(FinishResultGlobalRegServerApi.META.deserialize(sCtx_1452, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1461.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1460.writeInt(reqId_1459);
                    sCtx_1452.sendToRemote(dataOut_1460.toArray());
                    return result_1461;
                    
                }
                , 
            };
            return remoteApiImpl as GlobalRegServerApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: GlobalRegServerApiRemote ---
export interface GlobalRegServerApiRemote extends GlobalRegServerApi, RemoteApi  {
    
}
// --- Generated API Local Class: GlobalRegServerApiLocal ---
export abstract class GlobalRegServerApiLocal<RT extends GlobalRegServerApiRemote> implements GlobalRegServerApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract setMasterKey(key: Key): AFuture;
    public abstract finish(): ARFuture<FinishResultGlobalRegServerApi>;
    
}
// --- Generated API Interface: ServerRegistrationApi ---
export interface ServerRegistrationApi  {
    registration(salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture;
    requestWorkProofData(parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO>;
    resolveServers(serverIds: Cloud): ARFuture<ServerDescriptor[]>;
    
}
export namespace ServerRegistrationApi  {
    export const META: FastMetaApi<ServerRegistrationApi, ServerRegistrationApiRemote> = new class implements FastMetaApi<ServerRegistrationApi, ServerRegistrationApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: ServerRegistrationApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        let salt_1465: string;
                        let suffix_1466: string;
                        let passwords_1467: number[];
                        let parent_1468: UUID;
                        let returnKey_1469: Key;
                        let globalApi_1470: GlobalApiRegistrationServerRegistrationApi;
                        let stringBytes_1472: Uint8Array;
                        const len_1474 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        const bytes_1475 = dataIn.readBytes(len_1474);
                        stringBytes_1472 = bytes_1475;
                        salt_1465 = new TextDecoder('utf-8').decode(stringBytes_1472);
                        let stringBytes_1477: Uint8Array;
                        const len_1479 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        const bytes_1480 = dataIn.readBytes(len_1479);
                        stringBytes_1477 = bytes_1480;
                        suffix_1466 = new TextDecoder('utf-8').decode(stringBytes_1477);
                        const len_1482 = DeserializerPackNumber.INSTANCE.put(dataIn).valueOf();
                        passwords_1467 = new Array<number>(len_1482);
                        for (let idx_1481 = 0;
                        idx_1481 < len_1482;
                        idx_1481++)  {
                            passwords_1467[idx_1481] = dataIn.readInt();
                            
                        }
                        parent_1468 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        returnKey_1469 = Key.META.deserialize(ctx, dataIn);
                        globalApi_1470 = GlobalApiRegistrationServerRegistrationApi.META.deserialize(ctx, dataIn);
                        const argsNames_1487: string[] = ["salt", "suffix", "passwords", "parent", "returnKey", "globalApi"];
                        const argsValues_1488: any[] = [salt_1465, suffix_1466, passwords_1467, parent_1468, returnKey_1469, globalApi_1470];
                        ctx.invokeLocalMethodBefore("registration", argsNames_1487, argsValues_1488);
                        localApi.registration(salt_1465, suffix_1466, passwords_1467, parent_1468, returnKey_1469, globalApi_1470);
                        ctx.invokeLocalMethodAfter("registration", null, argsNames_1487, argsValues_1488);
                        break;
                        
                    }
                    case 4:  {
                        const reqId_1489 = dataIn.readInt();
                        let parent_1490: UUID;
                        let powMethods_1491: PowMethod;
                        let returnKey_1492: Key;
                        parent_1490 = FastMeta.META_UUID.deserialize(ctx, dataIn);
                        powMethods_1491 = PowMethod.META.deserialize(ctx, dataIn);
                        returnKey_1492 = Key.META.deserialize(ctx, dataIn);
                        const argsNames_1496: string[] = ["parent", "powMethods", "returnKey"];
                        const argsValues_1497: any[] = [parent_1490, powMethods_1491, returnKey_1492];
                        ctx.invokeLocalMethodBefore("requestWorkProofData", argsNames_1496, argsValues_1497);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.requestWorkProofData(parent_1490, powMethods_1491, returnKey_1492);
                        ctx.invokeLocalMethodAfter("requestWorkProofData", resultFuture, argsNames_1496, argsValues_1497);
                        resultFuture.to((v_1499: WorkProofDTO) =>  {
                            const data_1498 = new DataInOut();
                            WorkProofDTO.META.serialize(ctx, v_1499, data_1498);
                            ctx.sendResultToRemote(reqId_1489, data_1498.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 5:  {
                        const reqId_1501 = dataIn.readInt();
                        let serverIds_1502: Cloud;
                        serverIds_1502 = Cloud.META.deserialize(ctx, dataIn);
                        const argsNames_1504: string[] = ["serverIds"];
                        const argsValues_1505: any[] = [serverIds_1502];
                        ctx.invokeLocalMethodBefore("resolveServers", argsNames_1504, argsValues_1505);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.resolveServers(serverIds_1502);
                        ctx.invokeLocalMethodAfter("resolveServers", resultFuture, argsNames_1504, argsValues_1505);
                        resultFuture.to((v_1507: ServerDescriptor[]) =>  {
                            const data_1506 = new DataInOut();
                            SerializerPackNumber.INSTANCE.put(data_1506, v_1507.length);
                            for (const el_1508 of v_1507)  {
                                ServerDescriptor.META.serialize(ctx, el_1508, data_1506);
                                
                            }
                            ctx.sendResultToRemote(reqId_1501, data_1506.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<ServerRegistrationApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: ServerRegistrationApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1510: FastFutureContext): ServerRegistrationApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1510.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1510, registration: (salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture =>  {
                    const dataOut_1512 = new DataInOut();
                    dataOut_1512.writeByte(3);
                    const argsNames_1514: string[] = ["salt", "suffix", "passwords", "parent", "returnKey", "globalApi"];
                    const argsValues_1515: any[] = [salt, suffix, passwords, parent, returnKey, globalApi];
                    sCtx_1510.invokeRemoteMethodAfter("registration", null, argsNames_1514, argsValues_1515);
                    const stringBytes_1517 = new TextEncoder().encode(salt);
                    SerializerPackNumber.INSTANCE.put(dataOut_1512, stringBytes_1517.length);
                    dataOut_1512.write(stringBytes_1517);
                    const stringBytes_1520 = new TextEncoder().encode(suffix);
                    SerializerPackNumber.INSTANCE.put(dataOut_1512, stringBytes_1520.length);
                    dataOut_1512.write(stringBytes_1520);
                    SerializerPackNumber.INSTANCE.put(dataOut_1512, passwords.length);
                    for (const el_1522 of passwords)  {
                        dataOut_1512.writeInt(el_1522);
                        
                    }
                    FastMeta.META_UUID.serialize(sCtx_1510, parent, dataOut_1512);
                    Key.META.serialize(sCtx_1510, returnKey, dataOut_1512);
                    GlobalApiRegistrationServerRegistrationApi.META.serialize(sCtx_1510, globalApi, dataOut_1512);
                    sCtx_1510.sendToRemote(dataOut_1512.toArray());
                    return AFuture.of();
                    
                }
                , requestWorkProofData: (parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO> =>  {
                    const dataOut_1528 = new DataInOut();
                    dataOut_1528.writeByte(4);
                    const argsNames_1530: string[] = ["parent", "powMethods", "returnKey"];
                    const argsValues_1531: any[] = [parent, powMethods, returnKey];
                    const result_1529 = ARFuture.of<WorkProofDTO>();
                    sCtx_1510.invokeRemoteMethodAfter("requestWorkProofData", result_1529, argsNames_1530, argsValues_1531);
                    const reqId_1527 = sCtx_1510.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1529 as ARFuture<WorkProofDTO>).tryDone(WorkProofDTO.META.deserialize(sCtx_1510, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1529.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1528.writeInt(reqId_1527);
                    FastMeta.META_UUID.serialize(sCtx_1510, parent, dataOut_1528);
                    PowMethod.META.serialize(sCtx_1510, powMethods, dataOut_1528);
                    Key.META.serialize(sCtx_1510, returnKey, dataOut_1528);
                    sCtx_1510.sendToRemote(dataOut_1528.toArray());
                    return result_1529;
                    
                }
                , resolveServers: (serverIds: Cloud): ARFuture<ServerDescriptor[]> =>  {
                    const dataOut_1536 = new DataInOut();
                    dataOut_1536.writeByte(5);
                    const argsNames_1538: string[] = ["serverIds"];
                    const argsValues_1539: any[] = [serverIds];
                    const result_1537 = ARFuture.of<ServerDescriptor[]>();
                    sCtx_1510.invokeRemoteMethodAfter("resolveServers", result_1537, argsNames_1538, argsValues_1539);
                    const reqId_1535 = sCtx_1510.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1537 as ARFuture<ServerDescriptor[]>).tryDone(AllCustomMeta.META_ARRAY_ServerDescriptor.deserialize(sCtx_1510, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1537.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1536.writeInt(reqId_1535);
                    Cloud.META.serialize(sCtx_1510, serverIds, dataOut_1536);
                    sCtx_1510.sendToRemote(dataOut_1536.toArray());
                    return result_1537;
                    
                }
                , 
            };
            return remoteApiImpl as ServerRegistrationApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: ServerRegistrationApiRemote ---
export interface ServerRegistrationApiRemote extends ServerRegistrationApi, RemoteApi  {
    
}
// --- Generated API Local Class: ServerRegistrationApiLocal ---
export abstract class ServerRegistrationApiLocal<RT extends ServerRegistrationApiRemote> implements ServerRegistrationApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract registration(salt: string, suffix: string, passwords: number[], parent: UUID, returnKey: Key, globalApi: GlobalApiRegistrationServerRegistrationApi): AFuture;
    public abstract requestWorkProofData(parent: UUID, powMethods: PowMethod, returnKey: Key): ARFuture<WorkProofDTO>;
    public abstract resolveServers(serverIds: Cloud): ARFuture<ServerDescriptor[]>;
    
}
// --- Generated API Interface: RegistrationRootApi ---
export interface RegistrationRootApi  {
    getAsymmetricPublicKey(cryptoLib: CryptoLib): ARFuture<SignedKey>;
    enter(cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture;
    
}
export namespace RegistrationRootApi  {
    export const META: FastMetaApi<RegistrationRootApi, RegistrationRootApiRemote> = new class implements FastMetaApi<RegistrationRootApi, RegistrationRootApiRemote>  {
        makeLocal_fromDataIn(ctx: FastFutureContext, dataIn: DataIn, localApi: RegistrationRootApi): void  {
            while(dataIn.isReadable())  {
                const commandId = dataIn.readUByte();
                switch(commandId)  {
                    case 0:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onDone(dataIn);
                        break;
                        
                    }
                    case 1:  {
                        const reqId = FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);
                        const futureRec = ctx.getFuture(reqId);
                        if (futureRec) futureRec.onError(dataIn);
                        break;
                        
                    }
                    case 3:  {
                        const reqId_1541 = dataIn.readInt();
                        let cryptoLib_1542: CryptoLib;
                        cryptoLib_1542 = CryptoLib.META.deserialize(ctx, dataIn);
                        const argsNames_1544: string[] = ["cryptoLib"];
                        const argsValues_1545: any[] = [cryptoLib_1542];
                        ctx.invokeLocalMethodBefore("getAsymmetricPublicKey", argsNames_1544, argsValues_1545);
                        ctx.regLocalFuture();
                        const resultFuture = localApi.getAsymmetricPublicKey(cryptoLib_1542);
                        ctx.invokeLocalMethodAfter("getAsymmetricPublicKey", resultFuture, argsNames_1544, argsValues_1545);
                        resultFuture.to((v_1547: SignedKey) =>  {
                            const data_1546 = new DataInOut();
                            SignedKey.META.serialize(ctx, v_1547, data_1546);
                            ctx.sendResultToRemote(reqId_1541, data_1546.toArray());
                            
                        }
                        );
                        break;
                        
                    }
                    case 4:  {
                        let cryptoLib_1550: CryptoLib;
                        let stream_1551: ServerRegistrationApiStream;
                        cryptoLib_1550 = CryptoLib.META.deserialize(ctx, dataIn);
                        stream_1551 = ServerRegistrationApiStream.META.deserialize(ctx, dataIn);
                        const argsNames_1554: string[] = ["cryptoLib", "stream"];
                        const argsValues_1555: any[] = [cryptoLib_1550, stream_1551];
                        ctx.invokeLocalMethodBefore("enter", argsNames_1554, argsValues_1555);
                        localApi.enter(cryptoLib_1550, stream_1551);
                        ctx.invokeLocalMethodAfter("enter", null, argsNames_1554, argsValues_1555);
                        break;
                        
                    }
                    default: throw new Error(`Unknown command ID: $ {
                        commandId
                    }
                    `);
                    
                }
            }
            
        }
        makeLocal_fromBytes_ctxLocal(ctx: FastApiContextLocal<RegistrationRootApi>, data: Uint8Array): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), ctx.localApi);
            
        }
        makeLocal_fromBytes_ctx(ctx: FastFutureContext, data: Uint8Array, localApi: RegistrationRootApi): void  {
            this.makeLocal_fromDataIn(ctx, new DataInOutStatic(data), localApi);
            
        }
        makeRemote(sCtx_1556: FastFutureContext): RegistrationRootApiRemote  {
            const remoteApiImpl =  {
                flush: (sendFuture?: AFuture) =>  {
                    sCtx_1556.flush(sendFuture || AFuture.make());
                    
                }
                , getFastMetaContext: () => sCtx_1556, getAsymmetricPublicKey: (cryptoLib: CryptoLib): ARFuture<SignedKey> =>  {
                    const dataOut_1558 = new DataInOut();
                    dataOut_1558.writeByte(3);
                    const argsNames_1560: string[] = ["cryptoLib"];
                    const argsValues_1561: any[] = [cryptoLib];
                    const result_1559 = ARFuture.of<SignedKey>();
                    sCtx_1556.invokeRemoteMethodAfter("getAsymmetricPublicKey", result_1559, argsNames_1560, argsValues_1561);
                    const reqId_1557 = sCtx_1556.regFuture( {
                        onDone: (in_: DataIn) =>  {
                            (result_1559 as ARFuture<SignedKey>).tryDone(SignedKey.META.deserialize(sCtx_1556, in_));
                            
                        }
                        , onError: (_in_: DataIn) =>  {
                            result_1559.error(new Error("Remote call failed without a typed exception"));
                            
                        }
                        
                    }
                    );
                    dataOut_1558.writeInt(reqId_1557);
                    CryptoLib.META.serialize(sCtx_1556, cryptoLib, dataOut_1558);
                    sCtx_1556.sendToRemote(dataOut_1558.toArray());
                    return result_1559;
                    
                }
                , enter: (cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture =>  {
                    const dataOut_1564 = new DataInOut();
                    dataOut_1564.writeByte(4);
                    const argsNames_1566: string[] = ["cryptoLib", "stream"];
                    const argsValues_1567: any[] = [cryptoLib, stream];
                    sCtx_1556.invokeRemoteMethodAfter("enter", null, argsNames_1566, argsValues_1567);
                    CryptoLib.META.serialize(sCtx_1556, cryptoLib, dataOut_1564);
                    ServerRegistrationApiStream.META.serialize(sCtx_1556, stream, dataOut_1564);
                    sCtx_1556.sendToRemote(dataOut_1564.toArray());
                    return AFuture.of();
                    
                }
                , 
            };
            return remoteApiImpl as RegistrationRootApiRemote;
            
        }
        
    }
    ();
    
}
// --- Generated API Remote Interface: RegistrationRootApiRemote ---
export interface RegistrationRootApiRemote extends RegistrationRootApi, RemoteApi  {
    
}
// --- Generated API Local Class: RegistrationRootApiLocal ---
export abstract class RegistrationRootApiLocal<RT extends RegistrationRootApiRemote> implements RegistrationRootApi  {
    protected readonly remoteApi: RT;
    public getRemoteApi(): RT  {
        return this.remoteApi;
        
    }
    protected constructor(remoteApi: RT)  {
        this.remoteApi = remoteApi;
        
    }
    public abstract getAsymmetricPublicKey(cryptoLib: CryptoLib): ARFuture<SignedKey>;
    public abstract enter(cryptoLib: CryptoLib, stream: ServerRegistrationApiStream): AFuture;
    
}
// ===============================================================================
// GENERATED META: AllCustomMeta (Custom FastMeta Implementations)
// ===============================================================================
export namespace AllCustomMeta  {
    export const META_ARRAY_long: FastMetaType<number[]> = new class implements FastMetaType<number[]>  {
        serialize(_sCtx: FastFutureContext, obj: number[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                FastMeta.META_LONG.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): number[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<number>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = FastMeta.META_LONG.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    export const META_ARRAY_UUID: FastMetaType<UUID[]> = new class implements FastMetaType<UUID[]>  {
        serialize(_sCtx: FastFutureContext, obj: UUID[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                FastMeta.META_UUID.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): UUID[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<UUID>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = FastMeta.META_UUID.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    export const META_ARRAY_ServerDescriptor: FastMetaType<ServerDescriptor[]> = new class implements FastMetaType<ServerDescriptor[]>  {
        serialize(_sCtx: FastFutureContext, obj: ServerDescriptor[], out: DataOut): void  {
            SerializerPackNumber.INSTANCE.put(out, obj.length);
            for (const el of obj)  {
                ServerDescriptor.META.serialize(_sCtx, el, out);
                
            }
            
        }
        deserialize(_sCtx: FastFutureContext, in_: DataIn): ServerDescriptor[]  {
            const len = DeserializerPackNumber.INSTANCE.put(in_).valueOf();
            const ar = new Array<ServerDescriptor>(len);
            for (let i = 0;
            i < len;
            i++)  {
                ar[i] = ServerDescriptor.META.deserialize(_sCtx, in_);
                
            }
            return ar;
            
        }
        serializeToBytes(_obj: any): Uint8Array  {
            throw new Error('Not implemented');
            
        }
        deserializeFromBytes(_data: Uint8Array): any  {
            throw new Error('Not implemented');
            
        }
        loadFromFile(_file: string): any  {
            throw new Error('Not implemented');
            
        }
        
    }
    ();
    
}