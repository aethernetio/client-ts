import {
    AKey, CryptoProvider, PairKeys, Signer, SignChecker, Sign, KeyType, CryptoEngine,
    PairAsymKeys, PairSignKeys, PairSymKeys, SignedKey as CryptoSignedKey, CryptoProviderUnit,
    DtoPairKeysAsymSigned,
} from './aether_crypto';
import { RU, HexUtils } from './aether_utils';
import { Log } from './aether_logging';
import { CryptoProviderFactory } from './aether_crypto';
// --- Import concrete DTO classes for createDtoKey ---
import {
    SodiumChacha20Poly1305, HydrogenSecretBox,
    SodiumCurvePublic, HydrogenCurvePublic,
    SodiumCurvePrivate, HydrogenCurvePrivate,
    SodiumSignPublic, HydrogenSignPublic,
    SodiumSignPrivate, HydrogenSignPrivate
} from './aether_api'; // Adjust path as needed


// --- 1. Stub Implementations ---

// AKeyStub, SignStub, SignerStub, CryptoEngineStub, etc. remain unchanged from previous version
// ... (Make sure AKeyStub still includes getAetherTypeId) ...
class AKeyStub implements AKey.Symmetric, AKey.AsymmetricPublic, AKey.AsymmetricPrivate, AKey.SignPublic, AKey.SignPrivate {
    readonly dataArray: Uint8Array; readonly provider: CryptoProviderStub; readonly keyType: KeyType;
    constructor(provider: CryptoProviderStub, type: KeyType, data?: Uint8Array) { this.provider = provider; this.keyType = type; const defaultSize = (type === KeyType.SIGN_PRIVATE) ? 64 : 32; this.dataArray = data || new Uint8Array(defaultSize).fill(type + 1); }
    getData(): Uint8Array { return this.dataArray; } getKeyType(): KeyType { return this.keyType; } size(): number { return this.dataArray.length; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; }
    toSignedKey(signerOrSign: Signer | Sign): CryptoSignedKey { let sign: Sign; if (typeof (signerOrSign as Signer).sign === 'function') { sign = (signerOrSign as Signer).sign(this as AKey); } else { sign = signerOrSign as Sign; } return this.provider.createSignedKey(this as AKey, sign); }
    keyToString(): string { return `${this.getProviderName()}:${KeyType[this.keyType]}:${HexUtils.toHexString(this.dataArray)}`; }
    asSymmetric(): AKey.Symmetric { if (this.keyType !== KeyType.SYMMETRIC) throw new Error(`Invalid cast`); return this; } asAsymmetric(): AKey.AsymmetricPublic { if (this.keyType !== KeyType.ASYMMETRIC_PUBLIC) throw new Error(`Invalid cast`); return this; } asSignPublicKey(): AKey.SignPublic { if (this.keyType !== KeyType.SIGN_PUBLIC) throw new Error(`Invalid cast`); return this; } asSignPrivateKey(): AKey.SignPrivate { if (this.keyType !== KeyType.SIGN_PRIVATE) throw new Error(`Invalid cast`); return this; }
    toCryptoEngine(): CryptoEngine { if (this.keyType === KeyType.SYMMETRIC) { return this.provider.createSymmetricEngine(this.asSymmetric()); } if (this.keyType === KeyType.ASYMMETRIC_PUBLIC) { Log.warn("Stub: Creating asymmetric engine from public key only"); return this.provider.createAsymmetricEngine(this.asAsymmetric()); } throw new Error(`Unsupported`); }
    toSignChecker(): SignChecker { if (this.keyType !== KeyType.SIGN_PUBLIC) { throw new Error(`Invalid KeyType`); } return this.provider.createSigner(this.asSignPublicKey()); }
    getAetherTypeId(): number { switch (this.keyType) { case KeyType.SYMMETRIC: return 99; case KeyType.ASYMMETRIC_PUBLIC: return 98; case KeyType.ASYMMETRIC_PRIVATE: return 97; case KeyType.SIGN_PUBLIC: return 96; case KeyType.SIGN_PRIVATE: return 95; default: return -1; } }
}
class SignStub implements Sign { readonly dataArray: Uint8Array; readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub, data?: Uint8Array) { this.provider = provider; this.dataArray = data || new Uint8Array(64).fill(5); } getSignData(): Uint8Array { return this.dataArray; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } toString(): string { return `${this.getProviderName()}:${HexUtils.toHexString(this.dataArray)}`; } }
class SignerStub implements Signer { readonly provider: CryptoProviderStub; readonly pubKey: AKey.SignPublic; readonly privKey: AKey.SignPrivate | null; constructor(provider: CryptoProviderStub, pub: AKey.SignPublic, priv?: AKey.SignPrivate | null) { this.provider = provider; this.pubKey = pub; this.privKey = priv ?? null; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } getPublicKey(): AKey.SignPublic { return this.pubKey; } sign(dataOrKey: Uint8Array | AKey): Sign { if (!this.privKey) throw new Error("No private key"); const data = (dataOrKey instanceof Uint8Array) ? dataOrKey : (dataOrKey as AKey).getData(); const sig = new Uint8Array(64); if (data.length > 0 && this.privKey.getData().length > 0) sig[0] = (data[0] + this.privKey.getData()[0]) & 0xFF; return new SignStub(this.provider, sig); } checkSign(data: Uint8Array, sign: Sign): boolean { const sd = sign.getSignData(); const pd = this.pubKey.getData(); if (!pd || pd.length === 0) return false; if (this.privKey && this.privKey.getData().length > 0) { const es = (data.length > 0) ? (data[0] + this.privKey.getData()[0]) & 0xFF : 0; return sd.length > 0 && sd[0] === es; } else { const es = (data.length > 0) ? (data[0] + 1) & 0xFF : 0; return sd.length > 0 && sd[0] === es; } } }
class CryptoEngineStub implements CryptoEngine { readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub) { this.provider = provider; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } encrypt(d: Uint8Array): Uint8Array { const e = new Uint8Array(d.length); for (let i = 0; i < d.length; i++) e[i] = (d[i] ^ 0x55) & 0xFF; return e; } decrypt(d: Uint8Array): Uint8Array { const e = new Uint8Array(d.length); for (let i = 0; i < d.length; i++) e[i] = (d[i] ^ 0x55) & 0xFF; return e; } }
class PairAsymKeysStub implements PairAsymKeys { readonly publicKey: AKey.AsymmetricPublic; readonly privateKey: AKey.AsymmetricPrivate; readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub, pub?: AKey.AsymmetricPublic, priv?: AKey.AsymmetricPrivate) { this.provider = provider; this.publicKey = pub || new AKeyStub(provider, KeyType.ASYMMETRIC_PUBLIC) as AKey.AsymmetricPublic; this.privateKey = priv || new AKeyStub(provider, KeyType.ASYMMETRIC_PRIVATE) as AKey.AsymmetricPrivate; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } getPrivateKey(): AKey.AsymmetricPrivate { return this.privateKey; } getPublicKey(): AKey.AsymmetricPublic { return this.publicKey; } toCryptoEngine(): CryptoEngine { return this.provider.createAsymmetricEngine(this.privateKey, this.publicKey); } }
class PairSignKeysStub implements PairSignKeys { readonly publicKey: AKey.SignPublic; readonly privateKey: AKey.SignPrivate | null; readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub, pub?: AKey.SignPublic, priv?: AKey.SignPrivate | null) { this.provider = provider; this.publicKey = pub || new AKeyStub(provider, KeyType.SIGN_PUBLIC) as AKey.SignPublic; this.privateKey = priv === null ? null : (priv || new AKeyStub(provider, KeyType.SIGN_PRIVATE) as AKey.SignPrivate); } toSigner(): Signer { if (!this.privateKey) throw new Error("No private key"); return this.provider.createSigner(this); } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } getPublicKey(): AKey.SignPublic { return this.publicKey; } getPrivateKey(): AKey.SignPrivate | null { return this.privateKey; } }
class PairSymKeysStub implements PairSymKeys { readonly clientKey: AKey.Symmetric; readonly serverKey: AKey.Symmetric; readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub, clientKey?: AKey.Symmetric, serverKey?: AKey.Symmetric) { this.provider = provider; this.clientKey = clientKey || new AKeyStub(provider, KeyType.SYMMETRIC) as AKey.Symmetric; this.serverKey = serverKey || new AKeyStub(provider, KeyType.SYMMETRIC, new Uint8Array(32).fill(99)) as AKey.Symmetric; } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } }
class SignedKeyStub implements CryptoSignedKey { readonly key: AKey; readonly sign: Sign; readonly provider: CryptoProviderStub; constructor(provider: CryptoProviderStub, key: AKey, signOrSigner: Sign | Signer) { this.provider = provider; this.key = key; if (typeof (signOrSigner as Signer).sign === 'function') { this.sign = (signOrSigner as Signer).sign(key); } else { this.sign = signOrSigner as Sign; } } getProviderName(): string { return this.provider.getCryptoLibName(); } getCryptoProvider(): CryptoProvider { return this.provider; } check(soc: AKey.SignPublic | SignChecker): boolean { let checker: SignChecker; if ('toSignChecker' in soc && typeof soc.toSignChecker === 'function') { checker = soc.toSignChecker(); } else { checker = soc as SignChecker; } if (checker.getProviderName() !== this.getProviderName()) { Log.warn("SignedKeyStub check: Provider mismatch"); return false; } try { return checker.checkSign(this.key.getData(), this.sign); } catch (e) { Log.error("Sign check error", e as Error); return false; } } toString(): string { return `${this.key.keyToString()}:${this.sign.toString()}`; } }


// --- 2. CryptoProvider Stub Implementation ---

export class CryptoProviderStub implements CryptoProvider {
    private readonly NAME = "STUB";
    getCryptoLibName(): string { return this.NAME; }
    createAsymmetricKeys(): PairAsymKeys { return new PairAsymKeysStub(this); }
    createSymmetricKey(bytes?: Uint8Array): AKey.Symmetric { return new AKeyStub(this, KeyType.SYMMETRIC, bytes) as AKey.Symmetric; }
    createSignKeys(): PairSignKeys; createSignKeys(publicKey: Uint8Array, privateKey: Uint8Array): PairSignKeys; createSignKeys(publicKey: string, privateKey: string): PairSignKeys; createSignKeys(text: string): PairSignKeys;
    createSignKeys(arg1?: Uint8Array | string, arg2?: Uint8Array | string): PairSignKeys { if (typeof arg1 === 'string' && typeof arg2 === 'string') { return new PairSignKeysStub(this, this.createSignPublicKey(HexUtils.hexToBytes(arg1)), this.createSignPrivateKey(HexUtils.hexToBytes(arg2))); } else if (arg1 instanceof Uint8Array && arg2 instanceof Uint8Array) { return new PairSignKeysStub(this, this.createSignPublicKey(arg1), this.createSignPrivateKey(arg2)); } else if (typeof arg1 === 'string' && arg2 === undefined) { const text = arg1; if (text.includes("|")) { const parts = text.split("|"); if (parts.length !== 2) throw new Error("Invalid format"); const pub = CryptoProviderFactory.createKey<AKey.SignPublic>(parts[0]); const priv = CryptoProviderFactory.createKey<AKey.SignPrivate>(parts[1]); if (pub.getProviderName().toLowerCase() !== this.NAME.toLowerCase() || priv.getProviderName().toLowerCase() !== this.NAME.toLowerCase()) throw new Error(`Provider mismatch`); return new PairSignKeysStub(this, pub, priv); } else { const tt = text.split(":"); let pubHex: string; let privHex: string | undefined; let providerName = this.NAME; try { if (tt.length >= 2 && CryptoProviderFactory.getProvider(tt[0])) { providerName = tt[0]; if (providerName.toLowerCase() !== this.NAME.toLowerCase()) throw new Error(`Provider mismatch`); if (tt.length === 3) { pubHex = tt[1]; privHex = tt[2]; } else { pubHex = tt[1]; } } else if (tt.length === 2) { pubHex = tt[0]; privHex = tt[1]; } else if (tt.length === 1) { pubHex = tt[0]; } else { throw new Error(`Invalid text format: ${text}`); } } catch (e) { if (tt.length === 2) { pubHex = tt[0]; privHex = tt[1]; } else if (tt.length === 1) { pubHex = tt[0]; } else { throw new Error(`Invalid text format: ${text} (${(e as Error).message})`); } } const pub = this.createSignPublicKey(HexUtils.hexToBytes(pubHex)); const priv = privHex ? this.createSignPrivateKey(HexUtils.hexToBytes(privHex)) : null; return new PairSignKeysStub(this, pub, priv); } } else if (arg1 === undefined && arg2 === undefined) { return new PairSignKeysStub(this); } else { throw new Error("Invalid args"); } }
    createKey<T extends AKey>(keyType: KeyType, data: Uint8Array): T; createKey<T extends AKey>(data: string): T; createKey<T extends AKey>(keyType: KeyType, publicKeyHex: string): T;
    createKey<T extends AKey>(arg1: KeyType | string, arg2?: Uint8Array | string): T { if (typeof arg1 === 'string') { const s = arg1; const parts = s.split(":"); if (parts.length !== 3) throw new Error(`Invalid key string: '${s}'`); const providerName = parts[0]; if (providerName.toLowerCase() !== this.NAME.toLowerCase()) throw new Error(`Provider mismatch: ${providerName}`); const keyType = KeyType[parts[1] as keyof typeof KeyType]; if (keyType === undefined) throw new Error(`Invalid KeyType: ${parts[1]}`); const data = HexUtils.hexToBytes(parts[2]); return new AKeyStub(this, keyType, data) as unknown as T; } else if (typeof arg2 === 'string') { const keyType = arg1 as KeyType; const data = HexUtils.hexToBytes(arg2); return new AKeyStub(this, keyType, data) as unknown as T; } else if (arg2 instanceof Uint8Array) { const keyType = arg1 as KeyType; const data = arg2 as Uint8Array; return new AKeyStub(this, keyType, data) as unknown as T; } else { throw new Error("Invalid args"); } }
    createSignedKey(data: string): CryptoSignedKey; createSignedKey(keyType: KeyType, key: Uint8Array, sign: Uint8Array): CryptoSignedKey; createSignedKey(key: AKey, sign: Sign): CryptoSignedKey;
    createSignedKey(arg1: KeyType | string | AKey, arg2?: Uint8Array | Sign, arg3?: Uint8Array): CryptoSignedKey { if (typeof arg1 === 'string') { const d = arg1.replace('|', ':'); const p = d.split(":"); if (p.length !== 4) throw new Error(`Invalid signed key string: ${arg1}`); const pn = p[0]; if (pn.toLowerCase() !== this.NAME.toLowerCase()) throw new Error(`Provider mismatch`); const kt = KeyType[p[1] as keyof typeof KeyType]; if (kt === undefined) throw new Error(`Invalid KeyType: ${p[1]}`); const kd = HexUtils.hexToBytes(p[2]); const sd = HexUtils.hexToBytes(p[3]); const key = this.createKey(kt, kd); const sign = this.createSign(sd); return new SignedKeyStub(this, key, sign); } else if ('getKeyType' in (arg1 as object) && 'getSignData' in (arg2 ?? {})) { return new SignedKeyStub(this, arg1 as AKey, arg2 as Sign); } else if (typeof arg1 === 'number' && arg2 instanceof Uint8Array && arg3 instanceof Uint8Array) { const kt = arg1 as KeyType; const kd = arg2 as Uint8Array; const sd = arg3 as Uint8Array; const key = this.createKey(kt, kd); const sign = this.createSign(sd); return new SignedKeyStub(this, key, sign); } else { throw new Error("Invalid args"); } }
    createSign(data: string): Sign; createSign(data: Uint8Array): Sign;
    createSign(data: string | Uint8Array): Sign { if (typeof data === 'string') { const p = data.split(":"); if (p.length !== 2) throw new Error(`Invalid sign string: ${data}`); if (p[0].toLowerCase() !== this.NAME.toLowerCase()) throw new Error(`Provider mismatch`); const sd = HexUtils.hexToBytes(p[1]); return new SignStub(this, sd); } else { return new SignStub(this, data); } }
    createSigner(): Signer; createSigner(keys: PairSignKeys): Signer; createSigner(publicKey: AKey.SignPublic, privateKey: AKey.SignPrivate): Signer; createSigner(publicKey: AKey.SignPublic): Signer;
    createSigner(arg1?: PairSignKeys | AKey.SignPublic, arg2?: AKey.SignPrivate): Signer { let pub: AKey.SignPublic; let priv: AKey.SignPrivate | null = null; if (arg1 && 'getPublicKey' in arg1 && 'getPrivateKey' in arg1) { pub = arg1.getPublicKey(); priv = arg1.getPrivateKey(); } else if (arg1 && 'getKeyType' in arg1 && arg1.getKeyType() === KeyType.SIGN_PUBLIC && arg2 && 'getKeyType' in arg2 && arg2.getKeyType() === KeyType.SIGN_PRIVATE) { pub = arg1; priv = arg2; } else if (arg1 && 'getKeyType' in arg1 && arg1.getKeyType() === KeyType.SIGN_PUBLIC && arg2 === undefined) { pub = arg1; } else if (arg1 === undefined) { const pair = this.createSignKeys(); pub = pair.getPublicKey(); priv = pair.getPrivateKey(); } else { throw new Error("Invalid args"); } return new SignerStub(this, pub, priv); }
    createSymmetricEngine(key: AKey.Symmetric): CryptoEngine { return new CryptoEngineStub(this); }
    createAsymmetricEngine(key: AKey.AsymmetricPublic): CryptoEngine; createAsymmetricEngine(privateKey: AKey.AsymmetricPrivate, publicKey: AKey.AsymmetricPublic): CryptoEngine; createAsymmetricEngine(keys: PairAsymKeys): CryptoEngine;
    createAsymmetricEngine(arg1: AKey.AsymmetricPublic | AKey.AsymmetricPrivate | PairAsymKeys, arg2?: AKey.AsymmetricPublic): CryptoEngine { return new CryptoEngineStub(this); }
    deriveSymmetricKeys(masterKey: AKey.Symmetric, serverId: number, keyNumber: number): PairSymKeys { const ctd = new Uint8Array(masterKey.size()); const stc = new Uint8Array(masterKey.size()); const md = masterKey.getData(); for (let i = 0; i < md.length; i++) { ctd[i] = (md[i] ^ (serverId & 0xFF) ^ (keyNumber === 0 ? 0x11 : 0x22)) & 0xFF; stc[i] = (md[i] ^ (serverId & 0xFF) ^ (keyNumber === 0 ? 0x33 : 0x44)) & 0xFF; } const ct = this.createSymmetricKey(ctd); const st = this.createSymmetricKey(stc); return new PairSymKeysStub(this, ct, st); }
    createKeyForServer(masterKey: AKey.Symmetric, sid: number): PairSymKeys { Log.debug("Deriving STUB keys for server", { sid }); return this.deriveSymmetricKeys(masterKey, sid, 0); }
    createKeyForClient(masterKey: AKey.Symmetric, sid: number): PairSymKeys { Log.debug("Deriving STUB keys for client", { sid }); return this.deriveSymmetricKeys(masterKey, sid, 1); }
    createSignPublicKey(data: Uint8Array): AKey.SignPublic { return this.createKey(KeyType.SIGN_PUBLIC, data); }
    createSignPrivateKey(data: Uint8Array): AKey.SignPrivate { return this.createKey(KeyType.SIGN_PRIVATE, data); }

}

// --- 3. Registration ---
if (!CryptoProviderFactory.getProvider("STUB")) { // Avoid re-registering
    CryptoProviderFactory.register(new CryptoProviderStub());
    Log.info("Registered STUB CryptoProvider.");
}