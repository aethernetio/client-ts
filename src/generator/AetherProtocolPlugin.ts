// =============================================================================================
// FILE: AetherProtocolPlugin.ts
// PURPOSE: Standalone Generator для генерации TypeScript кода из ADSL YAML
// (ИСПРАВЛЕННАЯ ВЕРСИЯ)
// =============================================================================================

import * as path from 'path';
import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { generateAetherProtocol, IncludeResolver, AetherDslMeta, AetherDslMetaMap } from './aether_protocol_generator';
import { TypeScriptCodeFormatter } from './TypeScriptCodeFormatter';

/**
 * @class AetherProtocolGenerator
 * @description Standalone Generator для генерации TypeScript кода из ADSL YAML
 */
export class AetherProtocolGenerator {
    private readonly formatter = new TypeScriptCodeFormatter();
    private readonly outputFileName: string = 'aether_api.ts';
    private readonly allDslMeta: AetherDslMetaMap = {}; // Новый словарь для хранения всех метаданных
    private readonly processedDslPaths: Set<string> = new Set();

    async generate() {
        console.log('Starting Aether protocol generation...');

        const srcDir = path.resolve(process.cwd(), 'src');
        const outputFile = path.resolve(srcDir, this.outputFileName);

        // 1. Находим все ADSL YAML файлы
        const dslFiles = this.findDslFiles(srcDir);

        if (dslFiles.length === 0) {
            throw new Error('No ADSL YAML files found in src directory');
        }
        console.log(`Found ${dslFiles.length} DSL files:`, dslFiles.map(f => path.basename(f)));

        // 2. Агрегируем метаданные из всех файлов и их includes в allDslMeta
        // Для упрощения, предполагаем, что главный файл — это первый найденный (или самый большой/основной).
        // ИЗМЕНЕНО: Загружаем *все* найденные файлы и их 'includes' рекурсивно.
        for (const filePath of dslFiles) {
            await this.loadAllMetaRecursively(filePath);
        }

        // Выбираем первый файл (по конвенции) как "главный" для генерации.
        const primaryFilePath = dslFiles[0];
        const primaryBaseName = path.basename(primaryFilePath).replace(/\.adsl\.(yaml|json)$/, '');

        if (!this.allDslMeta[primaryBaseName]) {
             // Эта проверка должна быть избыточной, если dslFiles не пуст, но оставляем для безопасности
             throw new Error('Failed to load primary DSL metadata.');
        }

        // 3. Вызываем единый генератор с агрегированными метаданными
        console.log('Running unified code generation...');

        // =================================================================
        // ИСПРАВЛЕНИЕ:
        // Раньше: this.allDslMeta[primaryBaseName]
        // Сейчас: this.allDslMeta
        // Мы должны передать *всю карту* метаданных, а не только метаданные одного файла.
        // =================================================================
        const generatedFiles = await generateAetherProtocol(
            this.allDslMeta,                   // <--- ИСПРАВЛЕНО
            this.createAggregatedResolver(),   // Передаем резолвер для обработки includes
            primaryBaseName
        );

        // 4. Записываем результат (берем только aether_api.ts, который теперь содержит все)
        const finalCode = generatedFiles[this.outputFileName];

        if (!finalCode) {
            throw new Error(`Generator did not produce the expected output file: ${this.outputFileName}`);
        }

        // aether_protocol_generator теперь возвращает код с преамбулой и импортами внутри,
        // поэтому мы просто форматируем его и записываем.
        fs.writeFileSync(outputFile, this.formatter.format(finalCode));
        console.log(`Successfully generated and overwrote: ${outputFile}`);
    }

    private generateFileHeader(): string {
        return `// ===============================================================================\n` +
               `// GENERATED FILE: ${this.outputFileName}\n` +
               `// Generated by AetherProtocolGenerator\n` +
               `// Timestamp: ${new Date().toISOString()}\n` +
               `// ===============================================================================\n\n`;
    }

    // --- Новая логика агрегации ---

    private async loadMetaFromFile(filePath: string): Promise<AetherDslMeta> {
        const dslText = fs.readFileSync(filePath, 'utf8');
        const dslFormat = filePath.endsWith('.json') ? 'json' : 'yaml';
        return dslFormat === 'json'
            ? JSON.parse(dslText) as AetherDslMeta
            : yaml.load(dslText) as AetherDslMeta;
    }

    private async loadAllMetaRecursively(filePath: string): Promise<void> {
        // Убедимся, что путь абсолютный и нормализованный для Set
        const normalizedFilePath = path.resolve(filePath);
        if (this.processedDslPaths.has(normalizedFilePath)) return;

        const baseName = path.basename(normalizedFilePath).replace(/\.adsl\.(yaml|json)$/, '');
        this.processedDslPaths.add(normalizedFilePath);

        const meta = await this.loadMetaFromFile(normalizedFilePath);

        // Добавляем 'api', если он есть (для совместимости с Groovy)
        if (meta.services) {
             meta.api = meta.services;
        }

        this.allDslMeta[baseName] = meta;
        meta.baseName = baseName;

        const includes = meta.includes || [];
        for (const includeName of includes) {
            const includeBaseDir = path.dirname(normalizedFilePath);
            const possibleExtensions = ['.adsl.yaml', '.adsl.json'];
            let foundInclude = false;

            for (const ext of possibleExtensions) {
                const includePath = path.resolve(includeBaseDir, `${includeName}${ext}`);
                if (fs.existsSync(includePath)) {
                    await this.loadAllMetaRecursively(includePath);
                    foundInclude = true;
                    break;
                }
            }

            if (!foundInclude) {
                 // Попытка найти файл в других корневых директориях DSL (если 'common' лежит рядом)
                 // Это упрощенная логика; в идеале нужен полный include path resolver
                 const rootDir = path.dirname(normalizedFilePath); // Ищем в той же директории

                 for (const ext of possibleExtensions) {
                     const siblingPath = path.resolve(rootDir, `../${includeName}/${includeName}${ext}`); // Пробуем найти как соседа
                     const commonPath = path.resolve(rootDir, `${includeName}${ext}`); // Пробуем найти в той же папке

                     if (fs.existsSync(commonPath)) {
                         await this.loadAllMetaRecursively(commonPath);
                         foundInclude = true;
                         break;
                     }
                     if (fs.existsSync(siblingPath)) {
                         await this.loadAllMetaRecursively(siblingPath);
                         foundInclude = true;
                         break;
                     }
                 }

                 if (!foundInclude) {
                    console.warn(`Warning: Could not resolve include '${includeName}' from file ${normalizedFilePath}`);
                 }
            }
        }
    }

    private createAggregatedResolver(): IncludeResolver {
        return async (includeName: string): Promise<AetherDslMeta> => {
            const normalizedName = includeName.replace(/\.adsl\.(yaml|json)$/, '');
            const meta = this.allDslMeta[normalizedName];
            if (!meta) {
                 throw new Error(`Aggregated metadata for '${includeName}' (normalized: '${normalizedName}') not found.`);
            }
            return meta;
        };
    }

    // --- Старая логика поиска (оставлена) ---

    private findDslFiles(dir: string): string[] {
        const files: string[] = [];

        function scanDirectory(currentDir: string) {
            const items = fs.readdirSync(currentDir);

            for (const item of items) {
                const fullPath = path.join(currentDir, item);
                const stat = fs.statSync(fullPath);

                if (stat.isDirectory()) {
                    if (item === 'node_modules' || item.startsWith('.')) continue;
                    scanDirectory(fullPath);
                } else if (item.endsWith('.adsl.yaml') || item.endsWith('.adsl.json')) {
                    files.push(fullPath);
                }
            }
        }

        scanDirectory(dir);
        return files;
    }
}

// ==================== EXECUTABLE PART ====================

// Если файл запущен напрямую, а не импортирован как модуль
if (require.main === module) {
    const generator = new AetherProtocolGenerator();
    generator.generate().catch(error => {
        console.error('Generation failed:', error);
        process.exit(1);
    });
}